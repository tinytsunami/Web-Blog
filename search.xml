<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>圖 Graph</title>
      <link href="//graph/"/>
      <url>//graph/</url>
      
        <content type="html"><![CDATA[<p>這篇文章主要是為了之後的文章做鋪墊，<br>原本是想說跟特殊的圖論算法文章一起發的。</p><span id="more"></span><h1 id="元組"><a href="#元組" class="headerlink" title="元組"></a>元組</h1><p>元組（tuple）是一種數學結構：</p><ul><li>有序元組通常以小括號表示 $(a_0, a_1, a_2, …)$</li><li>無序元組通常以大括號表示 $\{a_0, a_1, a_2, …\}$</li></ul><p>另外，如果一個元組有 $k$ 個元素，我們會稱為 k 元組（k-tuple），例如：$(1,2)$ 為二元組。</p><p>有序元組的元素「順序」不能改變，如果改變，則不為同樣的有序元組，例如： </p><p>$$<br>(1, 2) \neq (2, 1)<br>$$</p><p>無序元組的元素「順序」能夠改變，改變後仍為同樣的元組，例如：</p><p>$$<br>\{1, 2\} &#x3D; \{2, 1\}<br>$$</p><p>元組跟集合最大的兩點不同是：</p><ul><li>元組允許重複元素（這個性質跟多重集一樣），例如：$(1, 2, 2) \neq (1, 2)$</li><li>元組必為有限個元素，集合允許無限個元素</li></ul><div class="note info">            <p>包含 $n$ 個有限元素的 <a href="https://en.wikipedia.org/wiki/Multiset">多重集（multiset）</a>是一個無序 n 元組</p>          </div><div class="note info">            <p>二元組又稱為對（pair），對學生來說，最常見的有序對可能是平面座標上的點 $(x, y)$</p>          </div><h2 id="笛卡兒積"><a href="#笛卡兒積" class="headerlink" title="笛卡兒積"></a>笛卡兒積</h2><p>笛卡兒積（Cartesian product）也被稱為卡氏積，定義是：</p><p>$$<br>A \times B &#x3D; \{(a, b) :|: a \in A ,; b \in B \}<br>$$</p><p>也就是將兩個集合的元素構成對，再包進一個集合中，例子：</p><p>$$<br>\{\text{a}, \text{b}\} \times \{1, 2, 3\} &#x3D; \{(a, 1), (a, 2), (a, 3), (b, 1), (b, 2), (b, 3)\}<br>$$</p><h1 id="圖的定義"><a href="#圖的定義" class="headerlink" title="圖的定義"></a>圖的定義</h1><p>圖（graph）是由點（vertex）的集合、邊（edge）的集合構成的有序對：</p><p>$$<br>G &#x3D; (V, E)<br>$$</p><p>其中：</p><ul><li>圖表示為 $G$</li><li>點集表示為 $V$ 是構成點的集合</li><li>邊集表示為 $E$ 是構成邊的多重集</li></ul><div class="note info">            <p>若邊集元素皆唯一（無重邊）則有 $E \subseteq V \times V$ 的關係</p>          </div><p>圖的例子：</p><p>$$<br>G &#x3D; (V, E), ;\text{where}; V &#x3D; \{a,b,c\},; E&#x3D;\{(a,a), (a,b)\}<br>$$</p><p>通常會畫成：</p><p><img src="https://i.imgur.com/xCacvlo.png"></p><p>上圖為不連通的圖。</p><p>圖若連通（connected）則沒有斷開。更精確地說，任兩點皆存在一條路徑抵達另外一點。</p><h2 id="設置權重"><a href="#設置權重" class="headerlink" title="設置權重"></a>設置權重</h2><p>可以為點或邊設置權重，數學上會使用函數處理：</p><ul><li>定義「點權重」為函數 $W_v(u)$ 帶入點 $u$ 可得該點權重。</li><li>定義「邊權重」為函數 $W_e(u, v)$ 帶入邊 $(u, v)$ 可得該邊權重。</li></ul><div class="note info">            <p>這邊有一個很彆扭的地方是，數學上常常將元組「直接拆開」作為函數輸入</p><p>比方說，函數 $f(x, y) &#x3D; \sqrt{x^2 + y^2}$ 可以代入 $(2, 3)$ 作為參數</p><p>通常不會保留其原本的結構（但偶爾會）即寫為 $f((x, y))$ 或 $f(p)$</p>          </div><h2 id="迴圈與環路"><a href="#迴圈與環路" class="headerlink" title="迴圈與環路"></a>迴圈與環路</h2><p>迴圈（loop）是指有自己到自己的邊：</p><p><img src="https://i.imgur.com/H7I3OFK.png"></p><p>環路（cycle）是圖上可以走一圈到自己：</p><p><img src="https://i.imgur.com/R8glOLi.png"></p><div class="note info">            <p>若圖有負環路（negative cycle）即環路上的所有邊權重和為負，則最短路徑問題的正解為無限小（不存在）；因為從任一點出發抵達負環路後，會持續在環路中繞，權重和會越來越小。<br>可是由於演算法設計的關係，有可能可以解出負環路圖的最短路徑解，但不為最佳解。</p>          </div><h2 id="有向與無向"><a href="#有向與無向" class="headerlink" title="有向與無向"></a>有向與無向</h2><p>有向圖（directed graph）是指圖上的邊是單行道、單向通行：</p><p><img src="https://i.imgur.com/g8tri0h.png"></p><p>無向圖（undirected graph）是指圖上的邊雙向通行：</p><p><img src="https://i.imgur.com/wXKkzUx.png"></p><div class="note info">            <p>無論有向無向，邊集 $E$ 元素皆用小括號表示。無向圖的情況下，寫 $(a, b)$ 跟 $(b, a)$ 的意義是相同的，儘管以大括號表示會更加貼近它的意義，但習慣上不太會這樣表示。</p>          </div><h2 id="點的度數"><a href="#點的度數" class="headerlink" title="點的度數"></a>點的度數</h2><p>無向圖的度數（degree）是指點有多少邊與之相聯，通常點 $u$ 的度數表示為 $deg(u)$</p><p><img src="https://i.imgur.com/RKkf3ru.png"></p><p>有向圖分成：</p><ul><li>入度數（in-degree）而點 $u$ 的度數表示為 $id(u)$</li><li>出度數（out-degree）而點 $u$ 的出度數表示為 $od(u)$</li></ul><p><img src="https://i.imgur.com/LP04A3K.png"></p><h1 id="圖的縮寫"><a href="#圖的縮寫" class="headerlink" title="圖的縮寫"></a>圖的縮寫</h1><p>這裡列出一些常見的圖縮寫：</p><table><thead><tr><th align="center">名稱</th><th align="center">縮寫</th><th align="center">簡述</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">完全圖（complete graph）</td><td align="center">$K_n$</td><td align="center">每點都跟其他點恰一邊相連</td><td align="center">$K_5$ <img src="https://i.imgur.com/RBI2Mym.png"></td></tr><tr><td align="center">環圖（cycle graph）</td><td align="center">$C_n$</td><td align="center">點與邊數相同，且每點的度數皆為 2</td><td align="center">$C_5$ <img src="https://i.imgur.com/lZFNx8h.png"></td></tr><tr><td align="center">完全雙分圖（complete bipartite graph）</td><td align="center">$K_{m,n}$</td><td align="center">點分成兩組，每點都跟另一組所有點恰一邊相連</td><td align="center">$K_{2,3}$ <img src="https://i.imgur.com/TFOTy29.png"></td></tr><tr><td align="center">立方圖（cubical graph）</td><td align="center">$Q_n$</td><td align="center">立方形</td><td align="center">$Q_3$ <img src="https://i.imgur.com/GDdqduy.png"></td></tr><tr><td align="center">有向完全圖（complete graph）</td><td align="center">$K^*_n$</td><td align="center">同 $K_n$ 只是邊有方向</td><td align="center">$K^*_5$ <img src="https://i.imgur.com/LxgKFbm.png"></td></tr><tr><td align="center">輪圖（wheel graph）</td><td align="center">$W_n$</td><td align="center">同 $C_n$ 只是多放一點跟所有點相連</td><td align="center">$W_5$ <img src="https://i.imgur.com/wFQ5Nnj.png"></td></tr></tbody></table><h1 id="圖的表示"><a href="#圖的表示" class="headerlink" title="圖的表示"></a>圖的表示</h1><p>圖在電腦中的表示大致上有兩種，一種基於陣列，另一種基於串列。</p><h2 id="鄰接矩陣"><a href="#鄰接矩陣" class="headerlink" title="鄰接矩陣"></a>鄰接矩陣</h2><p>鄰接矩陣（adjacency matrix）用點跟點的關係做標記：</p><p><img src="https://i.imgur.com/QJWY1bu.png" alt="例 1、有權重無向圖的例子"></p><p>有權重時，為了搭配演算法，常常會將沒有連接的邊，設為 <code>0x7fffffff</code> 即 4 bytes 的整數最大值，其他的邊會放入該邊權重。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 沒有連接權重無限大</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X 0x7FFFFFFF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 鄰接矩陣</span></span><br><span class="line"><span class="type">int</span> G[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        0  1  2  3  4</span></span><br><span class="line"><span class="comment">//        a  b  c  d  e</span></span><br><span class="line"><span class="comment">//  0  a  3  2  1  X  X</span></span><br><span class="line"><span class="comment">//  1  b  2  X  3  4  X</span></span><br><span class="line"><span class="comment">//  2  c  1  3  X  1  X</span></span><br><span class="line"><span class="comment">//  3  d  X  4  1  X  X</span></span><br><span class="line"><span class="comment">//  4  e  X  X  X  X  X</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">G[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">// 邊權重 (c, d) = 1</span></span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/llMue6n.png" alt="例 2、無權重有向圖的例子"></p><p>如果沒有權重，通常會將沒有連接的邊設為 <code>0</code> 做標記。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鄰接矩陣</span></span><br><span class="line"><span class="type">int</span> G[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//        0  1  2  3  4</span></span><br><span class="line"><span class="comment">//        a  b  c  d  e</span></span><br><span class="line"><span class="comment">//  0  a  1  1  0  0  0</span></span><br><span class="line"><span class="comment">//  1  b  0  0  1  1  0</span></span><br><span class="line"><span class="comment">//  2  c  1  0  0  0  0</span></span><br><span class="line"><span class="comment">//  3  d  0  0  1  0  0</span></span><br><span class="line"><span class="comment">//  4  e  0  0  0  0  0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">G[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">// 邊 (c, d) 無連接</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>還有一種比較少見的接合矩陣（incidence matrix）是以點跟邊構成的表示法。</p>          </div><h2 id="鄰接串列"><a href="#鄰接串列" class="headerlink" title="鄰接串列"></a>鄰接串列</h2><p>鄰接矩陣的一個問題是當 $|E| &lt;&lt; |V|^2$ 時，稱為稀疏圖（sparse graph），很浪費空間，另外在演算法中，搜索邊還要翻找一大堆 <code>0</code> 會浪費時間。故此，鄰接串列（adjacency list）只記錄存在的邊，既可節省空間，也可省去一些常數時間。</p><p><img src="https://i.imgur.com/uWL8N3X.png" alt="例 3、稀疏圖的例子"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 鄰接串列</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> id;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">G</span>[12];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  0  a -&gt; c -&gt; NULL</span></span><br><span class="line"><span class="comment">//  1  b -&gt; NULL</span></span><br><span class="line"><span class="comment">//  2  c -&gt; NULL</span></span><br><span class="line"><span class="comment">//  3  d -&gt; NULL</span></span><br><span class="line"><span class="comment">//  4  e -&gt; NULL</span></span><br><span class="line"><span class="comment">//  5  f -&gt; NULL</span></span><br><span class="line"><span class="comment">//  6  g -&gt; NULL</span></span><br><span class="line"><span class="comment">//  7  h -&gt; NULL</span></span><br><span class="line"><span class="comment">//  8  i -&gt; NULL</span></span><br><span class="line"><span class="comment">//  9  j -&gt; NULL</span></span><br><span class="line"><span class="comment">// 10  k -&gt; NULL</span></span><br><span class="line"><span class="comment">// 11  l -&gt; NULL</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">(G[<span class="number">0</span>].next)-&gt;id; <span class="comment">// a -&gt; c, 2</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊羽手札更新歷程 06</title>
      <link href="//tinytsunami-update-06/"/>
      <url>//tinytsunami-update-06/</url>
      
        <content type="html"><![CDATA[<p>話說已經 2022 年了，我都從大學生變成社會新鮮人了！<br>然後終於這個網站加入了「關於我」頁面 XDD</p><span id="more"></span><h1 id="新增關於我"><a href="#新增關於我" class="headerlink" title="新增關於我"></a>新增關於我</h1><p>創站 6 年，終於在 2022 年新增這一頁介紹我自己了（欸！）</p><p>原本創站的宗旨就是把內容寫好、演示做好而已；<br>覺得這些內容跟我本人其實關連不太大，就是說……</p><p>文章好不好其實讀文章就可以了，跟我是誰沒有太大的關係。</p><p>原本生活化的東西都是放 Facebook 那邊，後來覺得有些東西可以放過來，<br>應該是說「羊羽手札」這個 Blog 是正在面臨轉型的時候了吧！</p><p>如果要開始放一些獨立遊戲、遊記類的東西，那麼技術性的內容會被稀釋，<br>可是我覺得這個網站會更新更頻繁，也會更有溫度一點。</p><p>大概吧。</p><h1 id="更新歷程文章說明"><a href="#更新歷程文章說明" class="headerlink" title="更新歷程文章說明"></a>更新歷程文章說明</h1><p>以後歷程列表會放到關於我的頁面，所以「羊羽手札更新歷程」類的文章，<br>都只會紀載做了那些更動，以及遇到的問題這樣。</p><p>以免歷程列表越來越長。</p><h1 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h1><p>因為更新的時候還是有遇到問題，所以這裡寫一下。</p><h2 id="Hexo-文章被當成檔案下載"><a href="#Hexo-文章被當成檔案下載" class="headerlink" title="Hexo 文章被當成檔案下載"></a>Hexo 文章被當成檔案下載</h2><p>點入 Hexo Blog 文章，結果文章被當成檔案下載，<br>參考圖 1，該問題主要原因是文章上的 <code>permalink</code> 結尾忘記放斜線 <code>/</code> 造成的。</p><p><img src="https://i.imgur.com/gD1q2uk.png" alt="圖 1、官方文章的說明"></p><div class="note ">            <p>請參考：<a href="https://hexo.io/docs/front-matter">https://hexo.io/docs/front-matter</a></p>          </div><h2 id="Hexo-側邊欄錨點失效"><a href="#Hexo-側邊欄錨點失效" class="headerlink" title="Hexo 側邊欄錨點失效"></a>Hexo 側邊欄錨點失效</h2><p>然後我發現更新之後，自動生成的錨點連結失效，所以檢查了一下，<br>問題出在主題 Next 目錄下的 <code>themes\next\source\js\utils.js</code> 檔案。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// TOC item animation navigate.</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">var</span> id = event.<span class="property">currentTarget</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> target = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line">  <span class="keyword">var</span> offset = target.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> + <span class="variable language_">window</span>.<span class="property">scrollY</span>;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">anime</span>(&#123;</span><br><span class="line">    targets  : <span class="variable language_">document</span>.<span class="property">scrollingElement</span>,</span><br><span class="line">    duration : <span class="number">500</span>,</span><br><span class="line">    easing   : <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">    <span class="attr">scrollTop</span>: offset + <span class="number">10</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中 <code>target</code> 解析完位置後，如果是中文的話，<br>會是 URL-Encoding 的格式（Percent-encoding），像這樣：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%<span class="variable constant_">E6</span>%9B%<span class="variable constant_">B4</span>%<span class="variable constant_">E6</span>%<span class="number">96</span>%<span class="variable constant_">B0</span>%<span class="variable constant_">E6</span>%<span class="variable constant_">AD</span>%<span class="variable constant_">B7</span>%<span class="variable constant_">E7</span>%<span class="variable constant_">A8</span>%8B</span><br></pre></td></tr></table></figure><p>此時解析位置會找不到，所以可能要「解碼」一次：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// TOC item animation navigate.</span></span><br><span class="line">link.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">var</span> id = event.<span class="property">currentTarget</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;href&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;#&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> target = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="built_in">decodeURI</span>(id)); <span class="comment">// 解完碼再找元素</span></span><br><span class="line">  <span class="keyword">var</span> offset = target.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span> + <span class="variable language_">window</span>.<span class="property">scrollY</span>;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">anime</span>(&#123;</span><br><span class="line">    targets  : <span class="variable language_">document</span>.<span class="property">scrollingElement</span>,</span><br><span class="line">    duration : <span class="number">500</span>,</span><br><span class="line">    easing   : <span class="string">&#x27;linear&#x27;</span>,</span><br><span class="line">    <span class="attr">scrollTop</span>: offset + <span class="number">10</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這樣就可以修復了。</p><h2 id="Hexo-文章密碼設定"><a href="#Hexo-文章密碼設定" class="headerlink" title="Hexo 文章密碼設定"></a>Hexo 文章密碼設定</h2><p>我打算引入的新功能，針對一些特定類型的文章。<br>插件是用 <code>hexo-blog-encrypt</code> 但是他的密碼輸入太花俏 XDD</p><p>所以自己簡單修改了一下，主題叫做 <code>simple</code> 只有簡單的敘述：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hbe hbe-container&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hexo-blog-encrypt&quot;</span> <span class="attr">data-wpm</span>=<span class="string">&quot;&#123;&#123;hbeWrongPassMessage&#125;&#125;&quot;</span> <span class="attr">data-whm</span>=<span class="string">&quot;&#123;&#123;hbeWrongHashMessage&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;hbeData&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hbeData&quot;</span> <span class="attr">data-hmacdigest</span>=<span class="string">&quot;&#123;&#123;hbeHmacDigest&#125;&#125;&quot;</span>&gt;</span><span class="language-handlebars"><span class="template-variable">&#123;&#123;<span class="name">hbeEncryptedData</span>&#125;&#125;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hbe hbe-content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hbe hbe-input hbe-input-blink&quot;</span>&gt;</span>🔒 Encrypted Article</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;hbe hbe-input-field hbe-input-field-blink&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;hbePass&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;&#123;&#123;hbeMessage&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS 方面我也儘量維持簡單的狀態：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* simple theme &#123;&#123;&#123; */</span></span><br><span class="line"><span class="selector-class">.hbe-content</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">4em</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hbe-input</span> &#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0em</span> <span class="number">0em</span> <span class="number">0em</span> <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hbe-input-blink</span> &#123;</span><br><span class="line"><span class="attribute">padding-top</span>: <span class="number">0em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hbe-input-blink</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line"><span class="attribute">padding-top</span>: <span class="number">0em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hbe-input-field</span> &#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hbe-input-field-blink</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* simple theme &#125;&#125;&#125; */</span></span><br></pre></td></tr></table></figure><h2 id="Hexo-顯示-CSS-內容"><a href="#Hexo-顯示-CSS-內容" class="headerlink" title="Hexo 顯示 CSS 內容"></a>Hexo 顯示 CSS 內容</h2><p>Hexo 顯示 CSS 內容，只要用 <code>raw</code> 搭配 <code>codeblock</code> 就可以顯示大括號了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:css %&#125;</span><br><span class="line">&#123;% raw %&#125;</span><br><span class="line">// any css</span><br><span class="line">&#123;% endraw %&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 羊羽手札 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛頓法計算 sqrt 函數</title>
      <link href="//newton-method-sqrt/"/>
      <url>//newton-method-sqrt/</url>
      
        <content type="html"><![CDATA[<p>這篇最早是 Evernote 的筆記，整理之後就放到部落格這裡來了；<br>忘記最早是為了要做什麼，總之就是利用牛頓法計算開根號函數的作法。</p><span id="more"></span><h1 id="函數化"><a href="#函數化" class="headerlink" title="函數化"></a>函數化</h1><p>當要估計 $\text{sqrt}(a) &#x3D; \sqrt{a}$ 時，<br>可以先令 $x_k$  為一近似解，即 $x_k \approx \sqrt{a}$。</p><p>接著整理：</p><p>$x^{2}_{k} \approx a$ </p><p>$x^{2}_{k} - a \approx 0$</p><p>將 $x^{2}_{k} - a$ 視為一函數 $f(p) &#x3D; p^{2} - a$</p><p>令 $p &#x3D; x_{k}$ 就有 $f(x_{k}) &#x3D; x_{k}^{2} - a \approx 0$</p><p>則 $x_k$ 恰為函數近似解 $f(x_k) \approx 0$ 之值。</p><h1 id="泰勒展開"><a href="#泰勒展開" class="headerlink" title="泰勒展開"></a>泰勒展開</h1><p>對函數 $f(p)$ 在 $x_{k}$ 處取泰勒展開（Taylor series）有：</p><p>$f(p) &#x3D; \frac{f(x_{k})}{0!}(p-x_{k})^0  + \frac{f’(x_{k})}{1!}(p-x_{k})^1 + R(p)$</p><p>整理後得：</p><p>$f(p) &#x3D; f(x_{k}) + f’(x_{k})(p-x_{k}) + R(p)$</p><p>其中 $R(p)$ 為餘項。</p><h1 id="迭代關係"><a href="#迭代關係" class="headerlink" title="迭代關係"></a>迭代關係</h1><p>回憶最早的假設 $x_k \approx \sqrt{a}$；</p><p>我們現在考慮迭代法，即 $x_{k+1}$ 比 $x_{k}$ 的答案更精準：</p><p>$x_{k+1} \approx \sqrt{a}$</p><p>取 $p &#x3D; x_{k+1}$ 帶入泰勒展開：</p><p>$f(x_{k+1}) &#x3D; f(x_{k}) + f’(x_{k})(x_{k+1}-x_{k}) + R(x_{k+1})$</p><p>由於是近似解，故捨去餘項 $R(p)$ 有：</p><p>$f(x_{k+1}) \approx f(x_{k}) + f’(x_{k})(x_{k+1}-x_{k})$</p><p>這兩者都可以視做原函數的近似，即 $f(x_k) \approx f(x_{k+1})$ 只是 $f(x_{k+1})$ 更精確。</p><div class="note warning">            <p>注意對象目前是 $f(p) &#x3D; p^{2} - a$ 而 $f(p) \neq \sqrt{p}$</p>          </div><p>之前的函數 $f(p) &#x3D; p^{2} - a$；</p><p>我們現在帶入更精確的 $x_{k+1} \approx \sqrt{a}$ 於是：</p><p>$f(x_{k+1}) &#x3D; x_{k+1}^{2} - a \approx 0$</p><p>同時，展開式：</p><p>$f(x_{k+1}) \approx f(x_{k}) + f’(x_{k})(x_{k+1}-x_{k})$</p><p>兩式串接可得：</p><p>$f(x_{k}) + f’(x_{k})(x_{k+1}-x_{k}) \approx 0$</p><p>$f’(x_{k})(x_{k+1}-x_{k}) \approx -f(x_{k})$</p><p>$x_{k+1}-x_{k} \approx \frac{-f(x_{k})}{f’(x_{k})}$</p><p>$x_{k+1} \approx \frac{-f(x_{k})}{f’(x_{k})} + x_{k}$</p><p>$x_{k+1} \approx x_{k} - \frac{f(x_{k})}{f’(x_{k})}$</p><p>我們現在找到近似關係了，一旦我們確定 $x_{k}$ 那就可以計算右項來推得 $x_{k+1}$。</p><h1 id="程式解"><a href="#程式解" class="headerlink" title="程式解"></a>程式解</h1><p>函數 $f(x_{k}) &#x3D; x_k^2 - a$</p><p>一階微分函數 $f’(x_{k}) &#x3D; 2 \cdot x_k$</p><div class="note info">            <p>這裡的 $a$ 為一常數，也是確定的輸入參數值 $\text{sqrt}(a) &#x3D; \sqrt{a}$</p>          </div><p>整個合併整理：</p><p>$x_{k+1} \approx x_{k} - \frac{\displaystyle x_k^2 - a}{\displaystyle 2 x_k}$</p><p>$x_{k+1} \approx \frac{\displaystyle 2 x_{k}^2}{\displaystyle 2 x_k} - \frac{\displaystyle x_k^2 - a}{\displaystyle 2 x_k}$</p><p>$x_{k+1} \approx \frac{\displaystyle 2 x_{k}^2 - (x_k^2 - a)}{\displaystyle 2 x_k}$</p><p>$x_{k+1} \approx \frac{\displaystyle 2 x_{k}^2 - x_k^2 + a}{\displaystyle 2 x_k}$</p><p>$x_{k+1} \approx \frac{\displaystyle x_{k}^2 + a}{\displaystyle 2 x_k}$</p><p>$x_{k+1} \approx \frac{\displaystyle x_{k}}{\displaystyle 2} + \frac{\displaystyle a}{\displaystyle 2 x_k}$</p><p>$x_{k+1} \approx \frac{\displaystyle 1}{\displaystyle 2} \left( \displaystyle x_{k} + \frac{\displaystyle a}{\displaystyle x_k} \right)$</p><p>所以說 $\text{sqrt}(a)$ 的值為 $x_{k+1} \approx \frac{1}{2} \left(x_{k} + \frac{a}{x_k} \right)$</p><p>只要先隨便令一個 $x_k$ 為任意值，就透過計算 $x_{k+1}$ 得到更精確地解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sqrt</span>(<span class="params">a</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> epsilon = <span class="number">1e-6</span>;        <span class="comment">// 迭代到精準度 1e-6</span></span><br><span class="line">  <span class="keyword">let</span> x0;                    <span class="comment">// x[k]</span></span><br><span class="line">  <span class="keyword">let</span> x1;                    <span class="comment">// x[k+1]</span></span><br><span class="line">  x1 = a;                    <span class="comment">// 隨便猜一個數</span></span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    x0 = x1;                 <span class="comment">// 讓 k 遞增（x[k] 變成 x[k+1]）</span></span><br><span class="line">    x1 = (x0 + a/x0) / <span class="number">2</span>;    <span class="comment">// 公式 x[k+1] = (1/2)(x[k] + a/x[k])</span></span><br><span class="line">  &#125;<span class="keyword">while</span>(x0 - x1 &gt; epsilon); <span class="comment">// 不夠精準則繼續</span></span><br><span class="line">  <span class="keyword">return</span> x1;                 <span class="comment">// 答案在 x[k+1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>程式上的一個細節是，初始猜的值跟終止條件有關。</p><p>若初始條件 $x_{k} &gt; \sqrt a$ 則收斂時 $x_{k+1}$ 會比 $x_{k}$ 更小；<br>反之，初始條件 $x_{k} &lt; \sqrt a$ 則收斂時 $x_{k+1}$ 會比 $x_{k}$ 更大。</p><p>考慮 $a \in N$ 則必有 $a \geq \sqrt a$，<br>則初始條件給 $x_{k} &#x3D; a$ 則必向更小的方向收斂，終止條件就可以避免使用另外的判斷式。</p>          </div><h1 id="勘誤與致謝"><a href="#勘誤與致謝" class="headerlink" title="勘誤與致謝"></a>勘誤與致謝</h1><ul><li>2022&#x2F;09&#x2F;14 感謝 JyhChenHwang 指出程式解段落中的錯誤。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程式設計 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>陣列 Array</title>
      <link href="//array/"/>
      <url>//array/</url>
      
        <content type="html"><![CDATA[<p>本篇是紀載了關於陣列的筆記；<br>原本是跟指標寫在一起的，後來發現跑題太嚴重就獨立一篇出來了。</p><span id="more"></span><div class="note warning">            <p>為避免冗餘，本文的程式範例皆省略起始函數及標頭檔，即 <code>main</code> 跟 <code>include</code> 等程式碼請自行補完</p>          </div><h1 id="陣列宣告"><a href="#陣列宣告" class="headerlink" title="陣列宣告"></a>陣列宣告</h1><p>陣列是一種基本的資料結構，它會分配「連續」的記憶體位置給開發者使用。<br>更簡單的說，就是宣告多筆「某種類型」的資料。</p><p>用 C 語言宣告陣列的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];                        <span class="comment">// 宣告陣列</span></span><br></pre></td></tr></table></figure><p>除此之外，宣告完陣列後，還會額外取得一個「指向陣列開頭」的指標，<br>具體而言，指向陣列開頭的意思是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];                        <span class="comment">// 宣告陣列</span></span><br><span class="line"><span class="keyword">if</span>(*arr == arr[<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">&quot;Y&quot;</span>);     <span class="comment">// 印出 &quot;Y&quot;</span></span><br><span class="line"><span class="keyword">if</span>(arr == &amp;arr[<span class="number">0</span>]) <span class="built_in">printf</span>(<span class="string">&quot;Y&quot;</span>);     <span class="comment">// 印出 &quot;Y&quot;</span></span><br></pre></td></tr></table></figure><p>從這邊可以看出，陣列宣告時附贈的一個起始位置，是第一個元素的記憶體位置。</p><div class="note info">            <p>注意 <code>arr[0]</code> 其實就是 <code>*(arr + 0)</code>；<br>同樣 <code>&amp;arr[0]</code> 也是 <code>&amp;(*(arr + 0))</code> 即 <code>arr + 0</code>。</p>          </div><h1 id="陣列初始化"><a href="#陣列初始化" class="headerlink" title="陣列初始化"></a>陣列初始化</h1><p>通常來說，如果直接有要放入陣列的值，就直接放入了；<br>但有時會需要先準備空陣列的情況。</p><p>C 語言中一種常見的初始化方法是直接透過函數：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 初始化</span></span><br></pre></td></tr></table></figure><p>可是這個 <code>memset</code> 函數，實際上式定義在 <code>string.c</code> 下，目標是用於字串初始化的函數。</p><p>另一個比較奇怪的寫法是透過大括號：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">0</span>,&#125;; <span class="comment">// 或這種</span></span><br></pre></td></tr></table></figure><p>原理是根據 C99 標準，裡面有一段話：</p><blockquote><p>If there are fewer initializers in a brace-enclosed list than there are elements or members of an aggregate, or fewer characters in a string literal used to initialize an array of known size than there are elements in the array, the remainder of the aggregate shall be initialized implicitly the same as objects that have static storage duration.</p></blockquote><p>意思是說，如果一個大括號封閉的初始化值「數量少於宣告的空間」的話，<br>那麼「剩下的」會初始化為 <code>0</code> 值。換句話說：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 前三格為 1,2,3 剩下的 7 格會被初始化為 0</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;       <span class="comment">// 第 1 格為 0 剩下的 9 格會被初始化為 0</span></span><br></pre></td></tr></table></figure><p>另外下面 2 種寫法是有問題的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>] = <span class="number">0</span>;  <span class="comment">// Invalid initializer</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>] = &#123;&#125;; <span class="comment">// ISO C forbids empty initializer braces</span></span><br></pre></td></tr></table></figure><p>但 GCC 針對 <code>&#123;&#125;</code> 會自動將陣列初始化為 <code>0</code> 值。</p><h1 id="傳遞陣列"><a href="#傳遞陣列" class="headerlink" title="傳遞陣列"></a>傳遞陣列</h1><p>由於陣列有多個元素，傳遞給函數時，可以直接給一個起始位置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_one</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        arr[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 初始化為 0</span></span><br><span class="line"><span class="built_in">add_one</span>(x, <span class="number">10</span>);   <span class="comment">// 傳入函數，每個位置都加 1</span></span><br></pre></td></tr></table></figure><p>這裡希望大家把指標當成是一般的變數（存位置而已）<br>所以所謂的「傳陣列」其實就是把 <code>起始位置</code> 跟 <code>大小</code> 傳入函數。</p><p>另一個常見的傳入方式是 <code>起始位置</code> 跟 <code>結束位置</code> 的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_one</span><span class="params">(<span class="type">int</span> *begin, <span class="type">int</span> *end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> *tmp = begin; tmp &lt; end; tmp++)</span><br><span class="line">        (*tmp)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">// 初始化為 0</span></span><br><span class="line"><span class="built_in">add_one</span>(x, x+<span class="number">10</span>);   <span class="comment">// 傳入函數，每個位置都加 1</span></span><br></pre></td></tr></table></figure><div class="note warning">            <p>通常第二種傳法的 <code>結束位置</code> 是再後一格的位置；<br>通常 <code>x[10]</code> 的結束是 <code>x+10</code> 可是最後可存取的位置是 <code>x+9</code>；<br>像是 C++ 的 algorithm 的 sort 函數就是第二種。</p>          </div><div class="note info">            <p>對指標做加法，像 <code>x[10]</code> 的 <code>x+1</code> 意思是 <code>x</code>（起始位置）的下 <code>1</code> 格，<br>實際位置偏移 <code>sizeof(int)</code> 而不是 <code>1</code>。</p>          </div><h1 id="字元陣列"><a href="#字元陣列" class="headerlink" title="字元陣列"></a>字元陣列</h1><p>在 C 語言中，用字元陣列來表示字串（string），<br>所有字串相關的函數都放在 <code>&lt;string.h&gt;</code> 中，只要符合：</p><ul><li>它是一個字元陣列</li><li>它尾末有一個 <code>\0</code>（<code>0x00</code>） 結束符</li></ul><p>都可以直接視做字串；<br>反過來說，字串可以視為一種特別的字元陣列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffdc70</span>: <span class="number">0x68</span>  <span class="number">0x65</span>  <span class="number">0x6c</span>  <span class="number">0x6c</span>  <span class="number">0x6f</span>  <span class="number">0x20</span>  <span class="number">0x77</span>  <span class="number">0x6f</span></span><br><span class="line"><span class="number">0x7fffffffdc78</span>: <span class="number">0x72</span>  <span class="number">0x6c</span>  <span class="number">0x64</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffdc80</span>: <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0xff</span>  <span class="number">0x7f</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br></pre></td></tr></table></figure><p>看起來他存的是 <code>0x68  0x65  0x6c  0x6c  0x6f  0x20  0x77  0x6f 0x72  0x6c  0x64</code><br>這個數字叫作「ASCII」他們一一對應剛剛的 <code>hello world</code>。</p><div class="note info">            <p>請參考 <a href="https://en.wikipedia.org/wiki/ASCII">Wikipedia: ASCII</a></p>          </div><p>從 <code>0x7fffffffdc70</code> 到 <code>0x7fffffffdc83</code> 共 20 格是我們可以用的範圍。</p><div class="note info">            <p>因為是 16 進位，數學應該沒問題吧？ <code>0x83 - 0x70 = 0x13</code><br>換成 10 進位，所以 <code>1 * 16 + 3 = 19</code> 恩？少了一格？</p><p>其實用註標相減要再加 1（也就說 <code>0x83 - 0x70 + 0x01 = 0x14</code> 才對）<br>考慮「1, 2, 3，一共有幾個數字？」這種簡化的問題就很清楚了。</p>          </div><p>也可以顯式地將尾末的結束符寫出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = <span class="string">&quot;hello world\0&quot;</span>;</span><br></pre></td></tr></table></figure><p>看了上例就會知道，這個 <code>str</code> 其實只能放 19 個字，不要多放了！</p><p>這一節最後來疑難排解一些常見的問題：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">3</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, str); <span class="comment">// 0x7fffffffdc89</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); <span class="comment">// abc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嘿？不是只能放 2 個字嗎？為什麼可以正常顯示？<br>說起來是這樣的，因為「恰巧」他的下一位是 <code>0x00</code>（<code>\0</code>）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffdc80</span>:  <span class="number">0x80</span>  <span class="number">0xdd</span>  <span class="number">0xff</span>  <span class="number">0xff</span>  <span class="number">0xff</span>  <span class="number">0x7f</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffdc88</span>:  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x61</span>  <span class="number">0x62</span>  <span class="number">0x63</span></span><br><span class="line"><span class="number">0x7fffffffdc90</span>:  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br></pre></td></tr></table></figure><p>既然已知電腦會配置連續記憶體，那來做個實驗，我們插入一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">3</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">48</span>;          <span class="comment">// 48 對應的字元為 &quot;0&quot;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, str); <span class="comment">// 0x7fffffffdc89</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str); <span class="comment">// abc0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>記憶體中：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffdc80</span>:  <span class="number">0x80</span>  <span class="number">0xdd</span>  <span class="number">0xff</span>  <span class="number">0xff</span>  <span class="number">0xff</span>  <span class="number">0x7f</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffdc88</span>:  <span class="number">0x00</span>  <span class="number">0x61</span>  <span class="number">0x62</span>  <span class="number">0x63</span>  <span class="number">0x30</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  </span><br><span class="line"><span class="number">0x7fffffffdc90</span>:  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br></pre></td></tr></table></figure><p>真不巧，剛剛的輸出為 <code>abc0</code>，<br>因為記憶體中，下一位「恰好」是我們塞進去的那個 <code>48</code> 對應的 ASCII 為字元「0」。<br>也許我們還是手動加個 <code>\0</code> 阻止這種事情發生比較好。</p><p>關於長度的定義：</p><ul><li><code>字串長度</code> 為「字串開頭」直到「<code>\0</code>（這傢伙不算在內）」為止的長度</li><li><code>字元陣列長度</code> 為「宣告的字元陣列的大小」</li></ul><p>前者透過 <code>&lt;string.h&gt;</code> 的函數 <code>strlen</code> 取得，後者則是透過 <code>sizeof</code> 取得。<br>綜上所述，要是你沒有手動放 <code>\0</code> 又「恰巧」後面不為 <code>\0</code> 的話，你就會拿到完全不對的結果。</p><p>注意 <code>char s1[]</code> 跟 <code>char *s2</code>本質上是有差異的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[] = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 是指宣告一個字元陣列放 &#123;&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line"><span class="type">char</span> *s2 = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 是指宣告一個指標，指向 &quot;hello&quot; 靜態空間的起始位置</span></span><br><span class="line"></span><br><span class="line">s1[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;         <span class="comment">// 可修改，印出會是 &quot;pello&quot;</span></span><br><span class="line">s2[<span class="number">0</span>] = <span class="string">&#x27;n&#x27;</span>;         <span class="comment">// 不可修改，會出錯</span></span><br></pre></td></tr></table></figure><h1 id="多維陣列"><a href="#多維陣列" class="headerlink" title="多維陣列"></a>多維陣列</h1><p>C 語言的初學者常常會卡在多維陣列一段時間，但多維陣列的本質就是一維陣列（應該要視為記憶體中的一塊空間）來看待。</p><p>雖然說是多維，但實際上筆者除寫 Python 外，很少看過超過 3 維以上的陣列（或列表、張量）結構，<br>比較常見的多維陣列可能是 2 至 3 維，初學可以把它當成「陣列的陣列」來看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>][<span class="number">10</span>];     <span class="comment">// 一個二維陣列</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>][<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">// 一個三維陣列</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存取 arr1 的第 6 個陣列，再存取第 4 個值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr1[<span class="number">5</span>][<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存取 arr2 的第 2 個陣列的陣列、再存取第 3 個陣列、再存取第 4 個值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr2[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存取 arr1 的第 7 個陣列（起始位置）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr1[<span class="number">6</span>]);</span><br></pre></td></tr></table></figure><h2 id="一維轉換"><a href="#一維轉換" class="headerlink" title="一維轉換"></a>一維轉換</h2><p>多維陣列轉換成一維在 2D 遊戲中是非常常用的概念，<br>主要是用來算圖片編號、用來記錄地圖位置等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">100</span>];    <span class="comment">// 一維陣列</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>][<span class="number">10</span>]; <span class="comment">// 二維陣列</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 arr1 的值塞給 arr2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y = i / <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> x = i % <span class="number">10</span>;</span><br><span class="line">    arr2[y][x] = arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 arr2 的值塞給 arr1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">10</span>; y++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++)</span><br><span class="line">        arr1[y * <span class="number">10</span> + x] = arr2[y][x];</span><br></pre></td></tr></table></figure><p>更多維度也是同理（以四維為例）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[<span class="number">120</span>];        <span class="comment">// 一維陣列</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>]; <span class="comment">// 多維陣列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">120</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = (i / (<span class="number">3</span> * <span class="number">4</span> * <span class="number">5</span>));</span><br><span class="line">    <span class="type">int</span> b = (i /     (<span class="number">4</span> * <span class="number">5</span>)) % <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> c = (i /         (<span class="number">5</span>)) % <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> d = (i              ) % <span class="number">5</span>;</span><br><span class="line">    arr2[a][b][c][d] = arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多維轉換的核心想法是算這個註標分成幾塊會是第幾個。</p><p>以 arr1[100] 為例，而 arr2 有：</p><ul><li>arr2[0] 是一個共 3*4*5 &#x3D; 60 個元素的陣列</li><li>arr2[1] 是一個共 3*4*5 &#x3D; 60 個元素的陣列</li></ul><p>共 100 個元素，每 60 個放一組，逢 2 循環（僅 1 輪），顯然放在 arr2[(100&#x2F;60)%2] 中。</p><p>接下來考慮 arr2 有：</p><ul><li>arr2[0][0] 是一個共 4*5 &#x3D; 20 個元素的陣列</li><li>arr2[0][1] 是一個共 4*5 &#x3D; 20 個元素的陣列</li><li>arr2[0][2] 是一個共 4*5 &#x3D; 20 個元素的陣列</li><li>arr2[1][0] 是一個共 4*5 &#x3D; 20 個元素的陣列</li><li>arr2[1][1] 是一個共 4*5 &#x3D; 20 個元素的陣列</li><li>arr2[1][2] 是一個共 4*5 &#x3D; 20 個元素的陣列</li></ul><p>共 100 個元素每 20 個放一組，逢 3 循環（僅 2 輪），顯然放在 arr2[1][(100&#x2F;20)%3] 中。</p><p>以此類推。</p><h2 id="行列優先序"><a href="#行列優先序" class="headerlink" title="行列優先序"></a>行列優先序</h2><p>行列優先序（Row- &#x2F; Column- major order）是指安排記憶體的方式，由於高階語言的特性，所以理論上抽象的記憶體位置是不影響存取的，作業系統會自動幫你處理這個部分，但符合底層設計的程式會有更好的效能。</p><div class="note info">            <p>主要的原因是機器跟作業系統的設計，牽涉記憶體的分層架構（hierarchical architecture）在空間區域性（locality of space）下，讀取時會抓一大塊資料（分頁）到快取記憶體。</p><p>此時要是空間區域性失效，即每次存取的值都在不同的分頁中，就會導致大量的分頁錯誤（page faults）讓作業系統需要大量中斷（interrupt）來幫你處理，具體來說就是把正確的分頁放到快取中，這個狀態被稱為「顛簸（thrashing）」。</p>          </div><p>來看例子，下面的程式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N (1000000)</span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> arr[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">        arr[i][j] = i * N + j;</span><br></pre></td></tr></table></figure><p>會快過下面這個： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N (1000000)</span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> arr[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        arr[i][j] = i * N + j;</span><br></pre></td></tr></table></figure><h2 id="傳遞多維陣列"><a href="#傳遞多維陣列" class="headerlink" title="傳遞多維陣列"></a>傳遞多維陣列</h2><p>傳遞多維陣列到函數，總共有三種方法：</p><p>第一種是維持陣列的樣貌：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> arr[][<span class="number">2</span>][<span class="number">3</span>])</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">f(arr);</span><br></pre></td></tr></table></figure><p>很明顯，這個函數告訴你要準備傳入一個陣列，通常會搭配長度來使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> arr[][<span class="number">2</span>][<span class="number">3</span>], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">f(arr, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>第二種是將 <code>[]</code> 改成指標 <code>*</code> 的形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> *arr[<span class="number">2</span>][<span class="number">3</span>])</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">f(arr);</span><br></pre></td></tr></table></figure><p>但這個看起來就像是在說「我要傳入 2*3 個 int 指標」而不是我要傳入多維陣列。</p><p>最後一個則是單個參數中，不提供任何大小訊息，<br>直接傳遞起始位置，將整個陣列當成指標來用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> ***arr)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1</span>][<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">f(arr);</span><br></pre></td></tr></table></figure><div class="note info">            <p>除指標外，其他的核心要旨都是「除第一個維度外，其他維度都要顯式寫出。」</p>          </div>]]></content>
      
      
      <categories>
          
          <category> 程式設計 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分治與分割 Divide and Partition</title>
      <link href="//divide-and-partition/"/>
      <url>//divide-and-partition/</url>
      
        <content type="html"><![CDATA[<p>這篇算是心得總結，不太會按照傳統演算法的順序來講分治；分治法是演算法中很基礎的東西。</p><span id="more"></span><p>有趣的是，我在尚未了解算法前，一直沒有掌握分治法的核心想法，<br>總覺得就是「系統上地」將複雜的系統切成小塊再拼合，<br>於是很長一段時間裡，都覺得分治僅適用於系統。</p><p>但實際上，分治不只系統可以做，邏輯上也可以。</p><p>隱約記得某次演算法課上提過，分割（partition）跟分治（divide and conquer）是不同的。<br>兩者基本上差在一個合併的步驟。</p><h1 id="算法分割"><a href="#算法分割" class="headerlink" title="算法分割"></a>算法分割</h1><p>算法的分割（partition）是指邏輯上的。用 <a href="https://leetcode.com/problems/sort-colors/">LeetCode 75</a> 考慮，<br>題目大意是：「排序數字，數字只有三種，但會重複。」</p><p>這個實作起來很容易，隨意一個排序演算法（可能需要稍做修改）都可以處理。</p><div class="note success">            <p>請參考 <a href="/sort/" title="排序 Sort">排序 Sort</a></p>          </div><p>看到下面另一句話：<br>Follow up: Could you come up with a one-pass algorithm using only constant extra space?<br>這話暗示了類似 Bitonic Sort 之類的東西。</p><p>同樣是 $O(n)$ 我們可以從另一個角度來看，<br>如果我能保證下列三件事，那代表這個數列已經排序完成：</p><ul><li>所有的 0 都在 1 前面 </li><li>所有的 1 都在 2 前面</li><li>所有的 0 都在 2 前面</li></ul><p>至於為何不是兩個條件的原因留給讀者自己思考。</p><p>邏輯上來說，我只要寫一個函數，讓 $a$ 永遠在 $b$ 之前，然後依序把條件帶入即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swapWith</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize, <span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;                                    <span class="comment">// 從頭開始</span></span><br><span class="line">    <span class="type">int</span> j = numsSize - <span class="number">1</span>;                         <span class="comment">// 從尾開始</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; numsSize &amp;&amp; nums[i] != b) i++;  <span class="comment">// i 去找 j 前面的 b</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>       &amp;&amp; nums[j] != a) j--;  <span class="comment">// j 去找 i 後面的 a</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">        &#123;</span><br><span class="line">            t = nums[i];                          <span class="comment">// 交換兩個數</span></span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然後：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    swapWith(nums, numsSize, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 確保所有的 0 在 1 前</span></span><br><span class="line">    swapWith(nums, numsSize, <span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 確保所有的 0 在 2 前</span></span><br><span class="line">    swapWith(nums, numsSize, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 確保所有的 1 在 2 前</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一個類似的東西：<a href="https://leetcode.com/problems/valid-parentheses/">LeetCode 20</a>。</p><h1 id="算法分治"><a href="#算法分治" class="headerlink" title="算法分治"></a>算法分治</h1><p>分治法還是以合併排序最經典，但通常的合併階段沒有合併排序那麼單純；</p><p>通常第一步是粗估暴力破解的時間，然後提出一個分治法的假設，<br>如果光是合併就跟暴力破解的複雜度一樣或是接近，那基本上就是做白工。</p><h2 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h2><p>由於分治多跟遞迴有關，此時主定理（master theorem）就可以幫我們估計時間：</p><p>$$<br>T(n) &#x3D; aT(\frac{n}{b}) + f(n)<br>$$</p><p>這裡的 $T(n)$ 是大問題的耗時，而 $f(n)$ 是合併的耗時；<br>然後 $a$ 是子問題數，$\frac{n}{b}$ 是子問題規模。</p><p>然後拿 $f(n)$ 跟 $\log_{b}(a)$ 比大小，不嚴謹地表示：</p><ul><li>如果 $f(n) &#x3D; O(n^{\log_{b}(a)})$，則 $T(n) &#x3D; \Theta(n^{\log_{b}(a)})$</li><li>如果 $f(n) &#x3D; \Omega(n^{\log_{b}(a)})$，則 $T(n) &#x3D; \Theta(f(n))$</li><li>如果 $f(n) &#x3D; \Theta(n^{\log_{b}(a)}\log^{k}(n))$，而 $k \geq 0$，則 $T(n) &#x3D; \Theta(n^{\log_{b}(a)}\log^{k+1}(n))$</li></ul><p>簡易的白話文如下：</p><ul><li>如果「各個擊破的時間」比「合併結果的時間」長，那時間是「各個擊破的時間」</li><li>如果「合併結果的時間」比「各個擊破的時間」長，那時間是「合併結果的時間」</li><li>如果「合併結果的時間」跟「各個擊破的時間」只差 $\log^{k}$ 時間，那時間是「各個擊破的時間，再多一點 $\log^{k+1}$」</li></ul><h2 id="無效的分治"><a href="#無效的分治" class="headerlink" title="無效的分治"></a>無效的分治</h2><p>考慮一個例子 <a href="https://leetcode.com/problems/count-of-range-sum/">LeetCode 327</a>。<br>題目大意是，給定一個序列跟範圍，數一數有多少連續子序列和在這個範圍內。</p><p>我們粗估暴力破解，也就是以 $i$ 及 $j$ 找出所有的開頭及結尾，並以 $k$ 從 $i$ 累計到 $j$，<br>這樣的話，時間複雜度為 $O(n^3)$。顯然，如果我們希望做得更好，那麼至少得少於這個數字。</p><p>現在我們提出一個無效分治法的例子：</p><ul><li>首先將序列均分成兩部分 $[0, \frac{n}{2}]$ 及 $[\frac{n}{2}, n]$ </li><li>兩個部分各自計算數量</li><li>然後讓 $i &#x3D; [0, \frac{n}{2}] \in Z$ 且 $j &#x3D; [\frac{n}{2}, n] \in Z$ 為兩部分註標</li><li>計算合併的結果</li></ul><p>以他的 Example 1 為例：</p><ul><li>$[-2, 5, -1]$ 被分成 $[-2]$ 及 $[5, -1]$ 兩塊</li><li>$[-2]$ 有 1 個（從 0 累計到 0，也就是 $-2$）</li><li>$[5, -1]$ 有 1 個（從 1 累計到 1，也就是 $-1$）</li><li>然後 $i &#x3D; \{0\}$ 且 $j &#x3D; \{0, 1\}$ 計算</li><li>$i &#x3D; 0, j &#x3D; 0$ 有 $-2 + 5 &#x3D; 3$ 不合</li><li>$i &#x3D; 0, j &#x3D; 1$ 有 $-2 + 5 + -1 &#x3D; 2$ 總計 1 個</li><li>合計共 3 組連續子序列落在 $[-2, 2]$ 中</li></ul><p>為什麼這個做法會無效呢？我們用主定理估計看看……</p><p>$$<br>T(n) &#x3D; 2T(n&#x2F;2) + f(n)<br>$$</p><p>其中合併時間 $f(n)$ 的粗估如下，首先考量 $i$ 跟 $j$ 兩個註標至多是序列長的一半，即 $\frac{n}{2}$，</p><p>那麼，顯然計算從 $i$ 到 $j$ 需要 $k_1$（累計 $i$ 到第一部分結尾） 跟 $k_2$（累計第二部分開頭到 $j$），</p><p>而 $k_1$ 及 $k_2$ 的範圍是 $\frac{n}{2}$。</p><p>也就是說 $f(n) &#x3D; O(\frac{n}{2}^3) &#x3D; O(\frac{1}{8}n^3)$，基本上 $f(n) &#x3D; O(n^3)$；</p><p>主定理條件 $f(n) &#x3D; \Omega(n^{\log_{2}(2)}) &#x3D; \Omega(n)$ 有 $T(n) &#x3D; \Theta(f(n)) &#x3D; \Theta(n^3)$，顯然跟暴力破解相比，沒有任何好處。</p><h2 id="分析與最佳化"><a href="#分析與最佳化" class="headerlink" title="分析與最佳化"></a>分析與最佳化</h2><p>從主定理可以觀察到一個很重要的事實：反過來說，如果能壓低 $f(n)$ 的值，就能一定程度壓低 $T(n)$。</p><p>這裡我們利用「連續」的性質，考慮圖一。如果已經計算出兩個部份的結果，而我們額外計算的，必然是中間藍色（A 部分）及橘色（B 部分）的結果，也就是從中間向兩側延伸的序列。</p><p><img src="https://i.imgur.com/rtMlrEh.png" alt="圖一、連續子序列合併"></p><p>如果是這樣，那我們可以直接用暫存空間累計，考慮圖二。</p><p><img src="https://i.imgur.com/DAvvxOa.png" alt="圖二、轉換成累加序列"></p><p>這樣一來，我們就可以在 $f(n) &#x3D; O((\frac{n}{2})^2)$ 內計算完 $i$ 及 $j$，<br>累計也不需要 $k$，直接將暫存空間相加即可。根據主定理，總複雜度被降到 $T(n) &#x3D; \Theta(f(n)) &#x3D; \Theta(n^2)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">in</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= lower &amp;&amp; x &lt;= upper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">countRangeSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Boundary</span></span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">1</span>) </span><br><span class="line">        <span class="keyword">return</span> in(nums[<span class="number">0</span>], lower, upper) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Divide</span></span><br><span class="line">    <span class="type">int</span> half = numsSize / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> *partA = nums;</span><br><span class="line">    <span class="type">int</span> *partB = nums + half;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sizeA = half;</span><br><span class="line">    <span class="type">int</span> sizeB = numsSize - half;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> countA = countRangeSum(partA, sizeA, lower, upper);</span><br><span class="line">    <span class="type">int</span> countB = countRangeSum(partB, sizeB, lower, upper);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Merge</span></span><br><span class="line">    <span class="type">long</span> *tmp = (<span class="type">long</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>) * numsSize);</span><br><span class="line">    </span><br><span class="line">    tmp[half - <span class="number">1</span>] = nums[half - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = half - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        tmp[i] = tmp[i + <span class="number">1</span>] + nums[i];</span><br><span class="line">    </span><br><span class="line">    tmp[half] = nums[half];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = half + <span class="number">1</span>; j &lt; numsSize; j++) </span><br><span class="line">        tmp[j] = tmp[j - <span class="number">1</span>] + nums[j];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> countM = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sizeA; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = sizeA; j &lt; numsSize; j++)</span><br><span class="line">            <span class="keyword">if</span> (in(tmp[i] + tmp[j], lower, upper))</span><br><span class="line">                countM++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> countA + countB + countM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>注意程式碼的 <code>long</code> 型別，這裡沒針對範圍處理，使用 <code>int</code> 會出錯；<br>而且這個程式碼還不夠快，會超時（TLE, Time Limit Exceeded）</p>          </div><h2 id="進一步最佳化"><a href="#進一步最佳化" class="headerlink" title="進一步最佳化"></a>進一步最佳化</h2><div class="note success">            <p>接下來的內容是參考 Discuss 中排名最高的解</p>          </div><p>透過壓低 $f(n)$ 所能觸及的下界（如果能辦到），透過主定理也能大概猜到，是 $T(n) &#x3D; \Theta(n\log(n))$，<br>這個值出現在 $f(n)$ 被壓到只有 $\Theta(n)$ 時，為 $k&#x3D;0$ 的 $\log^{k}(n)$ 倍得到。</p><p>那麼，如何讓 $f(n)$ 進一步變小呢？</p><p>從上面程式可以發現，導致問題是 39 至 42 行，這裡的瓶頸導致 $f(n) &#x3D; O(n^2)$ 的結果。</p><p>就像第一次最佳化一樣，題目不需要子序列的總和。這代表打從一開始就應該用「累加序列」運算，而元素的差就是子序列的總和，見圖三：累加序列 $n$ 中，元素的差（任意 $n_j - n_i$）對應原始序列 $i$ 到 $j$ 的累加。圖中有 $n_6 - n_3 &#x3D; 10 - 4 &#x3D; 6$ 為 5、-6、7 三元素的和。</p><p><img src="https://i.imgur.com/kXm0YJw.png" alt="圖三、累加序列的元素差"></p><p>然後，一旦用累加序列取代，那麼只要在子問題合併前不打亂，順序就不重要了，可以透過排序處理。換句話說，由於我們合併階段，關心的是「跨越兩個子問題的序列和」，所以個別排序不會出問題。</p><p>考慮圖四，其中有 $\text{sorted}_5 - \text{sorted}_1 &#x3D; 9 - 1 &#x3D; 7$ 它對應的序列「不為原序列第 1 至第 5 個元素」而是對應「第 0 至第 4 個元素（$n_4 - n_0$）」。只要任意 $\text{sorted}_j - \text{sorted}_i$ 的 $i$ 都落在前半段，而 $j$ 落在後半段，那麼就一定唯一對應原序列的一段序列和，只是對應的註標不同。</p><p><img src="https://i.imgur.com/kWFHiAm.png" alt="圖四、累加序列排序的意義"></p><p>同樣地，我們透過切割兩半的方法去處理，假設子問題的區塊都有單調性（即已排序過），看看能不能省略計數的步驟。</p><ul><li>如果某個元素 $n_i$ 在第一區塊中、而 $n_j$ 在第二區塊，且兩個區塊都有單調性</li><li>我們遍歷所有的 $n_i$ 並尋找跟 $n_j$ 的關係</li><li>如果有註標 $k$ 有 $n_k - n_i \leq \text{lower}$ 則對於某個 $n_i$ 來說，元素 $n_k$ 不能再小</li><li>如果有註標 $j$ 有 $n_j - n_i \geq \text{upper}$ 則對於某個 $n_i$ 來說，元素 $n_j$ 不能再大</li></ul><p>然後關鍵是，由於單調性存在，所以遍歷 $i$ 時，值 $n_i$ 只會遞增，也就是說：</p><ul><li>當 $i$ 遞增，則 $n_i$ 變大</li><li>所以 $n_k - n_i$ 變小，之前的 $k$ 為首個滿足條件（恰好大於 $\text{lower}$）的註標</li><li>為了再次滿足條件，$n_k$ 必須變大，使 $n_k - n_i$ 變大</li><li>故 $k$ 必須遞增</li></ul><p>觀察另一個註標 $j$ 也有類似的狀況，只是這次要求找「不滿足」條件的註標：</p><ul><li>當 $i$ 遞增，則 $n_i$ 變大</li><li>所以 $n_j - n_i$ 變小，之前的 $j$ 為首個「不滿足」條件（恰好大於 $\text{upper}$）的註標</li><li>為了再次「不滿足」條件，$n_j$ 必須變大，使 $n_j - n_i$ 變大</li><li>故 $j$ 必須遞增</li></ul><p>計算完成後，兩個註標：</p><ul><li>註標 $k$ 對應的值 $n_k$ 為滿足 $n_k - n_i \geq \text{lower}$ 的首個註標</li><li>註標 $j$ 對應的值 $n_j$ 為滿足 $n_j - n_i &gt; \text{upper}$ 的首個註標</li></ul><p>則 $j - k$ 為兩個子問題合併情況的解。</p><p>剩下最後一個問題，就是子問題的單調性如何確保。實際上，可以直接透過合併排序的合併階段來實現。</p><p>稍微重新整理一下剛剛的流程：</p><ul><li>把整個序列轉換成累加序列，共花 $O(n)$</li><li>將問題切割成兩個子問題</li><li>遍歷第一區塊所有的 $n_i$ 計算 $n_j - n_i$ 及 $n_k - n_i$（注意 $j$ 跟 $k$ 只會變大，花費 $O(n)$）</li><li>每個子問題透過合併階段，花費 $O(n)$ 維持單調性</li><li>將兩個子問題解加上 $j - k$ 為答案</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countRangeSum</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 累加序列</span></span><br><span class="line">    <span class="type">int</span> sumsSize = numsSize;</span><br><span class="line">    <span class="type">long</span> *sums = (<span class="type">long</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>) * sumsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立累加序列</span></span><br><span class="line">    sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; sumsSize; i++)</span><br><span class="line">        sums[i] = sums[i - <span class="number">1</span>] + nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遞迴解區間 [0, sumsSize)</span></span><br><span class="line">    <span class="keyword">return</span> f(sums, <span class="number">0</span>, sumsSize, lower, upper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> *sums, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> lower, <span class="type">int</span> upper)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 單個元素則直接判斷範圍</span></span><br><span class="line">    <span class="keyword">if</span> (end - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sums[start] &gt;= lower &amp;&amp; sums[start] &lt;= upper ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將問題切割成子問題</span></span><br><span class="line">    <span class="type">int</span> mid = (end + start) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> count = f(sums, start, mid, lower, upper) <span class="comment">// 子問題 A</span></span><br><span class="line">              + f(sums, mid, end, lower, upper);  <span class="comment">// 子問題 B</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合併階段的暫存序列</span></span><br><span class="line">    <span class="type">long</span> *tmps = (<span class="type">long</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">long</span>) * (end - start));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用於計算的註標群</span></span><br><span class="line">    <span class="type">int</span> k = mid; <span class="comment">// 尋找累加序列的下界（首個符合條件的註標）</span></span><br><span class="line">    <span class="type">int</span> j = mid; <span class="comment">// 尋找累加序列的上界（首個不符合條件的註標）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用於合併的註標群</span></span><br><span class="line">    <span class="type">int</span> t = mid; <span class="comment">// 子問題 B 的元素註標</span></span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;   <span class="comment">// 合併暫存序列的註標</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍歷子問題 A 的累加序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start; i &lt; mid; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 計算數量</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt; end &amp;&amp; sums[k] - sums[i] &lt;  lower) k++; <span class="comment">// 尋找下界</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; end &amp;&amp; sums[j] - sums[i] &lt;= upper) j++; <span class="comment">// 尋找上界</span></span><br><span class="line">        count += j - k;                                   <span class="comment">// 計算數量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合併階段</span></span><br><span class="line">        <span class="comment">// 跟「子問題 A 首個的元素」比較</span></span><br><span class="line">        <span class="comment">// 如果「子問題 B 的元素」比較小，則放進合併序列中</span></span><br><span class="line">        <span class="keyword">while</span>(t &lt; end &amp;&amp; sums[t] &lt; sums[i])</span><br><span class="line">            tmps[r++] = sums[t++];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳出迴圈後，保證子問題 A 首個元素比較小，直接放進序列中</span></span><br><span class="line">        tmps[r++] = sums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把合併序列剩下的複製進原序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">        sums[start + i] = tmps[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 釋放掉合併暫存序列</span></span><br><span class="line">    <span class="built_in">free</span>(tmps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回傳答案</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>指標 Pointer</title>
      <link href="//pointer/"/>
      <url>//pointer/</url>
      
        <content type="html"><![CDATA[<p>本篇是紀載了關於指標的筆記。我稍微調整了撰寫的順序。<br>另外就是增加了一些額外的知識來補足一些內容。</p><span id="more"></span><div class="note warning">            <p>為避免冗餘，本文的程式範例皆省略起始函數及標頭檔，即 <code>main</code> 跟 <code>include</code> 等程式碼請自行補完</p>          </div><h1 id="運算子"><a href="#運算子" class="headerlink" title="運算子"></a>運算子</h1><p>指標的運算子，書中大致上會寫兩種：</p><ul><li>取址運算子</li><li>取值運算子</li></ul><p>但是如果考慮可以作用在位置上的運算子，其數量應該更多，比方說加法。</p><h2 id="取址運算子"><a href="#取址運算子" class="headerlink" title="取址運算子"></a>取址運算子</h2><p>取址運算子是「取得位置」的運算子。<br>它的符號 <code>&amp;</code> 加在變數前面可以取得存放這個變數的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">&amp;num;    <span class="comment">// 取得位置</span></span><br></pre></td></tr></table></figure><p>這是指標最基本的運算子，也是較不複雜的一個。</p><h2 id="取值運算子"><a href="#取值運算子" class="headerlink" title="取值運算子"></a>取值運算子</h2><p>取值運算子有兩個用途：</p><ul><li>宣告指標</li><li>取得資料</li></ul><p>如果一開始不分離兩個功能，可能會在之後搞得亂七八糟，<br>它的符號 <code>*</code> 加在變數前面可能有兩種作用，請看它所在的位置判斷。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *num; <span class="comment">// 功能 1：宣告指標</span></span><br><span class="line">*num;     <span class="comment">// 功能 2：取得資料</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>如果 <code>*</code> 出現在宣告，則代表宣告指標；除此之外是取得資料</p>          </div><h1 id="指標與變數"><a href="#指標與變數" class="headerlink" title="指標與變數"></a>指標與變數</h1><p>搭配取址運算子，可以寫出普通程式設計教科書的範例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iNum;               <span class="comment">// 宣告變數</span></span><br><span class="line"><span class="type">int</span> *pNum;              <span class="comment">// 宣告指標</span></span><br><span class="line">iNum = <span class="number">10</span>;              <span class="comment">// 設定變數值</span></span><br><span class="line">pNum = &amp;iNum;           <span class="comment">// 設定指標指向變數</span></span><br><span class="line">*pNum += <span class="number">2</span>;             <span class="comment">// 指標指向的變數加 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, iNum);     <span class="comment">// 印出 12</span></span><br></pre></td></tr></table></figure><p>我會建議讀者能把指標想成變數：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iNum;               <span class="comment">// 宣告變數</span></span><br><span class="line"><span class="type">int</span> *pNum;              <span class="comment">// 宣告指標</span></span><br><span class="line">iNum = <span class="number">10</span>;              <span class="comment">// 設定變數值</span></span><br><span class="line">pNum = &amp;iNum;           <span class="comment">// 設定指標值</span></span><br><span class="line">*pNum += <span class="number">2</span>;             <span class="comment">// 指標「存放的」變數加 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, iNum);     <span class="comment">// 印出 12</span></span><br></pre></td></tr></table></figure><p>以上面範例來說，傳統的畫法：</p><table><thead><tr><th align="center">名稱</th><th align="center">資料</th><th align="center">指向</th></tr></thead><tbody><tr><td align="center">iNum</td><td align="center">10</td><td align="center">x</td></tr><tr><td align="center">pNum</td><td align="center">10</td><td align="center">↑</td></tr></tbody></table><div class="note warning">            <p>筆者實際上不喜歡使用箭頭的指標畫法（因為其實他是「位置的值」）；<br>原因是會使初學者混亂，但如果彼此對此都很熟悉，那討論時使用倒無所謂。</p>          </div><p>筆者剛剛提到「把指標想成變數」這件事情，<br>原因是一旦這樣想像，很多事情就變得更清晰了：</p><table><thead><tr><th align="center">變數名稱</th><th align="center">變數資料</th><th align="center">變數位置</th></tr></thead><tbody><tr><td align="center">iNum</td><td align="center">10</td><td align="center">0x7fffffffdc74</td></tr><tr><td align="center">pNum</td><td align="center"><code>0x7fffffffdc74</code></td><td align="center">0x7fffffffdc78</td></tr></tbody></table><p>當我們執行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pNum = &amp;iNum; <span class="comment">// 設定指標值</span></span><br></pre></td></tr></table></figure><p>此時的 pNum 的「變數資料」會寫入「iNum 的位置」（也就是 &amp;iNum）<br>然後一連串的事情，就是「使用 pNum 保存的資料來做某些事」</p><p>接下來我們可以看看函數在傳值、傳址，傳參考分別的情況。</p><div class="note info">            <p>C 語言只有傳值、傳址，傳參考是 C++ 中新加入的內容；<br>不過實際上這三件事情，都是「傳值」才對。</p>          </div><h2 id="傳值"><a href="#傳值" class="headerlink" title="傳值"></a>傳值</h2><p>我們先從傳值開始，程式應該很好理解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_by_value</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    a += b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iNum = <span class="number">10</span>;             <span class="comment">// 宣告變數</span></span><br><span class="line">add_by_value(iNum, <span class="number">2</span>);     <span class="comment">// 調用傳值的函數</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, iNum);        <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">變數名稱</th><th align="center">變數資料</th><th align="center">變數位置</th></tr></thead><tbody><tr><td align="center">iNum</td><td align="center">10</td><td align="center">0x7fffffffdc7c</td></tr><tr><td align="center">a</td><td align="center">10</td><td align="center">0x7fffffffdc5c</td></tr><tr><td align="center">b</td><td align="center">2</td><td align="center">0x7fffffffdc58</td></tr></tbody></table><p>當 <code>add_by_value</code> 調用時，程式另外建立 <code>a</code> 跟 <code>b</code> 區域變數；<br>生命週期是直到函數結束。很單純的小程式。</p><h2 id="傳址"><a href="#傳址" class="headerlink" title="傳址"></a>傳址</h2><p>接著我們看傳址：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_by_pointer</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    *a += b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iNum = <span class="number">10</span>;              <span class="comment">// 宣告變數</span></span><br><span class="line">add_by_pointer(&amp;iNum, <span class="number">2</span>);   <span class="comment">// 調用傳值的函數</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, iNum);         <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">變數名稱</th><th align="center">變數資料</th><th align="center">變數位置</th></tr></thead><tbody><tr><td align="center">iNum</td><td align="center">10</td><td align="center"><code>0x7fffffffdc7c</code></td></tr><tr><td align="center">a</td><td align="center"><code>0x7fffffffdc7c</code></td><td align="center">0x7fffffffdc5c</td></tr><tr><td align="center">b</td><td align="center">2</td><td align="center">0x7fffffffdc58</td></tr></tbody></table><p>當使用傳址後，當 <code>a</code> 傳入時，實際上是傳入 <code>iNum</code> 的記憶體位置；<br>所以才有「傳址」也是「傳值」一說。</p><h2 id="傳參考"><a href="#傳參考" class="headerlink" title="傳參考"></a>傳參考</h2><p>最後來看傳參考。是三者中最特別的東西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_by_reference</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a += b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> iNum = <span class="number">10</span>;              <span class="comment">// 宣告變數</span></span><br><span class="line"><span class="built_in">add_by_reference</span>(iNum, <span class="number">2</span>);  <span class="comment">// 調用傳值的函數</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, iNum);         <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">變數名稱</th><th align="center">變數資料</th><th align="center">變數位置</th></tr></thead><tbody><tr><td align="center">iNum</td><td align="center">10</td><td align="center"><code>0x7fffffffdc7c</code></td></tr><tr><td align="center">a</td><td align="center">10</td><td align="center"><code>0x7fffffffdc7c</code></td></tr><tr><td align="center">b</td><td align="center">2</td><td align="center">0x7fffffffdc5c</td></tr></tbody></table><p>從表很容易看出，實際上傳參考就是當成把傳入的值，取個別名而已；<br>從例子來看，變數 <code>a</code> 其實就是 <code>iNum</code> 的別名。</p><h2 id="印出指標"><a href="#印出指標" class="headerlink" title="印出指標"></a>印出指標</h2><p>如果要觀察指標，可以透過 <code>printf(&quot;%p&quot;, ...)</code> 輸出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *y = &amp;x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d (%p)\n&quot;</span>, x, &amp;x);                     <span class="comment">// 0 (0x7ffd8443024c)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p (%p)\n&quot;</span>, y, &amp;y);                     <span class="comment">// 0x7ffd8443024c (0x7ffd84430240)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s (%p)\n&quot;</span>, <span class="string">&quot;constant&quot;</span>, &amp;<span class="string">&quot;constant&quot;</span>);   <span class="comment">// constant (0x55fdd9cbc016)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s (%p)\n&quot;</span>, <span class="string">&quot;constant&quot;</span>, &amp;<span class="string">&quot;constant&quot;</span>);   <span class="comment">// constant (0x55fdd9cbc016)</span></span><br></pre></td></tr></table></figure><p>這裡可以看出，當編譯器處理常數字串時，不會記錄多餘的資訊，<br>常數字串 <code>constant</code> 被存在 <code>0x55fdd9cbc016</code> 位置，而重複存取會到同一個位置找來用。</p><div class="note info">            <p>這裡的參數 <code>%p</code> 是輸出位置、而 <code>%d</code> 是輸出整數、然後 <code>%s</code> 是輸出字串。<br>請參閱 <a href="http://www.cplusplus.com/reference/cstdio/printf/">cplusplus: printf</a></p>          </div><h1 id="動態宣告"><a href="#動態宣告" class="headerlink" title="動態宣告"></a>動態宣告</h1><p>指標的用法中，很常見的是動態宣告，其實就是執行期間去跟 OS 拿記憶體來用。</p><p>C 語言常使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr;                                   <span class="comment">// 宣告指標</span></span><br><span class="line">arr = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);      <span class="comment">// 拿記憶體（10個int），起始位置給 arr</span></span><br><span class="line"><span class="comment">/* Do Something */</span>                          <span class="comment">// 使用記憶體</span></span><br><span class="line"><span class="built_in">free</span>(arr);                                  <span class="comment">// 把空間還給 OS</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>另一個常見的是使用 <code>calloc</code> 它會幫你初始化記憶體為 <code>0</code>。<br>請參閱 <a href="http://www.cplusplus.com/reference/cstdlib/calloc/">cplusplus: calloc</a></p>          </div><p>在 C 語言中，我們會在使用後透過 <code>free</code> 來釋放記憶體空間。</p><p>C++ 風格則是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr;               <span class="comment">// 宣告指標</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];      <span class="comment">// 拿記憶體（10個int），起始位置給 arr</span></span><br><span class="line"><span class="comment">/* Do Something */</span>      <span class="comment">// 使用記憶體</span></span><br><span class="line"><span class="keyword">delete</span> arr;             <span class="comment">// 把空間還給 OS</span></span><br></pre></td></tr></table></figure><p>在 C 語言中，我們會在使用後透過 <code>delete</code> 來釋放記憶體空間。</p><div class="note warning">            <p>請務必在動態配置記憶體後，釋放掉記憶體。</p>          </div><h1 id="指標的指標"><a href="#指標的指標" class="headerlink" title="指標的指標"></a>指標的指標</h1><p>到這個部份，解釋會開始變得複雜，<br>主要只是因為指標的指標講起來比較繞口。</p><p>實際上如果接受儲存的值為位置這個概念，<br>那指標的指標也會很容易理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *a = &amp;iNum; </span><br><span class="line"><span class="type">int</span> **b = &amp;a;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">變數名稱</th><th align="center">變數資料</th><th align="center">變數位置</th></tr></thead><tbody><tr><td align="center">iNum</td><td align="center">10</td><td align="center">0x7fffffffdc7c</td></tr><tr><td align="center">a</td><td align="center">0x7fffffffdc7c</td><td align="center">0x7fffffffdc70</td></tr><tr><td align="center">b</td><td align="center">0x7fffffffdc70</td><td align="center">0x7fffffffdc68</td></tr></tbody></table><p>指標的指標也是有動態宣告，用法跟單一指標一樣。<br>只是多重指向的指標動態宣告出來的必須是少一個指標：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **matrix;</span><br><span class="line">matrix = (<span class="type">int</span> **) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span> *) * <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    matrix[i] = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>或是 C++ 風格：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **matrix;</span><br><span class="line">matrix = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    matrix[i] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>不過，如果理解記憶體配置，也許可以這樣分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *matrix;</span><br><span class="line">matrix = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">10</span> * <span class="number">10</span>);</span><br><span class="line">matrix[i * <span class="number">10</span> + j]; <span class="comment">// 當成一個陣列來用</span></span><br></pre></td></tr></table></figure><h1 id="函數指標"><a href="#函數指標" class="headerlink" title="函數指標"></a>函數指標</h1><p>除了資料有指標外，實際上函數在宣告的時候也有位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> a)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>) = foo;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;foo); <span class="comment">// 0x555555555149</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, p);    <span class="comment">// 0x555555555149</span></span><br></pre></td></tr></table></figure><p>在 GDB 中，顯示的位址：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000555555555149</span> &lt;+<span class="number">0</span>&gt;:  endbr64 </span><br><span class="line"><span class="number">0x000055555555514d</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">push</span>   %rbp</span><br><span class="line"><span class="number">0x000055555555514e</span> &lt;+<span class="number">5</span>&gt;:  <span class="keyword">mov</span>    %rsp,%rbp</span><br><span class="line"><span class="number">0x0000555555555151</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">mov</span>    %edi,-<span class="number">0x4</span>(%rbp)</span><br><span class="line"><span class="number">0x0000555555555154</span> &lt;+<span class="number">11</span>&gt;: <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x0000555555555159</span> &lt;+<span class="number">16</span>&gt;: <span class="keyword">pop</span>    %rbp</span><br><span class="line"><span class="number">0x000055555555515a</span> &lt;+<span class="number">17</span>&gt;: retq   </span><br></pre></td></tr></table></figure><div class="note info">            <p>請參閱 <a href="https://en.wikipedia.org/wiki/GNU_Debugger">Wikipedia: GNU Debugger</a></p>          </div><p>函數的位置其實就是指令開始的位置。<br>至於函數指標宣告有一個細節，就是當不寫括號時：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">p</span><span class="params">(<span class="type">int</span>)</span> = foo; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>而 <code>int *p</code> 相當於把 <code>int*</code> 看做一組，等價於 <code>(int*) p(int)</code><br>編譯器看到 <code>int *p (int)</code> 的 <code>(int)</code> 就不知道你在寫什麼，會出錯：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span> *) p(<span class="type">int</span>) = foo; <span class="comment">// error</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./main.c:10:15: error: expected expression before ‘int’</span><br><span class="line">   10 |     (int *) p(int) = foo; // error</span><br><span class="line">      |               ^~~</span><br></pre></td></tr></table></figure><p>函數指標呼叫時：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*p)();                 <span class="comment">// 完整的寫法</span></span><br><span class="line">p();                    <span class="comment">// 簡寫</span></span><br></pre></td></tr></table></figure><p>相同地，函數其實也是簡寫：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>) = &amp;foo;   <span class="comment">// 完整的寫法</span></span><br><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>) = foo;    <span class="comment">// 簡寫</span></span><br></pre></td></tr></table></figure><h1 id="void-指標"><a href="#void-指標" class="headerlink" title="void 指標"></a>void 指標</h1><p>指標跟其他型別一樣，是可以強制轉型的。<br>比較特別的是指標存在一個稱為 <code>void *</code> 的東西。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p;</span><br></pre></td></tr></table></figure><p>簡單說，這個 <code>void *</code> 是為了讓使用者「強制轉型」，從而確定型別；<br>像是 <code>void *malloc(size_t size);</code> 就是回傳 <code>void *</code>。</p><p>所以如果你不轉型，是無法使用的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*p = <span class="number">10</span>;                        <span class="comment">// 無法使用</span></span><br><span class="line">*((<span class="type">int</span> *) p) = <span class="number">10</span>;              <span class="comment">// 強制轉型後可用</span></span><br></pre></td></tr></table></figure><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>這一節就真的是個人筆記了，初學者看看就好（雖然說順便學個 GDB 不是壞事），<br>所有東西在記憶體中都是有位置的，參考先前出現過的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> iNum;               <span class="comment">// 宣告變數</span></span><br><span class="line"><span class="type">int</span> *pNum;              <span class="comment">// 宣告指標</span></span><br><span class="line">iNum = <span class="number">10</span>;              <span class="comment">// 設定變數值</span></span><br><span class="line">pNum = &amp;iNum;           <span class="comment">// 設定指標值</span></span><br><span class="line">*pNum += <span class="number">2</span>;             <span class="comment">// 指標「存放的」變數加 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, iNum);     <span class="comment">// 印出 12</span></span><br></pre></td></tr></table></figure><p>我們編譯過後，透過 GDB 追蹤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt; </span><span class="language-bash">gcc ./main.c -o ./main -fno-stack-protector</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">gdb ./main</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">run</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">disas main</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash"><span class="built_in">break</span> *0x0000555555555173</span></span><br><span class="line"><span class="meta">&gt; </span><span class="language-bash">run</span></span><br></pre></td></tr></table></figure><p>中斷點 break 後的位置請參考自己環境下的位置。</p><div class="note info">            <p>這邊關閉了緩衝區防撞保護（Stack Smashing Protector）<br>請參閱 <a href="https://wiki.osdev.org/Stack_Smashing_Protector">OSDEV wiki: Stack SmashingProtector</a></p>          </div><p>反組譯的結果應該是：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000555555555149</span> &lt;+<span class="number">0</span>&gt;:  endbr64 </span><br><span class="line"><span class="number">0x000055555555514d</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">push</span>   %rbp</span><br><span class="line"><span class="number">0x000055555555514e</span> &lt;+<span class="number">5</span>&gt;:  <span class="keyword">mov</span>    %rsp,%rbp</span><br><span class="line"><span class="number">0x0000555555555151</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">sub</span>    <span class="number">$0</span>x10,%rsp</span><br><span class="line"><span class="number">0x0000555555555155</span> &lt;+<span class="number">12</span>&gt;: movl   <span class="number">$0</span>xa,-<span class="number">0xc</span>(%rbp)</span><br><span class="line"><span class="number">0x000055555555515c</span> &lt;+<span class="number">19</span>&gt;: <span class="keyword">lea</span>    -<span class="number">0xc</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x0000555555555160</span> &lt;+<span class="number">23</span>&gt;: <span class="keyword">mov</span>    %rax,-<span class="number">0x8</span>(%rbp)</span><br><span class="line"><span class="number">0x0000555555555164</span> &lt;+<span class="number">27</span>&gt;: <span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x0000555555555168</span> &lt;+<span class="number">31</span>&gt;: <span class="keyword">mov</span>    (%rax),%eax</span><br><span class="line"><span class="number">0x000055555555516a</span> &lt;+<span class="number">33</span>&gt;: <span class="keyword">lea</span>    <span class="number">0x2</span>(%rax),%edx</span><br><span class="line"><span class="number">0x000055555555516d</span> &lt;+<span class="number">36</span>&gt;: <span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax</span><br><span class="line"><span class="number">0x0000555555555171</span> &lt;+<span class="number">40</span>&gt;: <span class="keyword">mov</span>    %edx,(%rax)</span><br><span class="line"><span class="number">0x0000555555555173</span> &lt;+<span class="number">42</span>&gt;: <span class="keyword">mov</span>    -<span class="number">0xc</span>(%rbp),%eax</span><br><span class="line"><span class="number">0x0000555555555176</span> &lt;+<span class="number">45</span>&gt;: <span class="keyword">mov</span>    %eax,%esi</span><br><span class="line"><span class="number">0x0000555555555178</span> &lt;+<span class="number">47</span>&gt;: <span class="keyword">lea</span>    <span class="number">0xe85</span>(%rip),%rdi   # <span class="number">0x555555556004</span></span><br><span class="line"><span class="number">0x000055555555517f</span> &lt;+<span class="number">54</span>&gt;: <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x0000555555555184</span> &lt;+<span class="number">59</span>&gt;: callq  <span class="number">0x555555555050</span> &lt;printf@plt&gt;</span><br><span class="line"><span class="number">0x0000555555555189</span> &lt;+<span class="number">64</span>&gt;: <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax</span><br><span class="line"><span class="number">0x000055555555518e</span> &lt;+<span class="number">69</span>&gt;: leaveq </span><br><span class="line"><span class="number">0x000055555555518f</span> &lt;+<span class="number">70</span>&gt;: retq   </span><br></pre></td></tr></table></figure><p>我用 <code>#</code> 當成註解，標示成下面這樣：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0000555555555149</span> &lt;+<span class="number">0</span>&gt;:  endbr64                    # 標記為有效分支（系統安全操作）</span><br><span class="line"></span><br><span class="line">                                                     # 函數呼叫操作</span><br><span class="line"><span class="number">0x000055555555514d</span> &lt;+<span class="number">4</span>&gt;:  <span class="keyword">push</span>   %rbp                # 紀錄舊的 $<span class="built_in">rbp</span> 暫存器</span><br><span class="line"><span class="number">0x000055555555514e</span> &lt;+<span class="number">5</span>&gt;:  <span class="keyword">mov</span>    %rsp,%rbp           # 移動 $<span class="built_in">rbp</span> 到 $<span class="built_in">rsp</span>（紀錄 $<span class="built_in">rsp</span>）</span><br><span class="line"><span class="number">0x0000555555555151</span> &lt;+<span class="number">8</span>&gt;:  <span class="keyword">sub</span>    <span class="number">$0</span>x10,%rsp          # 將舊的 $<span class="built_in">rsp</span> 減去 <span class="number">16</span> Bytes（宣告記憶體空間）</span><br><span class="line"></span><br><span class="line">                                                     # iNum = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">                                                     # iNum 的位置是 $<span class="built_in">rbp</span>-<span class="number">12</span></span><br><span class="line">                                                     # 常數 <span class="number">10</span> 為 <span class="number">0xA</span></span><br><span class="line"><span class="number">0x0000555555555155</span> &lt;+<span class="number">12</span>&gt;: movl   <span class="number">$0</span>xa,-<span class="number">0xc</span>(%rbp)     # 移動 <span class="number">10</span> 到 iNum 的位置</span><br><span class="line"></span><br><span class="line">                                                     # pNum = &amp;iNum<span class="comment">;</span></span><br><span class="line">                                                     # pNum 的位置是 $<span class="built_in">rbp</span>-<span class="number">8</span></span><br><span class="line"><span class="number">0x000055555555515c</span> &lt;+<span class="number">19</span>&gt;: <span class="keyword">lea</span>    -<span class="number">0xc</span>(%rbp),%rax     # 將 iNum 的位置給 $<span class="built_in">rax</span></span><br><span class="line">                                                     # <span class="keyword">lea</span> mem,reg 指令不載入內容，mem 做完偏移就放到 reg</span><br><span class="line"><span class="number">0x0000555555555160</span> &lt;+<span class="number">23</span>&gt;: <span class="keyword">mov</span>    %rax,-<span class="number">0x8</span>(%rbp)     # 移動 %rax 的值給 pNum</span><br><span class="line"></span><br><span class="line">                                                     # *pNum += <span class="number">2</span><span class="comment">;</span></span><br><span class="line">                                                     # 等價於 *pNum = *pNum + <span class="number">2</span><span class="comment">;</span></span><br><span class="line">                                                     # 分兩個部份做，先加 <span class="number">2</span> 再賦值</span><br><span class="line"></span><br><span class="line">                                                     # *pNum + <span class="number">2</span></span><br><span class="line"><span class="number">0x0000555555555164</span> &lt;+<span class="number">27</span>&gt;: <span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax     # 移動 pNum 的值給 $<span class="built_in">rax</span>（iNum 的位置）</span><br><span class="line"><span class="number">0x0000555555555168</span> &lt;+<span class="number">31</span>&gt;: <span class="keyword">mov</span>    (%rax),%eax         # 移動 $<span class="built_in">rax</span> 存的那個位置上的值給 $<span class="built_in">eax</span>（<span class="number">10</span>）</span><br><span class="line"><span class="number">0x000055555555516a</span> &lt;+<span class="number">33</span>&gt;: <span class="keyword">lea</span>    <span class="number">0x2</span>(%rax),%edx      # 加載 $<span class="built_in">rax</span>（<span class="number">10</span>） 的值+<span class="number">2</span> 放到 $<span class="built_in">edx</span>（<span class="number">12</span>）</span><br><span class="line"></span><br><span class="line">                                                     # *pNum = *pNum + <span class="number">2</span></span><br><span class="line"><span class="number">0x000055555555516d</span> &lt;+<span class="number">36</span>&gt;: <span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%rax     # 讀取 pNum 的值給 $<span class="built_in">rax</span>（iNum 的位置）</span><br><span class="line"><span class="number">0x0000555555555171</span> &lt;+<span class="number">40</span>&gt;: <span class="keyword">mov</span>    %edx,(%rax)         # 將 $<span class="built_in">edx</span>（<span class="number">12</span>） 的值給 $<span class="built_in">rax</span>（iNum 的位置）的值</span><br><span class="line"></span><br><span class="line">                                                              # printf(<span class="string">&quot;%d&quot;</span>, iNum)<span class="comment">;</span></span><br><span class="line"><span class="number">0x0000555555555173</span> &lt;+<span class="number">42</span>&gt;: <span class="keyword">mov</span>    -<span class="number">0xc</span>(%rbp),%eax              # 讀取 iNum 的值給 $<span class="built_in">eax</span></span><br><span class="line"><span class="number">0x0000555555555176</span> &lt;+<span class="number">45</span>&gt;: <span class="keyword">mov</span>    %eax,%esi                    # 移動 $<span class="built_in">eax</span> 的值給 $<span class="built_in">esi</span></span><br><span class="line"><span class="number">0x0000555555555178</span> &lt;+<span class="number">47</span>&gt;: <span class="keyword">lea</span>    <span class="number">0xe85</span>(%rip),%rdi             # 將 $<span class="built_in">rip</span>+<span class="number">0xe85</span>（<span class="string">&quot;%d\n&quot;</span>）給 $<span class="built_in">rdi</span></span><br><span class="line"><span class="number">0x000055555555517f</span> &lt;+<span class="number">54</span>&gt;: <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax                    # 清空 $<span class="built_in">eax</span></span><br><span class="line"><span class="number">0x0000555555555184</span> &lt;+<span class="number">59</span>&gt;: callq  <span class="number">0x555555555050</span> &lt;printf@plt&gt;  # 呼叫 printf</span><br><span class="line"><span class="number">0x0000555555555189</span> &lt;+<span class="number">64</span>&gt;: <span class="keyword">mov</span>    <span class="number">$0</span>x0,%eax                    # 清空 $<span class="built_in">eax</span></span><br><span class="line"></span><br><span class="line">                                                     # 函數離開操作，等價於：</span><br><span class="line"><span class="number">0x000055555555518e</span> &lt;+<span class="number">69</span>&gt;: leaveq                     # <span class="keyword">movq</span> %rbp, %rsp</span><br><span class="line">                                                     # popq %rbp</span><br><span class="line"><span class="number">0x000055555555518f</span> &lt;+<span class="number">70</span>&gt;: retq                       # 回傳</span><br></pre></td></tr></table></figure><div class="note info">            <p>GDB 採 AT&amp;T 格式，顯示順序跟 Intel 是顛倒，請參閱 <a href="https://en.wikipedia.org/wiki/X86_assembly_language">Wikipedia: X86 assembly language</a></p>          </div><p>在輸出位置前檢查（設中斷點），可以檢查我們的區域變數：</p><table><thead><tr><th align="center">變數名稱</th><th align="center">變數資料</th><th align="center">變數位置</th></tr></thead><tbody><tr><td align="center">iNum</td><td align="center">0x0c</td><td align="center">0x7fffffffdc74</td></tr><tr><td align="center">pNum</td><td align="center">0x7fffffffdc74</td><td align="center">0x7fffffffdc78</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt; </span><span class="language-bash">(gdb) x/32xb <span class="variable">$rsp</span></span></span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x7fffffffdc70</span>: <span class="number">0x70</span>  <span class="number">0xdd</span>  <span class="number">0xff</span>  <span class="number">0xff</span>  <span class="number">0x0c</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffdc78</span>: <span class="number">0x74</span>  <span class="number">0xdc</span>  <span class="number">0xff</span>  <span class="number">0xff</span>  <span class="number">0xff</span>  <span class="number">0x7f</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffdc80</span>: <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffdc88</span>: <span class="number">0xb3</span>  <span class="number">0x70</span>  <span class="number">0xde</span>  <span class="number">0xf7</span>  <span class="number">0xff</span>  <span class="number">0x7f</span>  <span class="number">0x00</span>  <span class="number">0x00</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>注意顯示單位，這樣一組 <code>0x00</code> 相當於二進制的 <code>b00000000</code> 共 8 個位元；<br>所以一個 <code>int</code> 需要 4 組，而筆者電腦是 64-bits 需要 8 組。</p>          </div><p><code>0x7fffffffdc78</code> 儲存的內容看起來雖然是 <code>0x74dcffffff7f</code>，不過 x86 系統採用小端序（little endian），<br>所以實際的值是 <code>0x7fffffffdc74</code>；同樣地，<code>iNum</code> 是 <code>0x0000000c</code> 而非 <code>0x0c000000</code>。</p><p>注意！是 Bytes 的組合順序顛倒（不是位元順序、也不是顯示的順序），<br>以 <code>0x01 0x02 0x03 0x04</code>（<code>b00000001000000100000001100000101</code>）為例：</p><ul><li>真正的值（小端序）：<code>0x04 0x03 0x02 0x01</code> 即 <code>0x04030201</code></li><li>位元順序顛倒：<code>b10100000110000000100000010000000</code> 即 <code>0xA0C04080</code></li><li>顯示順序顛倒：<code>0x40 0x30 0x20 0x10</code> 即 <code>0x40302010</code></li></ul><p>這 3 種結果完全不同。</p><div class="note info">            <p><code>mov</code> 跟 <code>lea</code> 的差別；假設有兩個暫存器 <code>$A = 0xfc</code> 及 <code>$B</code>、一個記憶體 <code>0xfa = 777</code>。<br>    <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> -<span class="number">0x2</span>($A),$B     # $B = <span class="number">777</span></span><br><span class="line"><span class="keyword">lea</span> -<span class="number">0x2</span>($A),$B     # $B = <span class="number">0xfa</span></span><br></pre></td></tr></table></figure></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 程式設計 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>影像濾波 Image Filter</title>
      <link href="//Image-Filter/"/>
      <url>//Image-Filter/</url>
      
        <content type="html"><![CDATA[<p>這次的主題是影像濾波（image filter）。</p><p>這也是大學影像處理課的內容，基本的東西已經寫過了，<br>原先考慮到加入一些其他新東西，可是後來想說不要把文章複雜化，<br>所以新東西可能之後才會發。</p><span id="more"></span><div class="note success">            <p>請參閱 <a href="/ming-chuan-university-homework/" title="我的大學作業整理">我的大學作業整理</a> 的「影像處理課程」部分。</p>          </div><h1 id="相關名詞"><a href="#相關名詞" class="headerlink" title="相關名詞"></a>相關名詞</h1><p>在開始之前，可能要釐清一些相似的概念，<br>包括我自己也是，下面 4 件事情很容易混淆：</p><ul><li>影像濾波（image filter）</li><li>影像濾鏡（image filter）</li><li>影像相關（image correlation）</li><li>影像卷積（image convlusion）</li></ul><p>後來看了一些資料，才把這些事情搞清楚。</p><div class="note info">            <p>影像相關（image correlation）的中譯取自《数字图像处理（第三版）》</p>          </div><p>我們先看濾波與濾鏡好了，因為某些不明原因，似乎兩者的英文原文是相同的；<br>不過很濾波是來自於訊號處理，而濾鏡是來自攝影的鏡頭配件。</p><p>電腦科學上的濾鏡，這邊採用 Computer Definition 的定義：</p><blockquote><p>A software routine that changes the appearance of an image or part of an image by altering the shades and colors of the pixels in some manner. Filters are used to increase brightness and contrast as well as to add a wide variety of textures, tones and special effects to a picture.</p></blockquote><p>簡單的說，濾鏡是一種「軟體」，任何能夠修改圖像陰影、顏色、明暗的都可以算是一種影像濾鏡。</p><p>至於濾波，通常是指「濾波器」（Filter）是來自訊號處理的領域，<br>意思是「濾除某些東西」，用訊號來比方的話，像是低通濾波器，意思是低頻的會通、高頻則被「濾除」了。</p><p>很顯然，所以我們可以針對某個域來處理，影像的話，有「空間」跟「頻率」兩個域，<br>分別對應了「空間濾波器」跟「頻率濾波器」兩大類型。至於考量函數特性的線性、非線性也是一種分類方法。</p><p>濾波與卷積在訊號處理上是完全不同的東西。應該說，卷積只是濾波的一種操作方法。</p><p>在影像處理中，空間濾波的操作是透過相關（correlation）或卷積（convlusion）操作實現的，<br>透過濾波器（filter）在源圖像上進行掃描，然後逐步運算得出新圖像。</p><div class="note info">            <p>濾波器（filter）也被稱為核（kernel）</p>          </div><p>假設 $f(x, y)$ 是 $3 \times 3$ 濾波器，而 $g(x, y)$ 是圖像。<br>若執行「相關」操作，則新圖像 $h(x, y)$ 是：</p><p>$$<br>h(x, y) &#x3D; \text{cor}(f(x, y), g(x, y)) &#x3D; \sum\limits_{i&#x3D;-a}^{a} \sum\limits_{j&#x3D;-b}^{b} f(i, j) \cdot g(x + i, y + j)<br>$$</p><p>改執行「卷積」操作則為：</p><p>$$<br>h(x, y) &#x3D; \text{conv}(f(x, y), g(x, y)) &#x3D; \sum\limits_{i&#x3D;-a}^{a} \sum\limits_{j&#x3D;-b}^{b} f(i, j) \cdot g(x - i, y - j)<br>$$</p><p>不同的濾波器會對應不同的效果，可以參考 <a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)" title="" target="">Wikipedia: Kernel (image processing)</a><br>圖像相關跟圖像卷積兩者操作基本上一樣，唯獨卷積在濾波器上轉了 180 度。</p><div class="note info">            <p>這邊的定義是採奇數大小、中心座標為原點的濾波器。<br>意即 $3 \times 3$ 的濾波器，對應的參數為 $a &#x3D; 1, b &#x3D; 1$</p>          </div><h1 id="均值濾波器"><a href="#均值濾波器" class="headerlink" title="均值濾波器"></a>均值濾波器</h1><p>相似地，若輸出為 $h(x, y)$ 數學上的定義為：</p><p>$$<br>h(x, y)<br>&#x3D; \frac{\text{cor}(f(x, y), g(x, y))}{\sum\limits_{i&#x3D;-a}^{a} \sum\limits_{j&#x3D;-b}^{b} f(i, j)}<br>&#x3D; \frac{\sum\limits_{i&#x3D;-a}^{a} \sum\limits_{j&#x3D;-b}^{b} f(i, j) \cdot g(x + i, y + j)}{\sum\limits_{i&#x3D;-a}^{a} \sum\limits_{j&#x3D;-b}^{b} f(i, j)}<br>$$</p><p>看起來很難懂，其實就是拿著濾波器掃描圖片，然後被濾波器蓋住的地方，就平均一下。</p><p><img src="https://i.imgur.com/naVLmQK.png" alt="圖 1、均值濾波器"></p><p>參考圖 1 的例子，濾波器放在左上角，經過計算：</p><p>$$<br>\sum\limits_{i&#x3D;-1}^{1} \sum\limits_{j&#x3D;-1}^{1} f(i, j) &#x3D; 9<br>$$</p><p>所以把對應的格子乘以權重（這邊為 $1$）加起來，然後除以 $9$ 就可以了：</p><p>$$<br>h(x, y)<br>&#x3D; \frac{\text{cor}(f(x, y), g(x, y))}{9}<br>&#x3D; \frac{\sum\limits_{i&#x3D;-1}^{1} \sum\limits_{j&#x3D;-1}^{1} f(i, j) \cdot g(x + i, y + j)}{9}<br>$$<br>$$<br>&#x3D; \frac{216+255+255+102+216+255+102+102+255}{9}<br>&#x3D; \frac{1758}{9} &#x3D; 195<br>$$</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 設定變數 */</span></span><br><span class="line"><span class="keyword">let</span> i, j, k, p, q;          <span class="comment">// 用於迴圈的註標</span></span><br><span class="line"><span class="keyword">let</span> sum;                    <span class="comment">// 用於加總圖片濾波器的總和</span></span><br><span class="line"><span class="keyword">let</span> index;                  <span class="comment">// 用於計算實際圖片的像素的位置</span></span><br><span class="line"><span class="keyword">let</span> filter = [              <span class="comment">// 濾波器</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> w = imgData.<span class="property">width</span>;      <span class="comment">// 圖片的寬度</span></span><br><span class="line"><span class="keyword">let</span> h = imgData.<span class="property">height</span>;     <span class="comment">// 圖片的長度</span></span><br><span class="line"><span class="keyword">let</span> fw = <span class="number">3</span>;                 <span class="comment">// 濾波器的寬度</span></span><br><span class="line"><span class="keyword">let</span> fh = <span class="number">3</span>;                 <span class="comment">// 濾波器的長度</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="number">9</span>;                 <span class="comment">// 濾波器的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建立圖片副本 */</span></span><br><span class="line"><span class="keyword">let</span> newData = imageContext.<span class="title function_">createImageData</span>(w, h);</span><br><span class="line">newData.<span class="property">data</span>.<span class="title function_">set</span>(imgData.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 計算濾波器中心，在圖片上的位置 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; (w - fw - <span class="number">1</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; (h - fh - <span class="number">1</span>); j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 計算圖片的三種顏色 */</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 計算濾波器覆蓋圖片區域的平均值 */</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = -<span class="number">1</span>; p &lt; fw - <span class="number">1</span>; p++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = -<span class="number">1</span>; q &lt; fh - <span class="number">1</span>; q++) &#123;</span><br><span class="line">                    index = ((j + q) * w + (i + p)) * <span class="number">4</span> + k;</span><br><span class="line">                    sum += filter[p + <span class="number">1</span>][q + <span class="number">1</span>] * imgData.<span class="property">data</span>[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum /= fs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 將平均值賦值給這塊區域的所有像素 */</span></span><br><span class="line">            <span class="keyword">for</span> (p = -<span class="number">1</span>; p &lt; fw - <span class="number">1</span>; p++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = -<span class="number">1</span>; q &lt; fh - <span class="number">1</span>; q++) &#123;</span><br><span class="line">                    index = ((j + q) * w + (i + p)) * <span class="number">4</span> + k;</span><br><span class="line">                    newData.<span class="property">data</span>[index] = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顯示新圖片 */</span></span><br><span class="line">imageContext.<span class="title function_">putImageData</span>(newData, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><div class="note warning">            <p>實作時，應該另開記憶體空間，以避免取樣到加工過的圖片 $h(x, y)$</p>          </div><h1 id="中值濾波器"><a href="#中值濾波器" class="headerlink" title="中值濾波器"></a>中值濾波器</h1><p>中值濾波器只是在濾波器的範圍內找最大輸出：</p><p>$$<br>h(x, y) &#x3D; \max\limits_{i, j \in \{-1, 0, 1\}} g(x + i, y + j)<br>$$</p><p><img src="https://i.imgur.com/kQbriZT.png" alt="圖 2、中值濾波器"></p><p>中值濾波器的一個功能是，在圖片遭受胡椒鹽雜訊（Salt-and-pepper noise）時，<br>則可以透過中值濾波器修復，參考圖 3 的原圖：</p><p><img src="https://i.imgur.com/mGqhnpg.png" alt="圖 3、未受胡椒鹽雜訊汙染的圖像圖"></p><p>當遭受胡椒鹽雜訊干擾，呈現圖 4 的樣子：</p><p><img src="https://i.imgur.com/yu7R0R9.png" alt="圖 4、胡椒鹽雜訊汙染後的圖像"></p><p>我們透過中值濾波器，可以修復為圖 5 的樣子：</p><p><img src="https://i.imgur.com/Gpzy1P3.png" alt="圖 5、經中值濾波器復原後的圖像"></p><p>不過，當胡椒鹽雜訊過強時，像是圖 6 那樣，中值濾波器也難以修復：</p><p><img src="https://i.imgur.com/yAxd9OO.png" alt="圖 6、嚴重胡椒鹽雜訊汙染的圖像"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 設定變數 */</span></span><br><span class="line"><span class="keyword">let</span> i, j, k, p, q;          <span class="comment">// 用於迴圈的註標</span></span><br><span class="line"><span class="keyword">let</span> index;                  <span class="comment">// 用於計算實際圖片的像素的位置</span></span><br><span class="line"><span class="keyword">let</span> arr = [];               <span class="comment">// 用於計算中位數的陣列</span></span><br><span class="line"><span class="keyword">let</span> median;                 <span class="comment">// 紀錄的中位數</span></span><br><span class="line"><span class="keyword">let</span> w = imgData.<span class="property">width</span>;      <span class="comment">// 圖片的寬度</span></span><br><span class="line"><span class="keyword">let</span> h = imgData.<span class="property">height</span>;     <span class="comment">// 圖片的長度</span></span><br><span class="line"><span class="keyword">let</span> fw = <span class="number">3</span>;                 <span class="comment">// 濾波器的寬度</span></span><br><span class="line"><span class="keyword">let</span> fh = <span class="number">3</span>;                 <span class="comment">// 濾波器的長度</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="number">9</span>;                 <span class="comment">// 濾波器的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建立圖片副本 */</span></span><br><span class="line"><span class="keyword">let</span> newData = imageContext.<span class="title function_">createImageData</span>(w, h);</span><br><span class="line">newData.<span class="property">data</span>.<span class="title function_">set</span>(imgData.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 計算濾波器中心，在圖片上的位置 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; (w - fw - <span class="number">1</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; (h - fh - <span class="number">1</span>); j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 計算圖片的三種顏色 */</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 計算濾波器覆蓋圖片區域的中位數 */</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = -<span class="number">1</span>; p &lt; fw - <span class="number">1</span>; p++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = -<span class="number">1</span>; q &lt; fh - <span class="number">1</span>; q++) &#123;</span><br><span class="line">                    index = ((j + q) * w + (i + p)) * <span class="number">4</span> + k;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 直接找到註標塞值到 arr 中 */</span></span><br><span class="line">                    <span class="comment">/* 效能會比每次都重建陣列 push 來的好 */</span></span><br><span class="line">                    arr[(q + <span class="number">1</span>) * fh + (p + <span class="number">1</span>)] = imgData.<span class="property">data</span>[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (a &lt; b ? -<span class="number">1</span> : <span class="number">1</span>)); <span class="comment">// 排序固定數量的 9 個數</span></span><br><span class="line">            median = arr[<span class="number">4</span>];                      <span class="comment">// 中位數是第 5 個數（註標 4）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 將中位數賦值給這塊區域的所有像素 */</span></span><br><span class="line">            <span class="keyword">for</span> (p = -<span class="number">1</span>; p &lt; fw - <span class="number">1</span>; p++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = -<span class="number">1</span>; q &lt; fh - <span class="number">1</span>; q++) &#123;</span><br><span class="line">                    index = ((j + q) * w + (i + p)) * <span class="number">4</span> + k;</span><br><span class="line">                    newData.<span class="property">data</span>[index] = median;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顯示新圖片 */</span></span><br><span class="line">imageContext.<span class="title function_">putImageData</span>(newData, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="銳化濾波器"><a href="#銳化濾波器" class="headerlink" title="銳化濾波器"></a>銳化濾波器</h1><p>最後來看銳化濾波器，首先我們定義一階微分，<br>由於我們處理的數值是離散的、且變化量發生在相鄰像素之間，於是定義：</p><p>$$ \frac{\partial f}{\partial x} &#x3D; f(x+1) - f(x) $$</p><p>同樣地，我們定義二階微分：</p><p>$$ \frac{\partial^2 f}{\partial x^2} &#x3D; \frac{\partial f}{\partial x} (f(x+1) - f(x)) $$<br>$$ &#x3D; \frac{\partial f}{\partial x} f(x+1) - \frac{\partial f}{\partial x} f(x) $$<br>$$ &#x3D; (f(x+2) - f(x+1)) - (f(x+1) - f(x)) $$<br>$$ &#x3D; f(x+2) - 2f(x+1) + f(x) $$</p><p>我們遞移像素中心到 $x+1$ 所以表示為：</p><p>$$ f(x+2) - 2f(x+1) + f(x) $$<br>$$ &#x3D; f(x+1) - 2f(x) + f(x-1) $$</p><p>考慮雙變數在偏微分下的情況：</p><p>$$ \frac{\partial^2 f(x, y)}{\partial x^2} &#x3D; f(x+1, y) - 2f(x, y) + f(x-1, y) $$</p><p>$$ \frac{\partial^2 f(x, y)}{\partial y^2} &#x3D; f(x, y+1) - 2f(x, y) + f(x, y-1) $$</p><p>接著定義圖像 $f(x,y)$ 的拉普拉斯算子：</p><p>$$ \nabla^2 f(x, y) &#x3D; \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} $$</p><p>拉普拉斯算子是先做梯度再散度：</p><p>$$ \nabla^2 f(x, y) &#x3D; \nabla \cdot (\nabla f) $$</p><p>圖像函數 $f(x, y)$ 梯度：</p><p>$$ \nabla f(x, y) &#x3D; (\frac{\partial f}{\partial x},  \frac{\partial f}{\partial y}) $$</p><p>注意到這一步為止的結果是「向量」。</p><p>代表 $\nabla f(x, y)$ 本身是一個平面座標的向量場，接著 $\nabla f(x, y)$ 的散度：</p><p>$$ \nabla^2 f(x, y) &#x3D; \nabla \cdot \nabla f(x, y)$$<br>$$ &#x3D; \nabla (\frac{\partial f}{\partial x},  \frac{\partial f}{\partial y}) &#x3D; \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} $$</p><p>注意到這一步為止的結果是「純量」。</p><p>觀察性質上：</p><ul><li>圖片函數，即你所看到的圖片</li><li>圖片函數梯度，即圖片發生像素變化的「方向跟量」</li><li>圖片函數梯度的散度，即「圖片發生像素變化的『方向跟量』」的變化量總和</li></ul><div class="note info">            <p>因為是總和，所以 $\frac{\partial^2 f}{\partial x^2}$ 跟 $\frac{\partial^2 f}{\partial y^2}$ 有可能會抵消。</p>          </div><p>現在只有變化量，然後我們要「在原圖上加強我們的變化」那就是「加上原圖」得到，所以銳化圖片 $g(x, y)$ 為：</p><p>$$g(x, y) &#x3D; f(x, y) + c\left[\nabla^2 f(x, y)\right]$$</p><p>其中，常數 $c$ 常見的值為 $c &#x3D; 1$ 或 $c &#x3D; -1$</p><p>結合上述的結果，可以得到拉普拉斯的銳化濾波器：</p><p>$$ f(x, y) + c[\nabla^2 f(x, y)] &#x3D; f(x, y) + c [\nabla \cdot \nabla f(x, y)]$$<br>$$ &#x3D; f(x, y) + c[\frac{\partial^2 f(x, y)}{\partial x^2} + \frac{\partial^2 f(x, y)}{\partial y^2}]$$<br>$$ &#x3D; f(x, y) + c[f(x+1, y) - 2f(x, y) + f(x-1, y) + f(x, y+1) - 2f(x, y) + f(x, y-1)] $$<br>$$ &#x3D; f(x, y) + c[f(x+1, y) + f(x-1, y) + f(x, y+1) + f(x, y-1) - 4f(x, y)] $$<br>$$ &#x3D; (1 - 4c)f(x, y) + cf(x+1, y) + cf(x-1, y) + cf(x, y+1) + cf(x, y-1)$$</p><p>當 $c &#x3D; -1$ 時，濾波器可參考圖 7 所示，式子為：</p><p>$$5f(x, y) + f(x+1, y) + f(x-1, y) + f(x, y+1) + f(x, y-1)$$</p><p><img src="https://i.imgur.com/mIttFB5.png" alt="圖 7、銳化濾波器"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 設定變數 */</span></span><br><span class="line"><span class="keyword">let</span> i, j, k, p, q;          <span class="comment">// 用於迴圈的註標</span></span><br><span class="line"><span class="keyword">let</span> sum;                    <span class="comment">// 用於加總圖片濾波器的總和</span></span><br><span class="line"><span class="keyword">let</span> index;                  <span class="comment">// 用於計算實際圖片的像素的位置</span></span><br><span class="line"><span class="keyword">let</span> c = -<span class="number">1</span>;                 <span class="comment">// 參考公式，任意常數（常為 -1）</span></span><br><span class="line"><span class="keyword">let</span> filter = [              <span class="comment">// 參考公式，濾波器</span></span><br><span class="line">    [<span class="number">0</span>, c, <span class="number">0</span>],</span><br><span class="line">    [c, <span class="number">1</span> - <span class="number">4</span> * c, c],</span><br><span class="line">    [<span class="number">0</span>, c, <span class="number">0</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">let</span> w = imgData.<span class="property">width</span>;      <span class="comment">// 圖片的寬度</span></span><br><span class="line"><span class="keyword">let</span> h = imgData.<span class="property">height</span>;     <span class="comment">// 圖片的長度</span></span><br><span class="line"><span class="keyword">let</span> fw = <span class="number">3</span>;                 <span class="comment">// 濾波器的寬度</span></span><br><span class="line"><span class="keyword">let</span> fh = <span class="number">3</span>;                 <span class="comment">// 濾波器的長度</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="number">9</span>;                 <span class="comment">// 濾波器的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建立圖片副本 */</span></span><br><span class="line"><span class="keyword">let</span> newData = imageContext.<span class="title function_">createImageData</span>(w, h);</span><br><span class="line">newData.<span class="property">data</span>.<span class="title function_">set</span>(imgData.<span class="property">data</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 計算濾波器中心，在圖片上的位置 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; (w - fw - <span class="number">1</span>); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; (h - fh - <span class="number">1</span>); j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 計算圖片的三種顏色 */</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 計算濾波器覆蓋圖片區域的值（參考公式） */</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (p = -<span class="number">1</span>; p &lt; fw - <span class="number">1</span>; p++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (q = -<span class="number">1</span>; q &lt; fh - <span class="number">1</span>; q++) &#123;</span><br><span class="line">                    index = ((j + q) * w + (i + p)) * <span class="number">4</span> + k;</span><br><span class="line">                    sum += filter[p + <span class="number">1</span>][q + <span class="number">1</span>] * imgData.<span class="property">data</span>[index];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 將該值賦值給像素（需要限制值域，計算後可能會超出範圍） */</span></span><br><span class="line">            index = (j * w + i) * <span class="number">4</span> + k;</span><br><span class="line">            newData.<span class="property">data</span>[index] = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(sum, <span class="number">255</span>), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 顯示新圖片 */</span></span><br><span class="line">imageContext.<span class="title function_">putImageData</span>(newData, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h1 id="邊界處理"><a href="#邊界處理" class="headerlink" title="邊界處理"></a>邊界處理</h1><p>由於濾波器不會完全覆蓋，所以圖像邊界要特殊處理，常見的方式有 3 種：</p><ul><li>跳過不處理</li><li>在原圖的邊界補零</li><li>延伸原圖的邊界</li></ul><p>跳過不處理的話，濾波器可以從圖像的 $(1, 1)$ 開始，移動至 $(\text{width} - 2, \text{height} - 2)$ 停止。<br/><br>而邊界補零是非常常見的做法，意思是當濾波器跑出範圍，則預設給 $0$ 值，參考圖 8，<br/><br>不過缺點是輸出的邊界很容易黑黑的，但是可以省去很多例外條件的判斷。</p><p><img src="https://i.imgur.com/3CBMICm.png" alt="圖 8、邊界處理：補零"></p><p>至於為了獲得更好的效果，我們可以像圖 9 那樣，<br>把圖片的邊界「延伸」到圖片外一圈，如此一來，就會得到更好的效果。</p><p><img src="https://i.imgur.com/DgqiZSQ.png" alt="圖 9、邊界處理：延伸"></p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><iframe scrolling="no" width="100%" height="530px" src="https://jsfiddle.net/40unwrc5/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><div class="note info">            <p>此演示的圖像邊界是採用「跳過不處理」的方式</p>          </div><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li>《数字图像处理（第三版）》(ISBN：9787121110085)</li><li><a href="https://www.yourdictionary.com/image-filter">image filter - Computer Definition</a></li><li><a href="https://rocky69.pixnet.net/blog/post/218272785-%5B%E8%BD%89%5D%E6%BF%BE%E6%B3%A2%E5%92%8C%E5%8D%B7%E7%A9%8D">滤波和卷积</a></li><li><a href="https://en.wikipedia.org/wiki/Kernel_(image_processing)" title="" target="">Wikipedia: Kernel (image processing)</a></li><li><a href="https://en.wikipedia.org/wiki/Salt-and-pepper_noise" title="" target="">Wikipedia: Salt-and-pepper noise</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>直方圖均化 Histogram Equalization</title>
      <link href="//histogram-equalization/"/>
      <url>//histogram-equalization/</url>
      
        <content type="html"><![CDATA[<p>之前影像處理課有寫過直方圖均化（Histogram Equalization）的程式，<br>這篇是重新紀錄做法，以及提供 Web 的演示。</p><span id="more"></span><p>因為最近稍微小忙，為了保持每月更新的步調，<br>所以挑了一個比較簡單的主題先寫這樣 XD”</p><div class="note success">            <p>請參閱 <a href="/ming-chuan-university-homework/" title="我的大學作業整理">我的大學作業整理</a> 的「影像處理課程」部分。</p>          </div><h1 id="色階與直方圖"><a href="#色階與直方圖" class="headerlink" title="色階與直方圖"></a>色階與直方圖</h1><p>圖片的「色階」（level）是統計圖片像素的灰階亮度或各顏色分量，<br>然後依照其值與像素的數量，畫成一張直方圖（histogram）如圖 1 所示：</p><p><img src="https://i.imgur.com/Ms1N4xX.png" alt="圖 1、Paint.net 中的色階"></p><div class="note info">            <p>嚴格說，色階是顏色亮度的強弱，但直方圖是表示色階的一種圖表；<br>表示色階未必要用直方圖，而且直方圖的 X 與 Y 軸也不見得是亮度與數量。</p>          </div><h1 id="直方圖均化"><a href="#直方圖均化" class="headerlink" title="直方圖均化"></a>直方圖均化</h1><p>直觀地說，直方圖均化（histogram equalization）做法是紀錄圖像中，每個像素（pixel）的亮度（brightness），<br>然後根據「每個像素亮度的數量」重新分配亮度的過程，具體作法如下：</p><ol><li>初始化直方圖 $h(c, v) &#x3D; 0 \ \forall c, v$ 其中 $c \in \{0, 1, 2\}$ 為顏色分量，而 $v &#x3D; [0, 255] \in N$ 為統計數量</li><li>遍歷所有像素，計算出直方圖 $h(c, v)$</li><li>根據直方圖 $h$ 算出累積分布函數（Cumulative Distribution Function, CDF）<br>其定義為 $CDF(c, v) &#x3D; \sum_{i &#x3D; 0}^{v} h(c, i)$</li><li>按 $CDF$ 比例，重新分配像素 $p(c)$ 顏色 $c$ 的亮度值，定義為：</li></ol><p>$$<br>p_{new}(c) &#x3D; round\left(\text{color_range} \cdot \frac{p_{old}(c) - CDF_{min}(c)}{\text{image_size} - CDF_{min}(c)}\right) \ \forall c<br>$$</p><p>其中，根據累積分布函數的定義，有 $CDF_{min}(c) &#x3D; CDF(c, 0)$ 的關係，<br>而 $\text{color_range}$ 是該顏色 $c$ 的最大值、$\text{image_size}$ 的圖片像素總數（寬、高相乘），<br>另外就是 $round$ 函數實際上可以根據需要調整（常見的候選為 $floor(x)$ 及 $ceil(x)$ 函數）。</p><p>具體的程式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 直方圖初始化 */</span></span><br><span class="line"><span class="keyword">let</span> histogram = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">256</span>&#125;, <span class="function">() =&gt;</span> <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍歷所有像素 */</span></span><br><span class="line"><span class="keyword">let</span> pixels = imgData.<span class="property">data</span>;                              <span class="comment">// 讀取的圖片值，存在 ImageData 中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = pixels.<span class="property">length</span>; i &lt; l; i += <span class="number">4</span>) &#123;     <span class="comment">// 每個像素都有紅, 綠, 藍及透明度，共 4 個值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c += <span class="number">1</span>) &#123;                      <span class="comment">// 紀錄 3 種顏色的數量</span></span><br><span class="line">    histogram[c][pixels[i + c]] += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 累積分布函數初始化 */</span></span><br><span class="line"><span class="keyword">let</span> cdf = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">256</span>&#125;, <span class="function">() =&gt;</span> <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 計算累積分布函數 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c += <span class="number">1</span>) &#123;                        <span class="comment">// 遍歷所有顏色</span></span><br><span class="line">  cdf[c][<span class="number">0</span>] = histogram[c][<span class="number">0</span>];                          <span class="comment">// 紀錄第一個數量值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">256</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">    cdf[c][i] = cdf[c][i - <span class="number">1</span>] + histogram[c][i];        <span class="comment">// 累計後面所有數量的值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定義一些變數 */</span></span><br><span class="line"><span class="keyword">let</span> w = imgData.<span class="property">width</span>;                                  <span class="comment">// 舊圖片的寬度</span></span><br><span class="line"><span class="keyword">let</span> h = imgData.<span class="property">height</span>;                                 <span class="comment">// 舊圖片的高度</span></span><br><span class="line"><span class="keyword">let</span> max = w * h;                                        <span class="comment">// 圖片的像素總數（image_size = width*height）</span></span><br><span class="line"><span class="keyword">let</span> newData = imageContext.<span class="title function_">createImageData</span>(w, h);       <span class="comment">// 宣告新圖片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 開始直方圖均化 */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c += <span class="number">1</span>) &#123;                        <span class="comment">// 遍歷所有顏色</span></span><br><span class="line">  <span class="keyword">let</span> min = cdf[c][<span class="number">0</span>];                                  <span class="comment">// 取的該顏色最小 CDF 值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = pixels.<span class="property">length</span>; i &lt; l; i += <span class="number">4</span>) &#123;   <span class="comment">// 遍歷所有像素</span></span><br><span class="line">    <span class="keyword">let</span> v = cdf[c][pixels[i + c]];                      <span class="comment">// 取得 CDF 值</span></span><br><span class="line">    <span class="keyword">let</span> r = (v - min) / (max - min);                    <span class="comment">// 計算該 CDF 值的比例</span></span><br><span class="line">    newData.<span class="property">data</span>[i + c] = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">255</span> * r);          <span class="comment">// 設定新圖片的像素顏色（color_range = 255）</span></span><br><span class="line">    newData.<span class="property">data</span>[i + <span class="number">3</span>] = <span class="number">255</span>;                          <span class="comment">// 設定新圖片的像素透明度</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note success">            <p>關於讀取、顯示圖片，請參考 <a href="/javascript-file-process/" title="JavaScript 檔案處理">JavaScript 檔案處理</a> 及 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData">MDN ImageData</a> 相關文章。</p>          </div><div class="note info">            <p>在 Paint.net 軟體中的「自動色階」功能，就是「直方圖均化」。</p>          </div><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><iframe scrolling="no" width="100%" height="600px" src="https://jsfiddle.net/9v4xg21t/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><div class="note info">            <p>重複執行多次直方圖均化時，由於浮點數經過 $round(x)$ 函數，<br>會導致直方圖有時候會有稍微差異（約 1 個亮度值），但是對於圖片來說，並不會造成視覺上的改變。</p>          </div>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Next 的 Local Search 菜單位置</title>
      <link href="//hexo-next-local-search/"/>
      <url>//hexo-next-local-search/</url>
      
        <content type="html"><![CDATA[<p>由於要準備發新文章，開始重新考慮一些文章管理的事情，其中最重要的是「站內搜索」。<br>這篇文章只是記錄一個設定上的小問題而已……</p><span id="more"></span><h1 id="開啟-Local-Search-功能"><a href="#開啟-Local-Search-功能" class="headerlink" title="開啟 Local Search 功能"></a>開啟 Local Search 功能</h1><p>首先，在 Hexo 的 Next 主題開啟 Local Search 非常容易，<br>只要在 <code>themes\next\_config.yml</code> 中，找到：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>將 <code>local_search</code> 的 <code>enable</code> 設為 <code>true</code> 即可。</p><h1 id="調整-Local-Search-位置"><a href="#調整-Local-Search-位置" class="headerlink" title="調整 Local Search 位置"></a>調整 Local Search 位置</h1><p>預設 Local Search 在主選單的位置如圖 1 所示，會自動插入在最末處：</p><p><img src="https://i.imgur.com/KHVtWAN.png" alt="圖 1、預設 Local Search 的菜單位置"></p><p>基本上沒辦法直接從 <code>_config.yml</code> 設定位置，<br>如果要改到首頁的下方，則可以到 <code>themes\next\layout\_partials\header\menu.swig</code> 修改程式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;nav class=&quot;site-nav&quot;&gt;</span><br><span class="line">  &#123;% if theme.menu %&#125;</span><br><span class="line">    &lt;ul id=&quot;menu&quot; class=&quot;menu&quot;&gt;</span><br><span class="line">      &#123;% for name, path in theme.menu %&#125;</span><br><span class="line">        渲染每一行選單連結</span><br><span class="line">      &#123;%- endfor %&#125;</span><br><span class="line"></span><br><span class="line">      &#123;% set hasSearch = theme.swiftype_key || theme.algolia_search.enable || theme.local_search.enable %&#125;</span><br><span class="line">      &#123;% if hasSearch %&#125;</span><br><span class="line">        渲染 Local Search 功能連結</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  其他主題樣式的處理</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure><p>不難理解，假設我們需要把「搜索」的位置移動到「首頁」下方，<br>那只要把渲染 Local Search 功能，先插入到上方的 <code>for</code> 迴圈中，<br>然後加上一個條件 <code>name == &#39;home&#39;</code> 跟隨首頁進行渲染即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;nav class=&quot;site-nav&quot;&gt;</span><br><span class="line">  &#123;% if theme.menu %&#125;</span><br><span class="line">    &lt;ul id=&quot;menu&quot; class=&quot;menu&quot;&gt;</span><br><span class="line">      &#123;% for name, path in theme.menu %&#125;</span><br><span class="line">        渲染每一行選單連結</span><br><span class="line"></span><br><span class="line">        跟隨首頁進行渲染</span><br><span class="line">        &#123;% if name == &#x27;home&#x27; %&#125;</span><br><span class="line">          &#123;% set hasSearch = theme.swiftype_key || theme.algolia_search.enable || theme.local_search.enable %&#125;</span><br><span class="line">          &#123;% if hasSearch %&#125;</span><br><span class="line">            渲染 Local Search 功能連結</span><br><span class="line">          &#123;% endif %&#125;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">      &#123;%- endfor %&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  其他主題樣式的處理</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure><div class="note info">            <p>需要注意的是，隨著需求不同，設下的條件（<code>name == &#39;home&#39;</code>）可能不一樣，<br>你應該檢查 <code>_config.yml</code> 的 <code>menu</code> 區域設定，來獲得正確的條件。</p>          </div><div class="note info">            <p>關於渲染 swig 代碼塊，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:swig %&#125;</span><br><span class="line">&#123;% raw %&#125;</span><br><span class="line">...</span><br><span class="line">&#123;% endraw %&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>          </div>]]></content>
      
      
      <categories>
          
          <category> 網頁設計 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊羽手札更新歷程 05</title>
      <link href="//tinytsunami-update-05/"/>
      <url>//tinytsunami-update-05/</url>
      
        <content type="html"><![CDATA[<p>總之雖然有點遲到，預祝 2020 諸事順遂；<br>然後接下來應該會準備發新文章了。</p><span id="more"></span><h1 id="更新歷程"><a href="#更新歷程" class="headerlink" title="更新歷程"></a>更新歷程</h1><ul><li>2016.10.24 羊羽手札v1（PHP）</li><li>2017.12.18 羊羽手札v2（Vue.js+Express）</li><li>2017.02.25 羊羽手札v3（Hexo）</li><li>2017.02.25 更新歷程 01 發表</li><li>2018.07.01 更新歷程 02 發表</li><li>2018.09.24 暫停更新</li><li>2018.09.24 更新歷程 03 發表</li><li>2019.03.28 重啟更新</li><li>2019.04.20 羊羽手札v4（Hexo&#x2F;Next Update）</li><li>2019.04.20 更新歷程 04 發表</li><li>2020.02.25 更新歷程 05 發表</li></ul><h1 id="新年賀圖"><a href="#新年賀圖" class="headerlink" title="新年賀圖"></a>新年賀圖</h1><p><img src="https://i.imgur.com/3zotrQ3.png" alt="圖 1、2020 新年賀圖"></p>]]></content>
      
      
      <categories>
          
          <category> 羊羽手札 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RMMV 音樂遊戲</title>
      <link href="//rpg-maker-mv-music-game/"/>
      <url>//rpg-maker-mv-music-game/</url>
      
        <content type="html"><![CDATA[<p>這篇文章將公開前作《Thinking at night》的音樂遊戲插件，<br>以及介紹其使用方法、譜面撰寫方法之類的內容。</p><p>一方面期待 RM 圈未來能有其他更好的作品，<br>另外也希望能讓一些樂師更容易製作屬於自己的音樂遊戲。</p><span id="more"></span><div class="note info">            <p>關於遊戲請參考 <a href="/thinking-at-night/" title="Thinking at night">Thinking at night</a></p>          </div><div class="note info">            <p>更多插件請參考我的 <a href="https://github.com/tinytsunami/RMMV-Plugins">GitHub(RMMV-Plugins)</a></p>          </div><h1 id="插件發布"><a href="#插件發布" class="headerlink" title="插件發布"></a>插件發布</h1><p>這個插件我發布於 <a href="https://github.com/tinytsunami/RMMV-Plugins/tree/master/MusicGame">GitHub</a> 上，<br>使用說明我會重貼在這裡，主要是增加一點補充（我比較喜歡個人部落格的排版）這樣。</p><p>下面統一稱本插件為「MusicGame」這樣。</p><div class="note info">            <p>題外話，譜面撰寫的格式，很大一部分參考了太鼓次郎的譜面檔案（.tja）格式。</p>          </div><h2 id="更新歷程"><a href="#更新歷程" class="headerlink" title="更新歷程"></a>更新歷程</h2><ul><li>2019.11.10 《Thinking at night》遊戲公開</li><li>2019.12.10 MusicGame v1.0：插件整理完成並內部公開</li><li>2020.01.03 MusicGame v1.1：新增切換數字、背景、分數統計功能</li><li>2020.01.09 MusicGame v1.2：新增長音音符功能</li><li>2020.01.16 MusicGame v1.2：插件正式發表</li></ul><h2 id="利用條款"><a href="#利用條款" class="headerlink" title="利用條款"></a>利用條款</h2><p>本插件採用 <a href="https://en.wikipedia.org/wiki/MIT_License">MIT 授權 (MIT License)</a>。  </p><p>也就是說，基本上你用這個插件可以做任何事，<br>原本 MIT 授權，需包含著作權聲明（作者）和許可聲明（MIT 授權）標示；<br>但考慮到遊戲發布的特殊性，我基本只要求著作權聲明。</p><p>簡單的說，你只需要保留插件註解的作者一行即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@author 羊羽</span><br></pre></td></tr></table></figure><p>另外，關於 <a href="https://en.wikipedia.org/wiki/Closing_credits">Closing credits</a> 是沒有要求的；不過如果有，我會很高興就是了。</p><div class="note info">            <p>其他問題請 <a href="mailto:z27619273@gmail.com">來信聯絡</a></p>          </div><h1 id="使用說明"><a href="#使用說明" class="headerlink" title="使用說明"></a>使用說明</h1><p>這個插件的說明有一點點複雜，尤其是譜面的部分。  </p><h2 id="插件參數"><a href="#插件參數" class="headerlink" title="插件參數"></a>插件參數</h2><table><thead><tr><th align="left">名稱</th><th align="left">型別</th><th align="left">預設值</th><th align="left">說明</th></tr></thead><tbody><tr><td align="left">music data</td><td align="left">Json:File</td><td align="left">data&#x2F;game&#x2F;Music.json</td><td align="left">音樂譜面的檔案</td></tr><tr><td align="left">control keys</td><td align="left">Refer to help:String</td><td align="left">up, right, down, left</td><td align="left">玩家操控的按鈕</td></tr><tr><td align="left">auto play</td><td align="left">[0, 1]Z:Boolean</td><td align="left">0</td><td align="left">自動演奏</td></tr><tr><td align="left">auto pause</td><td align="left">[0, 1]Z:Boolean</td><td align="left">1</td><td align="left">遊戲跟隨窗口狀態自動暫停與開始</td></tr><tr><td align="left">pitch rate</td><td align="left">[1, inf)Z:Number</td><td align="left">100</td><td align="left">演奏速率</td></tr><tr><td align="left">start delay</td><td align="left">[0, inf)Z:Number</td><td align="left">300</td><td align="left">音樂載入後<br/>第一個音符到達前的空白預留時間</td></tr><tr><td align="left">end delay</td><td align="left">[0, inf)Z:Number</td><td align="left">300</td><td align="left">演奏結束後<br/>等待回到上一個場景的空白預留時間</td></tr><tr><td align="left">BGM volume</td><td align="left">[0, 100]Z:Number</td><td align="left">80</td><td align="left">BGM 播放的音量</td></tr><tr><td align="left">trackes number</td><td align="left">[1, inf)Z:Number</td><td align="left">4</td><td align="left">設定的軌道數</td></tr><tr><td align="left">trackes direction</td><td align="left">Refer to help:String</td><td align="left">left to right</td><td align="left">軌道方向</td></tr><tr><td align="left">trackes x position</td><td align="left">Refer to help:String</td><td align="left">766, 766, 766, 766</td><td align="left">軌道 X 位置</td></tr><tr><td align="left">trackes y position</td><td align="left">Refer to help:String</td><td align="left">162, 262, 362, 462</td><td align="left">軌道 Y 位置</td></tr><tr><td align="left">image background</td><td align="left">Image:File</td><td align="left">img&#x2F;pictures&#x2F;background</td><td align="left">預設演奏時的背景圖片</td></tr><tr><td align="left">image note</td><td align="left">Image:File</td><td align="left">img&#x2F;pictures&#x2F;note</td><td align="left">演奏時的相關音符圖片</td></tr><tr><td align="left">image max combo</td><td align="left">Image:File</td><td align="left">img&#x2F;pictures&#x2F;number</td><td align="left">演奏時的連擊數字圖片</td></tr><tr><td align="left">image max combo digits</td><td align="left">[1, inf)Z:Number</td><td align="left">3</td><td align="left">最大連擊位數</td></tr><tr><td align="left">image max combo x offset</td><td align="left">(-inf, inf)Z:Number</td><td align="left">372</td><td align="left">最大連擊 X 位置</td></tr><tr><td align="left">image max combo y offset</td><td align="left">(-inf, inf)Z:Number</td><td align="left">296</td><td align="left">最大連擊 Y 位置</td></tr><tr><td align="left">image score</td><td align="left">Image:File</td><td align="left">img&#x2F;pictures&#x2F;number</td><td align="left">演奏時的分數數字圖片</td></tr><tr><td align="left">image score digits</td><td align="left">[1, inf)Z:Number</td><td align="left">7</td><td align="left">分數位數</td></tr><tr><td align="left">image score x offset</td><td align="left">(-inf, inf)Z:Number</td><td align="left">10</td><td align="left">分數 X 位置</td></tr><tr><td align="left">image score y offset</td><td align="left">(-inf, inf)Z:Number</td><td align="left">10</td><td align="left">分數 Y 位置</td></tr><tr><td align="left">animation hit</td><td align="left">Refer to help:String</td><td align="left">1, 2, 3, 4</td><td align="left">按下按鍵時的動畫編號</td></tr><tr><td align="left">animation great hit</td><td align="left">Refer to help:String</td><td align="left">5, 5, 5, 5</td><td align="left">按下按鍵且擊出 great 的動畫</td></tr><tr><td align="left">animation good hit</td><td align="left">Refer to help:String</td><td align="left">6, 6, 6, 6</td><td align="left">按下按鍵且擊出 good 的動畫</td></tr><tr><td align="left">animation miss hit</td><td align="left">Refer to help:String</td><td align="left">7, 7, 7, 7</td><td align="left">按下按鍵且擊出 miss 的動畫</td></tr><tr><td align="left">animation connect hit</td><td align="left">Refer to help:String</td><td align="left">8, 8, 8, 8</td><td align="left">按下按鍵的長音播放動畫</td></tr><tr><td align="left">variable total</td><td align="left">[1, inf)Z:Number</td><td align="left">1</td><td align="left">紀錄結果音符數量的變數</td></tr><tr><td align="left">variable great</td><td align="left">[1, inf)Z:Number</td><td align="left">2</td><td align="left">紀錄結果 great 數量的變數</td></tr><tr><td align="left">variable good</td><td align="left">[1, inf)Z:Number</td><td align="left">3</td><td align="left">紀錄結果 good 數量的變數</td></tr><tr><td align="left">variable miss</td><td align="left">[1, inf)Z:Number</td><td align="left">4</td><td align="left">紀錄結果 miss 數量的變數</td></tr><tr><td align="left">variable combo</td><td align="left">[1, inf)Z:Number</td><td align="left">5</td><td align="left">紀錄結果當前 combo 的變數</td></tr><tr><td align="left">variable max combo</td><td align="left">[1, inf)Z:Number</td><td align="left">6</td><td align="left">紀錄結果 max combo 的變數</td></tr><tr><td align="left">variable score</td><td align="left">[1, inf)Z:Number</td><td align="left">7</td><td align="left">紀錄結果 score 的變數</td></tr><tr><td align="left">precision great</td><td align="left">[1, inf)R:Number</td><td align="left">4.0</td><td align="left">判斷為 Great 的精度範圍<br/>單位是為流速倍率</td></tr><tr><td align="left">precision good</td><td align="left">[1, inf)R:Number</td><td align="left">8.0</td><td align="left">判斷為 Good 的精度範圍<br/>單位是為流速倍率</td></tr><tr><td align="left">precision miss</td><td align="left">[1, inf)R:Number</td><td align="left">12.0</td><td align="left">判斷為 Miss 的精度範圍<br/>單位是為流速倍率</td></tr><tr><td align="left">score great</td><td align="left">(-inf, inf)R:Number</td><td align="left">1000</td><td align="left">判定為 Great 的分數</td></tr><tr><td align="left">score good</td><td align="left">(-inf, inf)R:Number</td><td align="left">500</td><td align="left">判定為 Good 的分數</td></tr><tr><td align="left">score miss</td><td align="left">(-inf, inf)R:Number</td><td align="left">0</td><td align="left">判定為 Miss 的分數</td></tr><tr><td align="left">score connect</td><td align="left">(-inf, inf)R:Number</td><td align="left">1000</td><td align="left">完成長音的分數</td></tr></tbody></table><h3 id="Trackes-direction"><a href="#Trackes-direction" class="headerlink" title="Trackes direction"></a>Trackes direction</h3><table><thead><tr><th align="left">數值</th><th align="left">說明</th></tr></thead><tbody><tr><td align="left">left to right</td><td align="left">為音符由左至右</td></tr><tr><td align="left">right to left</td><td align="left">為音符由右至左</td></tr><tr><td align="left">bottom to top</td><td align="left">為音符由下至上</td></tr><tr><td align="left">top to bottom</td><td align="left">為音符由下至上</td></tr></tbody></table><div class="note warning">            <p>輸入其他內容，自動變成「left to right」</p>          </div><h3 id="Control-keys"><a href="#Control-keys" class="headerlink" title="Control keys"></a>Control keys</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;key_1&gt;, &lt;key_2&gt;, ... <span class="comment">// 字元</span></span><br></pre></td></tr></table></figure><p>其中每個參數皆為字串，為「<code>Input.keyMapper</code>」與「英文鍵中任意字符」都可以。<br>關於 <code>Input.keyMapper</code> 的部分請參考：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Input</span>.<span class="property">keyMapper</span> = &#123;</span><br><span class="line">    <span class="number">9</span>: <span class="string">&#x27;tab&#x27;</span>,       <span class="comment">// tab</span></span><br><span class="line">    <span class="number">13</span>: <span class="string">&#x27;ok&#x27;</span>,       <span class="comment">// enter</span></span><br><span class="line">    <span class="number">16</span>: <span class="string">&#x27;shift&#x27;</span>,    <span class="comment">// shift</span></span><br><span class="line">    <span class="number">17</span>: <span class="string">&#x27;control&#x27;</span>,  <span class="comment">// control</span></span><br><span class="line">    <span class="number">18</span>: <span class="string">&#x27;control&#x27;</span>,  <span class="comment">// alt</span></span><br><span class="line">    <span class="number">27</span>: <span class="string">&#x27;escape&#x27;</span>,   <span class="comment">// escape</span></span><br><span class="line">    <span class="number">32</span>: <span class="string">&#x27;ok&#x27;</span>,       <span class="comment">// space</span></span><br><span class="line">    <span class="number">33</span>: <span class="string">&#x27;pageup&#x27;</span>,   <span class="comment">// pageup</span></span><br><span class="line">    <span class="number">34</span>: <span class="string">&#x27;pagedown&#x27;</span>, <span class="comment">// pagedown</span></span><br><span class="line">    <span class="number">37</span>: <span class="string">&#x27;left&#x27;</span>,     <span class="comment">// left arrow</span></span><br><span class="line">    <span class="number">38</span>: <span class="string">&#x27;up&#x27;</span>,       <span class="comment">// up arrow</span></span><br><span class="line">    <span class="number">39</span>: <span class="string">&#x27;right&#x27;</span>,    <span class="comment">// right arrow</span></span><br><span class="line">    <span class="number">40</span>: <span class="string">&#x27;down&#x27;</span>,     <span class="comment">// down arrow</span></span><br><span class="line">    <span class="number">45</span>: <span class="string">&#x27;escape&#x27;</span>,   <span class="comment">// insert</span></span><br><span class="line">    <span class="number">81</span>: <span class="string">&#x27;pageup&#x27;</span>,   <span class="comment">// Q</span></span><br><span class="line">    <span class="number">87</span>: <span class="string">&#x27;pagedown&#x27;</span>, <span class="comment">// W</span></span><br><span class="line">    <span class="number">88</span>: <span class="string">&#x27;escape&#x27;</span>,   <span class="comment">// X</span></span><br><span class="line">    <span class="number">90</span>: <span class="string">&#x27;ok&#x27;</span>,       <span class="comment">// Z</span></span><br><span class="line">    <span class="number">96</span>: <span class="string">&#x27;escape&#x27;</span>,   <span class="comment">// numpad 0</span></span><br><span class="line">    <span class="number">98</span>: <span class="string">&#x27;down&#x27;</span>,     <span class="comment">// numpad 2</span></span><br><span class="line">    <span class="number">100</span>: <span class="string">&#x27;left&#x27;</span>,    <span class="comment">// numpad 4</span></span><br><span class="line">    <span class="number">102</span>: <span class="string">&#x27;right&#x27;</span>,   <span class="comment">// numpad 6</span></span><br><span class="line">    <span class="number">104</span>: <span class="string">&#x27;up&#x27;</span>,      <span class="comment">// numpad 8</span></span><br><span class="line">    <span class="number">120</span>: <span class="string">&#x27;debug&#x27;</span>    <span class="comment">// F9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他參考值"><a href="#其他參考值" class="headerlink" title="其他參考值"></a>其他參考值</h3><p>下面 8 個參數的數量皆應與 trackes number 對應，<br>每個值都以「,」隔開，空白將會忽略，型別請參考註解內容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">trackes x position      <span class="comment">// (-inf, inf)Z:Number</span></span><br><span class="line">trackes y position      <span class="comment">// (-inf, inf)Z:Number</span></span><br><span class="line">control keys            <span class="comment">// Refer to help:String</span></span><br><span class="line">animation hit           <span class="comment">// [1, inf)Z:Number</span></span><br><span class="line">animation great hit     <span class="comment">// [1, inf)Z:Number</span></span><br><span class="line">animation good hit      <span class="comment">// [1, inf)Z:Number</span></span><br><span class="line">animation miss hit      <span class="comment">// [1, inf)Z:Number</span></span><br><span class="line">animation connect hit   <span class="comment">// [1, inf)Z:Number</span></span><br></pre></td></tr></table></figure><h2 id="插件指令"><a href="#插件指令" class="headerlink" title="插件指令"></a>插件指令</h2><p>隨時可以使用的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MusicGame auto true                  // 開啟自動演奏</span><br><span class="line">MusicGame auto false                 // 關閉自動演奏</span><br></pre></td></tr></table></figure><p>遊戲外可以使用的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MusicGame start &lt;id&gt;                 // 以第 &lt;id&gt; 首音樂開始遊戲</span><br><span class="line">MusicGame read &lt;id&gt; &lt;args&gt; &lt;var_id&gt;  // 讀取第 &lt;id&gt; 首音樂的參數 &lt;args&gt; 到第 &lt;var_id&gt; 號變數</span><br></pre></td></tr></table></figure><p>遊戲場景中可以使用的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MusicGame pause true                 // 暫停遊戲</span><br><span class="line">MusicGame pause false                // 暫停結束</span><br><span class="line">MusicGame end                        // 遊戲結束</span><br><span class="line">MusicGame number &lt;filename&gt;          // 數字圖片更改為 &lt;filename&gt;</span><br><span class="line">MusicGame number reset               // 數字圖片重設為預設圖片</span><br><span class="line">MusicGame score great &lt;number&gt;       // 將 Great 得分數設為 &lt;number&gt; 分</span><br><span class="line">MusicGame score good &lt;number&gt;        // 將 Good 得分數設為 &lt;number&gt; 分</span><br><span class="line">MusicGame score miss &lt;number&gt;        // 將 Miss 得分數設為 &lt;number&gt; 分</span><br><span class="line">MusicGame score connect &lt;number&gt;     // 將長音得分數設為 &lt;number&gt; 分</span><br></pre></td></tr></table></figure><p>所有插件指令的參數，皆不允許空白；若為檔案位置名稱，則不需副檔名。</p><h2 id="設定說明"><a href="#設定說明" class="headerlink" title="設定說明"></a>設定說明</h2><p>在指定目錄 <code>MUSICGAME_FOLDER</code> 的底下，<br>放置 <code>music.json</code> 與  檔案，檔案結構如下所示：</p><pre><code>[    &#123;        &quot;name&quot;: &lt;樂曲名&gt;,        &quot;file&quot;: &lt;樂曲檔名&gt;,        &quot;background&quot;: &lt;背景圖片&gt;,        &quot;level&quot;: &lt;難度分級&gt;,        &quot;sign&quot;: &lt;拍號&gt;,        &quot;bpm&quot;: &lt;曲速&gt;,        &quot;speed&quot;: &lt;音符流速&gt;,        &quot;sheet&quot;: &lt;譜面&gt;    &#125;,    ...]</code></pre><p>每個大括號的內容都為一首樂曲，而「樂曲編號」是這首樂曲在陣列中的序位，<br>除了樂曲編號不用填寫外，其他欄位的說明如下：</p><ul><li>「樂曲名、樂曲檔名」為字串，且樂曲檔名應置於 <code>./audio/bgm</code> 底下（不需副檔名）</li><li>「背景圖片」為字串，且圖片檔名應置於 <code>./picture/</code> 底下（不需副檔名，省略時為參數預設）</li><li>「難度分級」為一數字（整數、小數皆可）</li><li>「拍號」為長度二的陣列，像是四四拍應寫成 <code>[4, 4]</code></li><li>「曲速」為一整數</li><li>「音符流速」為一整數，單位是像素&#x2F;每幀（pixel&#x2F;frame）</li><li>「譜面」為二維陣列，如下說明設定</li></ul><h2 id="譜面撰寫"><a href="#譜面撰寫" class="headerlink" title="譜面撰寫"></a>譜面撰寫</h2><p>對於譜面，第一個維度會放置小節數，第二個維度放置指定軌道的音符（二進制）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 譜面 */</span></span><br><span class="line">[</span><br><span class="line">    [...], <span class="comment">// 第 1 小節</span></span><br><span class="line">    [...], <span class="comment">// 第 2 小節</span></span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>我們這邊以《Thinking at night》三個軌道為例。<br>《Thinking at night》的主題曲，開頭的 3 小節主旋律（小節線用灰線補強）如下：</p><p><img src="https://i.imgur.com/oVOt63C.png" alt="圖 1、Thinking at night 曲目的主旋律"></p><p>第一步，我們只拿第一小節，由於這裡所有音符都是 8 分音符，所以我們切割成 8 份，<br>如果我們想將其簡化成如圖 2 右邊的樣子：</p><p><img src="https://i.imgur.com/1P1f6mt.png" alt="圖 2、第一小節簡化版"></p><p>接下來考慮二進位，<br>注意最高位與最低位相反跟軌道放置順序有關，<br>我這邊是由左至右排列（最低位在最左邊）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">001</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">010</span> -&gt; <span class="number">2</span></span><br><span class="line"><span class="number">001</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">010</span> -&gt; <span class="number">2</span> </span><br><span class="line"><span class="number">001</span> -&gt; <span class="number">4</span></span><br><span class="line"><span class="number">100</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">011</span> -&gt; <span class="number">6</span></span><br></pre></td></tr></table></figure><p>按照前後方向整理，這裡譜面是向下流動，所以整理成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line">    [<span class="number">6</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],   <span class="comment">// 第 1 小節</span></span><br><span class="line">    [...],                      <span class="comment">// 第 2 小節</span></span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>這個就是基本譜面的撰寫。</p><h3 id="複雜的旋律"><a href="#複雜的旋律" class="headerlink" title="複雜的旋律"></a>複雜的旋律</h3><p>很多時候會看到多個音符分布的情況，考慮下列小節：</p><p><img src="https://i.imgur.com/tWkIpMK.png" alt="圖 3、小節內有多種音符"></p><p>這個時候應該以「最小單位的音符」為準，圖 3 中最小單位是「16 分音符」。<br>譜面中的小節將會是 16 個數字，然後可以先大致想一下要怎麼安排位置，如圖四：</p><p><img src="https://i.imgur.com/5RrspdH.png" alt="圖 4、抽象化的音符位置"></p><p>然後，因為發出聲音的瞬間，是在音符開頭的地方（而非拉長的地方）<br>所以我們放置抽象的音符應該長的像圖 5 所示：</p><p><img src="https://i.imgur.com/JemY2ue.png" alt="圖 5、白點處為譜面音符位置"></p><p>撰寫譜面為：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="comment">// 注意音符為向下流動，圖 5 最下方的白格是第一個元素</span></span><br></pre></td></tr></table></figure><div class="note info">            <p>雖然說有音軌的話，旋律幾乎不會出錯，但實際效果還是需要重複多聽幾次以及實際去玩才能感受</p>          </div><h3 id="音符縮寫"><a href="#音符縮寫" class="headerlink" title="音符縮寫"></a>音符縮寫</h3><p>考慮圖 6 的音軌，這是短音與長音同處一小節的情況：</p><p><img src="https://i.imgur.com/3YnmcaF.png" alt="圖 6、短音與長音"></p><p>如果按照前面的想法，那這裡最小單位是 16 分音符，<br>則我們可能會寫出這樣的譜面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二進制</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">100</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">010</span> -&gt; <span class="number">2</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">100</span> -&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 譜面</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>不難發現，我們的譜面大部分都為 <code>0</code> 且難以觀察，曲子一長就很難修改。<br>這時我們可以將這一小節縮寫，方式非常簡單：兩兩一組，拿掉後面的數字即可。<br>相當於：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二進制</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span> <span class="comment">// 刪除</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span> <span class="comment">// 刪除</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span> <span class="comment">// 刪除</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span> <span class="comment">// 刪除</span></span><br><span class="line"><span class="number">100</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span> <span class="comment">// 刪除</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span> <span class="comment">// 刪除</span></span><br><span class="line"><span class="number">010</span> -&gt; <span class="number">2</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span> <span class="comment">// 刪除</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="number">000</span> -&gt; <span class="number">0</span> <span class="comment">// 刪除</span></span><br><span class="line"><span class="number">100</span> -&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 譜面</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>再進一步縮寫，可以得到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 譜面</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>其實眼尖的人應該可以發現，音符縮寫其實相當於去修改譜面的最小單位：<br><img src="https://i.imgur.com/DD1Enph.png" alt="圖 7、縮寫的意義"></p><div class="note info">            <p>能這樣縮寫，是因為小節的時間，是程式依照陣列元素自動切割的。</p>          </div><h3 id="長音符"><a href="#長音符" class="headerlink" title="長音符"></a>長音符</h3><p>如果上面都懂了，那麼這裡就很容易，我們再次以圖 6 舉例。<br>長音需要「開頭」以及「結尾」，如果將圖 6 的第三個音符當作長音符，<br>於下一小節結束，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>],   <span class="comment">// 圖 6 縮寫後</span></span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]    <span class="comment">// 開頭的 1 為結尾</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>則把數字寫成陣列，並於第二維度標示長音即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">1</span>, <span class="number">1</span>], <span class="number">0</span>],   <span class="comment">// 圖 6 最後一個音為長音</span></span><br><span class="line">    [[<span class="number">1</span>, <span class="number">1</span>], <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]    <span class="comment">// 開頭的 1 為長音結尾</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>長音的格式為：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">/*原本的音符*/</span>, <span class="comment">/*長音標示*/</span>]</span><br></pre></td></tr></table></figure><p>例如，全部三軌都要按下，但只有第二軌是長音，也是辦的到的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="comment">// 原本的音符 (111 = 7)</span></span><br><span class="line">  ^   <span class="comment">// 長音標示 (010 = 4)</span></span><br></pre></td></tr></table></figure><div class="note warning">            <p>小心！長音沒有正確關閉的話，會出錯！</p>          </div><h1 id="演示專案"><a href="#演示專案" class="headerlink" title="演示專案"></a>演示專案</h1><p>我有準備一個演示的專案可以提供給需要的人下載，<br>當然也可以直接修改本專案來製作遊戲。</p><div class="note primary">            <p><a href="https://drive.google.com/file/d/1Op2lpthvHUenQ5BmZpobAbPv-qo6GYYZ/view?usp=sharing">下載演示專案 (Google Drive)</a></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 羊羽手札 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Thinking at night</title>
      <link href="//thinking-at-night/"/>
      <url>//thinking-at-night/</url>
      
        <content type="html"><![CDATA[<p>這是一個蒐集我編曲作品的音樂遊戲。</p><p>當初看到國外素材全原創的遊戲，很想把這樣的風氣帶回 R 圈；<br>為此我跑去學了程式、美術跟音樂，目標是做出一個全原創的遊戲。</p><p>不過事情總是沒有這麼順利，許多專案都棄坑或塵封了……</p><span id="more"></span><p>自誤入作曲與編曲的領域後，就一直想做一個作品的大合集，<br>因緣際會看到 RPG 2020 比賽，就決定捲起袖子完成這個小小的夢想。</p><div class="note info">            <p>同步發布於 <a href="https://forum.gamer.com.tw/C.php?bsn=4918&snA=29415&tnum=1">巴哈姆特</a></p>          </div><h1 id="遊戲介紹"><a href="#遊戲介紹" class="headerlink" title="遊戲介紹"></a>遊戲介紹</h1><p><img src="https://i.imgur.com/zPMiv63.png" alt="Thinking at night 封面圖"></p><p><strong>【遊戲名稱】</strong> Thinking at night<br><strong>【最新版本】</strong> v1.3<br><strong>【遊戲類型】</strong> 音樂遊戲<br><strong>【開發引擎】</strong> RPG Maker MV<br><strong>【檔案大小】</strong> 195 MB &#x2F; 101 MB(zip)<br><strong>【遊玩時間】</strong> 約 60 分鐘<br><strong>【素材來源】</strong> 全自製<br><strong>【下載連結】</strong> <a href="https://tinytsunami.itch.io/thinking-at-night">itch.io</a></p><iframe frameborder="0" src="https://itch.io/embed/516570?border_width=0&amp;bg_color=222&amp;fg_color=ffffff&amp;link_color=5b7efa&amp;border_color=4e4e4e" width="550" height="165"></iframe><div class="note info">            <p>原 Google Drive 下載版（桌面版），請直接由 itch.io 內連結下載。</p>          </div><div class="note warning">            <p>有些鍵盤不能支援多鍵同時按下，可能需要自行設定到可用的鍵位</p>          </div><h1 id="曲目列表"><a href="#曲目列表" class="headerlink" title="曲目列表"></a>曲目列表</h1><p>這個作品有 16 首原創音樂，演奏特定歌曲後，才會解鎖某些曲目（不論成績皆會解鎖）<br>最後一首音樂是「Ending Mix」，只有前面所有曲目都通過才會解鎖。</p><p>下面是 SoundCloud 的曲目列表，可以線上收聽。</p><iframe width="100%" height="450" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/playlists/919956049&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe><h1 id="更新紀錄"><a href="#更新紀錄" class="headerlink" title="更新紀錄"></a>更新紀錄</h1><div class="note success">            <p>更新紀錄提供給大家參考，目前的最新版是 <a href="#v1-3-%E7%89%88">v1.3 版</a></p>          </div><h2 id="v1-1-版"><a href="#v1-1-版" class="headerlink" title="v1.1 版"></a>v1.1 版</h2><p><strong>更新說明</strong></p><ul><li>標題增加開始遊戲的按鍵提示</li><li>移除曲目 Clear 解鎖條件，現在只要演奏完就解鎖新曲</li><li>加入 Great &#x2F; Good &#x2F; Miss 擊中動畫</li><li>Hit 改成 Accuracy 字樣</li><li>部分曲目流速加速</li><li>部分曲目譜面修正</li><li>重開時按鍵操作消失 Bug 修正</li><li>現在會紀錄每首歌最高 Accuracy 的分數</li><li>在設定狀態中，顯示操作提示</li><li>設定熱鍵由 tab 改成 shift</li><li>中途退出曲目與暫停功能</li><li>放寬判定標準，現在的判定為 [6.02, 12.04, 14.45] 幀倍率</li></ul><div class="note warning">            <p>v1.0 版的紀錄不再適用 v1.1 版</p>          </div><div class="note info">            <p>v1.1 版開始，按下 shift 可以中途暫停或退出</p>          </div><h2 id="v1-2-版"><a href="#v1-2-版" class="headerlink" title="v1.2 版"></a>v1.2 版</h2><p><strong>發行說明</strong></p><ul><li>不再提供極致壓縮的 7z 版</li><li>新增了 Itch.io 的線上版</li><li>接下來將會釋出這個音樂遊戲的核心腳本（目前正在整理中）</li></ul><p><strong>更新說明</strong></p><ul><li>手寫字風格 UI 修正</li><li>增加選曲標示 UI&#x2F;UX 修正</li><li>增加自動演奏（auto-play）功能</li><li>增加三種難度 Easy, Normalcy, Crazy 的譜面</li><li>每首歌的難度分級由 3 顆星變為 8 顆星</li></ul><p><strong>譜面調整</strong></p><ul><li>thinking at night 的原譜現被歸類到 Normalcy 難度</li><li>umbrella 的原譜現被歸類到 Crazy 難度</li><li>night forset roadd 的原譜被歸類到 Crazy 難度，並調整單連 2&#x2F;4 連擊處</li><li>balasute meet 的原譜被歸類到 Normalcy 難度</li><li>balasute battle 的原譜被歸類到 Crazy 難度</li><li>bar 的原譜被歸類到 Crazy 難度</li><li>bye bye tomorrow 的原譜簡化後為 Normalcy 難度，並在 Crazy 難度中變得更具挑戰性</li><li>common battle 的原譜被歸類到 Crazy 難度</li><li>conspiracy 的原譜被歸類到 Crazy 難度</li><li>desert scorpion 的原譜被歸類到 Crazy 難度</li><li>fragmentation 的原譜被歸類到 Crazy 難度</li><li>fragmentation 在 Normalcy 難度中被略為簡化，而 Easy 難度中，去除 3&#x2F;6 連擊處</li><li>leave 的原譜被歸類到 Crazy 難度</li><li>leave 的 Normalcy 難度的譜面與 Crazy 相同，但音符的流速更快</li><li>leave 的 Easy 難度中刪去了 1-2-3-2-1-2-… 樓梯型連擊</li><li>letter from you 的原譜被歸類到 Normalcy 難度</li><li>letter from you 的 Crazy 難度強化了 3&#x2F;6 拍打擊</li><li>letter from you 在 Easy 難度中去除了 16 分音符</li><li>on way 的原譜被歸類到 Crazy 難度</li><li>on way 於 Normalcy 難度中去除了 1-2-3-2-1-2-… 樓梯型連擊</li><li>the a minor 的原譜被歸類到 Crazy 難度</li><li>the a minor 在 Easy 難度中簡化節奏與調降音符流速度</li><li>ending mix 的原譜被歸類到 Normalcy難度，為各類難度譜面的集合</li></ul><div class="note warning">            <p>v1.1 版的紀錄不再適用 v1.2 版</p>          </div><div class="note info">            <p>v1.1 版開始，按下 Ctrl 可以自動演奏</p>          </div><h2 id="v1-3-版"><a href="#v1-3-版" class="headerlink" title="v1.3 版"></a>v1.3 版</h2><p><strong>發行說明</strong></p><ul><li>現在開始不再提供 Google Drive 的檔案，請直接在 itch.io 下載</li><li>音樂遊戲插件已經整理完成，目前正在撰寫使用說明</li></ul><p><strong>更新說明</strong></p><ul><li>新增「長音符」（需要在長音開頭按下直至結尾，完成打擊）</li><li>大部分譜面更新（少數沒有增加長音，少數譜面大改）</li><li>曲目 Desert Scorpion 的圖標修正</li><li>曲目 Desert Scorpion 音樂修正</li><li>羊羽手札的顯示畫面修正</li><li>部分曲目的星數調整</li></ul><p><strong>星數調整</strong></p><ul><li>Balasute meet (Normalcy) 難度調整為 ★6</li><li>Balasute meet (Crazy) 難度調整為 ★7</li><li>Beer bar (Crazy) 難度調整為 ★7</li><li>Bye bye tomorrow (Easy) 難度調整為 ★3</li><li>Desert scorpion (Normalcy) 難度調整為 ★8</li><li>Leave (Easy) 難度調整為 ★2</li><li>Letter from you (Crazy) 難度調整為 ★6</li><li>On way (Crazy) 難度調整為 ★6</li><li>The a minor (Easy) 難度調整為 ★3</li></ul><div class="note info">            <p>從 1.2 版升級到 1.3 版時。桌面版紀錄 save 資料夾可以複製到 www 目錄底下，<br>解鎖、演奏完成的資訊可被繼承，而 Great、Good、Miss、MaxCombo 等，分數類紀錄將歸零。</p>          </div><h1 id="開發花絮"><a href="#開發花絮" class="headerlink" title="開發花絮"></a>開發花絮</h1><p>其實這不是我第一部公開的遊戲，但是這是第一部發布的遊戲。<br>記得以前巴哈 RM 版有遊戲發布預告的討論串，我發過一款名為「躲怪遊戲」的遊戲預告。<br>（RMVX，後來有嘗試把該遊戲遷移到 RMMV）</p><p>那個時間點大概是剛學會寫 RMVX 腳本的時候……<br>而這個遊戲被那個棄坑作影響深遠，大概可以這樣理解吧 XDD”</p><h2 id="樂曲背景"><a href="#樂曲背景" class="headerlink" title="樂曲背景"></a>樂曲背景</h2><p>《Thinking at night》（夜中思考）曲名是源於我經常熬夜，<br>不知道為何，深夜靈感比較豐富，這遊戲的曲目大部分都是深夜完成的。<br>不計《Ending Mix》的話，這首是這個遊戲最晚寫的曲目。</p><p>《Umbrella》（傘）是最早寫的曲目，大約是躲怪遊戲預告發布後一陣子（2014 年前後），<br>完成這首曲目時，午後下起了太陽雨，所以無論是雨傘或陽傘的解釋都是對的。</p><p>《Night forest road》（夜晚森林之路，我常簡稱為夜森之路或夜森），<br>封面的路燈是原本躲怪遊戲的怪物「結界路燈」，而這首最早是希望作為遊戲夜晚森林的 BGM。<br>值得一提的是，這首歌設計上是 Clarinet（單簧管）跟 Flute（長笛）交互演奏主旋律的曲子，<br>最早的版本沒有 73~105 小節的合奏。</p><p><img src="https://i.imgur.com/9BEVNRn.jpg" alt="圖 1、躲怪遊戲的路燈（事件出沒）"><br><img src="https://i.imgur.com/8qC0WRT.png" alt="圖 2、結界路燈的形象圖"></p><div class="note info">            <p>結界路燈原本應該是魔法都市附近森林的怪物，躲怪遊戲因特殊事件而出沒在城堡中。</p>          </div><p>關於 Balasute（巴拉斯特）是躲怪遊戲的一位女性 NPC 角色，這個遊戲偷偷塞了兩首她的 BGM 在裡面，<br>分別是《Balasute meet》（巴拉斯特遭遇）以及《Balasute battle》（巴拉斯特戰鬥）。</p><p>《Bye bye tomorrow》（再見明天）是我有一陣子低潮時的作品，當時真的想要直接結束，不過後來挺過來了。<br>上吊繩的由來是，當時閱讀完全自殺手冊後，發現上吊是這本書最推薦的自殺方法。<br>原本我有想過放上吊繩會不會把遊戲搞得「不合主流」，但是想要保留最初的原意，就沒有拿掉了。<br>這首原曲改過三次，遊戲中是第三版。</p><p>《Conspiracy》的迷之動物其實是羊駝 (我發現幾乎所有人都覺得我畫的是長頸鹿)<br>因為這些音樂都是用 LMMS 作曲的，其中有個 LB302 的樂器插件是羊駝圖案。這首歌幾乎都是用這個樂器插件完成的。<br>另外，曲目中的低頻噪音是飛機起降的聲音，在 Crazy 的曲末，我用譜面模擬了飛機跑道。</p><p><img src="https://i.imgur.com/lFw2BGR.png" alt="圖 3、LB302 的樂器插件"></p><p>《Fragmentation》（碎片）對我來說是畢業歌，當時恰逢學校畢業，碎片指的是回憶的碎片。<br>遊戲中的畫面是左上的橘色背景跟飛散的照片。</p><p>《Letter from you》（來自你的信）原本是寫在某論壇作曲教學的成品。<br>當時選曲的時候發覺大部分的曲目都很難，所以想放一首相對簡單的來平衡這樣……</p><p>《the a minor》這首曲名是雙關，意思是 the a minor（一個小調）及 the A minor（這個 A 小調）。<br>顧名思義，全曲是 A 小調寫成，這是早期作品。圖中的蜥蜴是在 youtube 發布音樂時，隨手撇的蜥蜴。</p><p>《Ending Mix》是選擇我最愛的曲目完成的，所以沒有包含所有歌曲 XD<br>另外這首是 FL Studio 寫成的，也可以作為我從 LMMS 搬家到 FL Studio 的里程碑：</p><p><img src="https://i.imgur.com/7Sup7TK.jpg" alt="圖 4、《Ending Mix》樂曲軌道"></p><p>然後這曲的設計順序是：</p><ol><li>用較慢的 Thinking at night 動機當開頭</li><li>小銜接段，切進原創的段落，這裡我稱為 Bridge-A</li><li>敲 4 拍鼓邊，切進 Fragmentation 副歌</li><li>一個長音切到 Umbrella 的主歌</li><li>鋼琴琶音後，切入 4 個主拍上行銜接段，然後鼓聲驟停 1 小節，切入 Bridge-B</li><li>用比較急的鼓拍子，切入 on way 的特色段落（爬樓梯段落）</li><li>延續爬樓梯的旋律，敲一個鈸切到 Night forest road</li><li>Night forest road 這裡速度比原曲快，所以我把管樂換成純鋼琴</li><li>標準 4 拍切到最後一個 Bridge-C</li><li>用跳音切入 Bye bye Tomorrow 這裡是減慢版</li><li>過門加速切回 Thinking at night 副歌，以此結尾</li></ol><p>其中 Bridge-A 希望設計成 RPG 冒險開始的感覺，<br>而 Bridge-B 是 RPG 遭遇曲折，最後 Bridge-C 是 RPG 過夜劇情的感覺 XDD</p><h2 id="視覺設計"><a href="#視覺設計" class="headerlink" title="視覺設計"></a>視覺設計</h2><p>關於這個遊戲的選圖，其實是很掙扎的，<br>先要決定手上的音樂要搭什麼圖片，然後放置於主圖中的位置，<br>最早只有決定路燈、鯨魚跟上吊繩的相對位置。</p><p>原本還打算放一些極早期的作品，只是因為換電腦很多曲子的分軌檔都不見了 QQ</p><p><img src="https://i.imgur.com/Pk74d03.jpg" alt="圖 5、主圖的設計草稿"></p><p>最早的遊戲難度與分級是我自己打過一輪，然後把百分比排序，切成三組（標示 1~3 星）<br>後來多數玩家反應說難度太高，我才發覺我太鼓七段自己測試根本失準 XD”</p><p>所以在新版本中，我把難度切出來了，<br>在這裡的一個小彩蛋是難度分級 Easy、Normalcy 跟 Crazy 押韻。<br>（Normalcy 是常態的意思）</p><p>至於最早曲目的解鎖順序是難度為基準的，<br>但是新版本中調整譜面後，這層關係就沒這麼明顯了。</p><p><img src="https://i.imgur.com/BoPh5Zq.jpg" alt="圖 6、自己測試的成績紀錄手稿（最初版）"></p><h2 id="製作後續"><a href="#製作後續" class="headerlink" title="製作後續"></a>製作後續</h2><div class="note info">            <p>這個音樂遊戲的插件請參考 <a href="/rpg-maker-mv-music-game/" title="RMMV 音樂遊戲">RMMV 音樂遊戲</a></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 獨立遊戲製作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拉格朗日插值 Lagrange polynomial interpolation</title>
      <link href="//lagrange-polynomial-interpolation/"/>
      <url>//lagrange-polynomial-interpolation/</url>
      
        <content type="html"><![CDATA[<p>第一次認識拉格朗日插值，源自於名叫 Paint.NET 的繪圖軟體，<br>這個軟體陪我走過 RPG Maker VX 的許多歲月。</p><span id="more"></span><p>當初在尋找適合製作 Pixel art 的軟體時，筆者當時選擇軟體的條件是「既不能太複雜、也不能太陽春」。<br>因緣際會遇到了 Paint.NET，它的功能足夠，操作也很簡單，所以我很快就喜歡上了。</p><p><img src="https://i.imgur.com/WCnpBLH.jpg" alt="圖 1、個人製作的遊戲畫面圖（素材皆為 Paint.NET 繪製）"></p><p>當時除了用它製作基本的 Pixel 素材之外，也會用它做一些遊戲的特殊效果（像光影）之類的，<br>它其中一個重要的功能是「設定各個顏色的曲線」：</p><p><img src="https://i.imgur.com/fw0N6s6.jpg" alt="圖 2、Paint.NET 的曲線功能"></p><p>當時就在想，要怎麼實作這個功能呢？網路上一查，就碰到「拉格朗日（Lagrange）插值」了！</p><h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>插值，意思就是手上有一些資料點：</p><p>$\{(x_0, y_0), (x_1, y_1), (x_2, y_2) …, (x_{n-1}, y_{n-1})\}$</p><p>找一個函數，去「穿過」這些點：</p><p>$f(x_i) &#x3D; y_i, \quad i &#x3D; 0, 1, …, n-1$</p><p>而這邊接下來討論的是「多項式插值」，<br>也就是說，我們預期 $f(x)$ 是一個多項式，我們表示成 $P(x)$</p><div class="note success">            <p>建議閱讀 <a href="#">Post not found: 線性回歸與梯度下降-Linear Regression-and-Gradient-Descent</a><br>比較「插值（interpolation）」跟「擬合（fitting）」的差別。</p>          </div><div class="note info">            <p>插值可以細分為內插（interpolation）與外插（extrapolation）；<br>一般說插值是指內插，而如果預測的點出現在資料點的最大區間之外，則稱為外插。</p>          </div><h1 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h1><p>拉格朗日插值多項式：</p><p>$$<br>P(x) &#x3D; \sum\limits_{i&#x3D;0}^{n-1} y_i \ell_i(x)<br>$$</p><p>其中 $\ell_i(x)$ 為插值基函數：</p><p>$$<br>\ell_i(x) &#x3D; \prod\limits_{j&#x3D;0, j \neq i}^{n-1} \frac{(x - x_i)}{(x_i - x_j)}<br>$$</p><p>因為有特性：<br>$$<br>\ell_i(x_j) &#x3D; \delta_{ij} &#x3D;<br>\begin{cases}<br>    1, \qquad\text{if } i &#x3D; j \\<br>    0, \qquad\text{if } i \neq j \\<br>\end{cases}<br>$$</p><div class="note info">            <p>式中的 $\delta_{ij}$ 是指 <a href="https://en.wikipedia.org/wiki/Kronecker_delta">克羅內克 delta 函數 (Kronecker delta function)</a></p>          </div><p>導致任意點對 $(x_k, y_k)$ 帶入後都有：</p><p>$$<br>y_k \ell_k(x_k) &#x3D; y_k<br>$$</p><p>所以 $P(x)$ 必可穿過 $0, 1, …, n-1$ 所有的點對。</p><h1 id="多項式的點值表示"><a href="#多項式的點值表示" class="headerlink" title="多項式的點值表示"></a>多項式的點值表示</h1><p>插值在最初我看到時，是用在影像處理編輯圖片的操作上；<br>直到有次在《算法導論》中看到插值結果的唯一性證明，發現它也可以用多項式的點值表示，<br>更進一步可以用在計算快速傅立葉轉換上。</p><p>原本我們是有點對：<br>$\{(x_0, y_0), (x_1, y_1), (x_2, y_2) …, (x_{n-1}, y_{n-1})\}$</p><p>透過這些點對找多項式函數，也就是多項式函數的係數，滿足：</p><p>$$<br>P(x_k) &#x3D; a_0 + a_1x_k + a_2x_k^2 + \dots + a_{n-1}x_k^{n-1} &#x3D; y_k, \quad k &#x3D; 0, 1, \dots, n-1<br>$$</p><p>通常我們都將 $x$ 當成函數輸入，即 $Ax &#x3D; y$；<br>但現在我們改以 $a$ 當成函數輸入，並將 $k$ 展開，表示成矩陣有：</p><p>$$<br>Xa &#x3D; y<br>$$</p><p>$$<br>\left[ \begin{matrix}<br>1 &amp; x_{0} &amp; x_{0}^{2} &amp; \dots &amp; x_{0}^{n-1} \\<br>1 &amp; x_{1} &amp; x_{1}^{2} &amp; \dots &amp; x_{1}^{n-1} \\<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>1 &amp; x_{n-1} &amp; x_{n-1}^{2} &amp; \dots  &amp; x_{n-1}^{n-1}<br>\end{matrix} \right]<br>\left[ \begin{matrix}<br>a_{0} \\<br>a_{1} \\<br>\vdots \\<br>a_{n-1}<br>\end{matrix} \right]<br>&#x3D;<br>\left[ \begin{matrix}<br>y_{0} \\<br>y_{1} \\<br>\vdots \\<br>y_{n-1}<br>\end{matrix} \right]<br>$$</p><p>其中 $X$ 為 <a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E5%BE%B7%E8%92%99%E7%9F%A9%E9%99%A3">Vandermonde 矩陣</a><br>當 $i \neq j$ 時，有 $x_i \neq x_j$，則行列式 $det(X) \neq 0$<br>$X$ 可逆，代表唯一存在一組 $a$ 是唯一解，滿足 $Xa &#x3D; y$</p><p>既然係數 $a$ 是唯一的，那多項式函數 $P(x)$ 也是唯一的，<br>代表了，表示多項式時，我有兩種選擇方法：</p><ol><li>直接儲存 $a_0, a_1, \dots, a_n$ 共 $n$ 個係數</li><li>儲存 $(x_0, y_0), (x_1, y_1), (x_2, y_2) …, (x_{n-1}, y_{n-1})$ 共 $n$ 組點對</li></ol><p>而第二種儲存點對的方式，被稱為多項式的「點值表示」。</p><div class="note info">            <p>點值表示有一些很有趣的性質，<br>比方說兩個多項式相乘的複雜度，在係數表示時是 $\Theta(n^2)$，但在點值表示僅需 $\Theta(n)$。</p>          </div><p>至於用點值表示做其他事情，就超出本文的範圍了。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>這個演示可以上傳一張照片，用插值曲線調整顏色。</p><iframe scrolling="no" width="100%" height="600px" src="https://jsfiddle.net/hyjb39e7/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的大學作業整理</title>
      <link href="//ming-chuan-university-homework/"/>
      <url>//ming-chuan-university-homework/</url>
      
        <content type="html"><![CDATA[<p>隨著銘傳大學畢業後，攻讀研究所，一直很捨不得一些過去大學時期的作業；<br>這篇是整理大學時期的所有作業（當成是個人的小作品）放在這篇文章裡。</p><span id="more"></span><p>也許有人會說「作業有什麼好留的」，<br>但是因為筆者的心態是很極端的「要嘛認真做、要嘛擺爛」，<br>（既然一開始無心幹嘛浪費時間，不如去幹其他事。）</p><p>又因為特別喜歡軟體課，變成軟體課的作業都很認真寫，<br>所以對於某些東西真的覺得未來找不到會很可惜。</p><h1 id="資料結構與演算法"><a href="#資料結構與演算法" class="headerlink" title="資料結構與演算法"></a>資料結構與演算法</h1><p>因為老師有特別說過可以整理，所以這門課的作業特別整理過，<br>而且這個 Blog 的 <a href="/sort/" title="排序 Sort">排序 Sort</a> 最早就是出自 C++ 的排序作業（105上學期作業1）。</p><p>後來 Blog 的 Code 有重寫過，因為初版某些排序寫太爛了。</p><div class="note success">            <p>作業連結：<a href="https://github.com/tinytsunami/MCU-DSA">GitHub: tinytsunami&#x2F;MCU-DSA</a></p>          </div><p>同時，從大概第一次修課的這個時候撰寫 Blog 至今，最早是當成課堂筆記用。</p><h1 id="多媒體導論"><a href="#多媒體導論" class="headerlink" title="多媒體導論"></a>多媒體導論</h1><p>最主要的工作是 Python 的小精靈專案，因為那個是要參加私立大學軟體什麼東西的。<br>不過實際參展的時候，發現全部學校都是用期末專題，只有我們這邊是課程專案……</p><p>當時的主要作品是多人連線版小精靈，但是連線 Server 的檔案（多人）丟失了，<br>純 Client 版本（單人）在 GitHub 可以找到。</p><div class="note success">            <p>作業連結：<a href="https://github.com/tinytsunami/Python-Game">GitHub: tinytsunami&#x2F;Python-Game</a></p>          </div><h1 id="影像處理課程"><a href="#影像處理課程" class="headerlink" title="影像處理課程"></a>影像處理課程</h1><p>影像處理課的作業是寫 C++ 程式，然後發布成果與心得到作業 Blog 上，<br>其實一直想轉寫所有的 Code 成 Javascript 版本到自己的 Blog，但之後再說。</p><div class="note success">            <p>作業連結：<a href="http://hwshow-ipc.blogspot.com/search/label/04360783%20%E6%B2%88%E9%83%81%E7%BF%94">影像處理作業 Blog</a></p>          </div><p>題外話，這篇作業整理是因為找這個 Blog 找了老半天，<br>所以乾脆一次找好放在自己 Blog 裡。</p><h1 id="互動遊戲製作"><a href="#互動遊戲製作" class="headerlink" title="互動遊戲製作"></a>互動遊戲製作</h1><p>這門課的先修課是影像處理，而互動遊戲製作的 C++ 專案是一個學期的，<br>目標是製作一個透過 webcam 可以與人或環境「互動」的遊戲。<br>（當時剛好碰到 PokemonGo 熱潮，大概就是那樣的東西。）</p><p>我的專案很晚才做，是因為題目一直不確定，找靈感花了很多時間，<br>大部分時間都在 <a href="https://itch.io/">itch.io</a> 尋找一些免費的獨立遊戲發掘靈感。</p><p>當時最吸引我的是 <a href="https://gamesbyjens.itch.io/kinoko">KINOKO</a><br>我的個人分類為「禪遊戲」（畫面漂亮、安靜愜意，而且沒有明確目標的遊戲。）</p><p>最後是因為某個朋友圈剛好有養魚遊戲的訊息，加上某個朋友暱稱叫「魚」，<br>所以開始有一些想法，最後延伸成一些問題：<br>扭曲的畫面在程式上如何寫？把畫面當成魚缸如何？色調如何處理？景色如何搭配？</p><p>解決這些問題，就變成我的最終專案「養魚遊戲」。<br>（似乎很適合放在 Blog 當放置遊戲）</p><div class="note success">            <p>作業連結：<a href="https://hwshow-vgc.blogspot.com/search/label/04360783%20%E6%B2%88%E9%83%81%E7%BF%94">互動遊戲專案 Blog</a></p>          </div><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>「躲怪遊戲」是我從大學入學前就不斷在製作的遊戲，只是現在已經棄坑了，<br>一開始世界觀弄太大，雖然後來有做完，但是跟心目中的差太多就沒公開發布。</p><p>而且某一次把家裡 PC 的螢幕換成 1920*1080 以後，<br>才發現 RMVX 的視窗太小了，連我 Debug 盯著畫面都很痛苦。</p><p>意外翻到遊戲最後 Ending 的圖片，最後就放上這張圖片，<br>作為我大學時代的人生里程碑，正式劃下句點。</p><p><img src="https://i.imgur.com/FEDSAAz.jpg" alt="圖 1、躲怪遊戲完結圖之一"></p>]]></content>
      
      
      <categories>
          
          <category> 羊羽手札 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前、中及後序 Preorder, Inorder and Postorder</title>
      <link href="//preorder-inorder-postorder/"/>
      <url>//preorder-inorder-postorder/</url>
      
        <content type="html"><![CDATA[<p>研究所開學前想把一些比較簡單的內容寫完，<br>然後正式邁入下個階段，要學的東西還很多……</p><span id="more"></span><div class="note success">            <p>這篇文章需要堆疊與佇列的基本知識，請參考 <a href="/stack-and-queue/" title="堆疊與佇列 Stack and Queue">堆疊與佇列 Stack and Queue</a></p>          </div><h1 id="運算子與運算元"><a href="#運算子與運算元" class="headerlink" title="運算子與運算元"></a>運算子與運算元</h1><p>在開始介紹之前，可能要先提到運算子跟運算元。</p><p>運算子（operator）通俗的意思是「符號」，像是 + - * &#x2F; 之類的；<br>而運算元（operand）意思是「數字」或「代數」，像是 1, 2, 3,… 或 x, y, z, …等都是運算元。</p><p>本篇文章使用的運算子包含：</p><ul><li>加 +</li><li>減 -</li><li>乘 *</li><li>除 &#x2F;</li><li>冪 ^</li><li>左括號 (</li><li>右括號 )</li></ul><p>共 7 種運算子，而運算元則可以是任意數字。</p><h1 id="中序表示法"><a href="#中序表示法" class="headerlink" title="中序表示法"></a>中序表示法</h1><p>中序表示法（Infix order）就是一般常見的數學式，運算格式為「運算元 運算子 運算元」；<br>像是「1 + 1」、「3 * 2」、「3 ^ 3」等等皆屬中序表示，另外含括號的類型也是，<br>比如「5 &#x2F; ( 2 + 1 )」，因為「2 + 1」可以運算後變成「5 &#x2F; 3」，也是中序表示法。</p><p>要特別說明的是，電腦運算通常不使用中序表示，而使用前、後序表示；<br>因為資料常常從左讀取至右，前、後序都有隱含運算順序的能力，可以省去許多資料處理上的麻煩。</p><h1 id="前序表示法"><a href="#前序表示法" class="headerlink" title="前序表示法"></a>前序表示法</h1><p>前序表示法是將運算子放到所有運算元之前的表示法，格式為「運算子 運算元 運算元」；<br>像是「+ 1 1」、「* 3 2」、「^ 3 3」就是前序表示法。</p><p>由於前序表示已經隱含了運算順序，所以前序表示不需要括號也可以判斷運算順序。<br>像是「&#x2F; 5 + 2 1」就是先做「+ 2 1」再做「&#x2F; 5 3」。</p><div class="note info">            <p>不需要括號，不代表不能顯式寫出，比方說「&#x2F; 5 ( + 2 1 )」也是可以的。</p>          </div><h1 id="後序表示法"><a href="#後序表示法" class="headerlink" title="後序表示法"></a>後序表示法</h1><p>後序表示法是將運算子放置到所有運算元之後的表示法，格式為「運算元 運算元 運算子」；<br>像是「1 1 +」、「3 2 *」、「3 3 ^」就是後序表示法。</p><p>與前序表示一樣，後序表示法隱含了運算順序，所以不需要括號，<br>像是「5 2 1 + &#x2F;」就是先做「2 1 +」再做「5 3 &#x2F;」。</p><div class="note info">            <p>不需要括號，不代表不能顯式寫出，比方說「5 ( 2 1 + ) &#x2F;」也是可以的。</p>          </div><h1 id="中序轉前後序"><a href="#中序轉前後序" class="headerlink" title="中序轉前後序"></a>中序轉前後序</h1><p>先考慮中序轉換成前序，若以「1 + 2 * ( 3 - 4 ) &#x2F; 5」為例，<br>其對應前序為「+ 1 &#x2F; * 2 - 3 4 5」，後序轉換概念與前序一致。</p><p>我們觀察該式，如果電腦由左至右掃描，那麼經過轉換的式子，運算元應該對應順序不變。</p><p>但電腦掃到「1 + 2」時，不能直接轉換成「+ <u>1</u> <u>2</u>」，<br>因為尚未確定「1 + 2」之後的運算子，需要掃描到「1 + 2 *」才有足夠的資訊處理。</p><p>我們透過 2 個堆疊可以將中序轉換成前序，一個保留運算元資訊，另一個紀錄運算子。<br>詳細步驟稍後解釋，逐步的轉換步驟如下，掃描到的字元以顏色表示：</p><table><thead><tr><th>運算式</th><th>分類</th><th>運算子堆疊</th><th>運算元堆疊</th><th>處理原因</th></tr></thead><tbody><tr><td><code>1</code> + 2 * ( 3 - 4 ) &#x2F; 5</td><td>運算元</td><td>空</td><td><u>1</u></td><td>運算元直接加入堆疊</td></tr><tr><td>1 <code>+</code> 2 * ( 3 - 4 ) &#x2F; 5</td><td>運算子</td><td>+</td><td><u>1</u></td><td>運算子堆疊為空，直接加入堆疊</td></tr><tr><td>1 + <code>2</code> * ( 3 - 4 ) &#x2F; 5</td><td>運算元</td><td>+</td><td><u>1</u> <u>2</u></td><td>運算元直接加入堆疊</td></tr><tr><td>1 + 2 <code>*</code> ( 3 - 4 ) &#x2F; 5</td><td>運算子</td><td>+ *</td><td><u>1</u> <u>2</u></td><td>* 優先度高於 + 故加入堆疊</td></tr><tr><td>1 + 2 * <code>(</code> 3 - 4 ) &#x2F; 5</td><td>運算子</td><td>+ * (</td><td><u>1</u> <u>2</u></td><td>( 優先度高於 * 故加入堆疊</td></tr><tr><td>1 + 2 * ( <code>3</code> - 4 ) &#x2F; 5</td><td>運算元</td><td>+ * (</td><td><u>1</u> <u>2</u> <u>3</u></td><td>運算元直接加入堆疊</td></tr><tr><td>1 + 2 * ( 3 <code>-</code> 4 ) &#x2F; 5</td><td>運算子</td><td>+ * ( -</td><td><u>1</u> <u>2</u> <u>3</u></td><td>- 優先度高於 ( 加入堆疊</td></tr><tr><td>1 + 2 * ( 3 - <code>4</code> ) &#x2F; 5</td><td>運算元</td><td>+ * ( -</td><td><u>1</u> <u>2</u> <u>3</u> <u>4</u></td><td>運算元直接加入堆疊</td></tr><tr><td>1 + 2 * ( 3 - 4 <code>)</code> &#x2F; 5</td><td>運算子</td><td>+ * ( -</td><td><u>1</u> <u>2</u> <u>3</u> <u>4</u></td><td>) 需特殊處理</td></tr><tr><td>1 + 2 * ( 3 - 4 <code>)</code> &#x2F; 5</td><td>運算子</td><td>+ * (</td><td><u>1</u> <u>2</u> <u>- 3 4</u></td><td>運算子堆疊取出一個元素 - 檢查不為 ( <br/> 運算元堆疊取出兩個元素 <u>4</u> <u>3</u> <br/> 組合成 <u>- 3 4</u> 加回運算元堆疊</td></tr><tr><td>1 + 2 * ( 3 - 4 <code>)</code> &#x2F; 5</td><td>運算子</td><td>+ *</td><td><u>1</u> <u>2</u> <u>- 3 4</u></td><td>運算子堆疊取出一個元素 ( 檢查為 ( 結束特殊處理</td></tr><tr><td>1 + 2 * ( 3 - 4 ) <code>/</code> 5</td><td>運算子</td><td>+</td><td><u>1</u> <u>* 2 - 3 4</u></td><td>&#x2F; 與 * 優先度相等 <br/> 運算子堆疊取出一個元素 * <br/> 運算元堆疊取出兩個元素 <u>- 3 4</u> <u>2</u> <br/> 組合成 <u>* 2 - 3 4</u> 加回運算元堆疊</td></tr><tr><td>1 + 2 * ( 3 - 4 ) <code>/</code> 5</td><td>運算子</td><td>+ &#x2F;</td><td><u>1</u> <u>* 2 - 3 4</u></td><td>&#x2F; 優先度高於 + 故加入堆疊</td></tr><tr><td>1 + 2 * ( 3 - 4 ) &#x2F; <code>5</code></td><td>運算元</td><td>+ &#x2F;</td><td><u>1</u> <u>* 2 - 3 4</u> <u>5</u></td><td>運算元直接加入堆疊</td></tr><tr><td>1 + 2 * ( 3 - 4 ) &#x2F; 5</td><td>運算元</td><td>+ &#x2F;</td><td><u>1</u> <u>* 2 - 3 4</u> <u>5</u></td><td>掃描完畢</td></tr><tr><td>1 + 2 * ( 3 - 4 ) &#x2F; 5</td><td>運算元</td><td>+</td><td><u>1</u> <u>&#x2F; * 2 - 3 4 5</u></td><td>運算子堆疊取出一個元素 &#x2F; <br/> 運算元堆疊取出兩個元素 <u>5</u> <u>* 2 - 3 4</u> <br/> 組合成 <u>&#x2F; * 2 - 3 4 5</u> 加回運算元堆疊</td></tr><tr><td>1 + 2 * ( 3 - 4 ) &#x2F; 5</td><td>運算元</td><td>空</td><td><u>+ 1 &#x2F; * 2 - 3 4 5</u></td><td>運算子堆疊取出一個元素 + <br/> 運算元堆疊取出兩個元素 <u>&#x2F; * 2 - 3 4 5</u> <u>1</u> <br/> 組合成 <u>+ 1 &#x2F; * 2 - 3 4 5</u> 加回運算元堆疊</td></tr><tr><td>1 + 2 * ( 3 - 4 ) &#x2F; 5</td><td>運算元</td><td>空</td><td><u>+ 1 &#x2F; * 2 - 3 4 5</u></td><td>運算元堆疊頂端元素即為解</td></tr></tbody></table><p>從這個列表，我們可以歸納出下面這些結論：</p><ol><li>掃描到運算元，直接加入運算元堆疊</li><li>掃描到運算子，若其優先度高於運算子堆疊頂端元素，則直接加入運算子堆疊</li><li>掃描到運算子，若其優先度低於運算子堆疊頂端元素，則「清理堆疊」直到滿足第 2 點</li><li>掃描到運算子，若為「)」則「清理堆疊」直到運算子堆疊中「(」取出為止</li><li>掃描完畢後「清理堆疊」直到運算元堆疊只剩下 1 個元素</li></ol><p>至於「清理堆疊」的方法為：</p><ol><li>從運算子堆疊取出 1 個元素</li><li>從運算元堆疊取出 2 個元素</li><li>組合放回運算元堆疊</li></ol><div class="note info">            <p>從這裡可以發現，中序表示轉換成前序或後序，是由清理堆疊的第 3 步處理的。</p>          </div><p>運算子優先度接近其運算的優先度，列表如下：</p><table><thead><tr><th>運算子</th><th>優先度</th></tr></thead><tbody><tr><td>+</td><td>1</td></tr><tr><td>-</td><td>1</td></tr><tr><td>*</td><td>2</td></tr><tr><td>&#x2F;</td><td>2</td></tr><tr><td>^</td><td>3</td></tr><tr><td>(</td><td>出堆疊時，優先度為 0（因為要阻止它離開堆疊，直到配對「)」為止）<br/>進入堆疊時，優先度為 4（因為要強制加入堆疊中，等待「)」的配對）</td></tr><tr><td>)</td><td>特殊處理，不進入堆疊中（出現時，堆疊中必存在「(」，否則算式有誤）</td></tr></tbody></table><div class="note info">            <p>優先度是透過大小關係運作的，亦即大小關係正確即可，實際數值可以自行調整。</p>          </div><h1 id="前後序轉中序"><a href="#前後序轉中序" class="headerlink" title="前後序轉中序"></a>前後序轉中序</h1><p>與中序轉換成前後序不同，轉換回中序較簡單，<br>以前序為例，觀察下表，稍後整理步驟：</p><table><thead><tr><th>運算式</th><th>分類</th><th>運算元堆疊</th><th>處理原因</th></tr></thead><tbody><tr><td>+ 1 &#x2F; * 2 - 3 4 <code>5</code></td><td>運算元</td><td><u>5</u></td><td>運算元直接加入堆疊</td></tr><tr><td>+ 1 &#x2F; * 2 - 3 <code>4</code> 5</td><td>運算元</td><td><u>5</u> <u>4</u></td><td>運算元直接加入堆疊</td></tr><tr><td>+ 1 &#x2F; * 2 - <code>3</code> 4 5</td><td>運算元</td><td><u>5</u> <u>4</u> <u>3</u></td><td>運算元直接加入堆疊</td></tr><tr><td>+ 1 &#x2F; * 2 <code>-</code> 3 4 5</td><td>運算子</td><td><u>5</u> <u>(3 - 4)</u></td><td>從運算元堆疊取出兩個元素 <u>3</u> <u>4</u> <br/> 組合成 <u>(3 - 4)</u> 加回運算元堆疊 <br/> - 加入運算子堆疊</td></tr><tr><td>+ 1 &#x2F; * <code>2</code> - 3 4 5</td><td>運算元</td><td><u>5</u> <u>(3 - 4)</u> <u>2</u></td><td>運算元直接加入堆疊</td></tr><tr><td>+ 1 &#x2F; <code>*</code> 2 - 3 4 5</td><td>運算子</td><td><u>5</u> <u>(2 * (3 - 4))</u></td><td>從運算元堆疊取出兩個元素 <u>2</u> <u>(3 + 4)</u> <br/> 組合成 <u>(2 * (3 + 4))</u> 加回運算元堆疊 <br/> * 加入運算子堆疊</td></tr><tr><td>+ 1 <code>/</code> * 2 - 3 4 5</td><td>運算子</td><td><u>((2 * (3 - 4)) &#x2F; 5)</u></td><td>從運算元堆疊取出兩個元素 <u>(2 * (3 - 4))</u> <u>5</u> <br/> 組合成 <u>((2 * (3 - 4)) &#x2F; 5)</u> 加回運算元堆疊 <br/> &#x2F; 加入運算子堆疊</td></tr><tr><td>+ <code>1</code> &#x2F; * 2 - 3 4 5</td><td>運算元</td><td><u>((2 * (3 - 4)) &#x2F; 5)</u> <u>1</u></td><td>運算元直接加入堆疊</td></tr><tr><td><code>+</code> 1 &#x2F; * 2 - 3 4 5</td><td>運算子</td><td><u>(1 + ((2 * (3 - 4)) &#x2F; 5))</u></td><td>從運算元堆疊取出兩個元素 <u>1</u> <u>((2 * (3 - 4)) &#x2F; 5)</u> <br/> 組合成 <u>(1 + ((2 * (3 - 4)) &#x2F; 5))</u> 加回運算元堆疊 <br/> + 加入運算子堆疊</td></tr><tr><td>+ 1 &#x2F; * 2 - 3 4 5</td><td>運算元</td><td><u>(1 + ((2 * (3 - 4)) &#x2F; 5))</u></td><td>運算元堆疊頂端元素即為解</td></tr></tbody></table><p>同樣地，可以歸納出下面這些結論：</p><ol><li>前序轉中序時，反向掃描（因為要先掃到運算元）</li><li>後序轉中序時，正向掃描（因為要先掃到運算元）</li><li>掃描到運算元時，加入運算元堆疊</li><li>掃描到運算子時，執行「清理堆疊」</li></ol><p>至於「清理堆疊」的方法為：</p><ol><li>（掃描到的）運算子</li><li>從運算元堆疊取出 2 個元素</li><li>組合放回運算元堆疊（可以加入括號）</li></ol><div class="note info">            <p>不難發現，前序、後序表示運算的方法，就是轉換成中序的方法：將每一步清理堆疊的「組合」變成「計算」即可。</p>          </div>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>全連接神經網路 Fully-Connected Neural Network</title>
      <link href="//fully-connected-neural-network/"/>
      <url>//fully-connected-neural-network/</url>
      
        <content type="html"><![CDATA[<p>上一篇介紹的是邏輯回歸與感知器，這一篇將會討論「全連接神經網路」。</p><p>睽違 2 年的主要原因是覺得網路上關於反向傳播很多人寫了，<br>另外微積分其實我沒有掌握得很完全，所以很猶豫哪時要完成這篇文章。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>回顧邏輯回歸與感知器的文章，圖 1 是單科感知器的模型，現在我們將拓展它，<br>不難理解，單個感知器（perceptron）可以視作是簡化的邏輯回歸，也可以視作基本的神經元（neuron）。</p><p><img src="https://i.imgur.com/TGmNZoX.png" alt="圖 1、感知器"></p><p>在基於這個想法，我們堆砌感知器成神經網路，便可以解決上一篇提及的「線性不可分問題」。</p><div class="note success">            <p>這是 ANN 的系列文章<br>上一篇是 <a href="#">Post not found: 邏輯回歸與感知器-Logistic Regression-and-Perceptron</a></p>          </div><div class="note success">            <p>其他資源請參考：<a href="https://www.youtube.com/watch?v=PgcKcu-RMcc">解說影片</a></p>          </div><h1 id="神經網路簡介"><a href="#神經網路簡介" class="headerlink" title="神經網路簡介"></a>神經網路簡介</h1><p>全連接神經網路（Fully-connect Neural Network, FNN）是一種多個神經元的「連接模式」，<br>事實上，許多的神經網路模型都只是各種神經元的連接模式，而全連接神經網路是其中最簡單的一種，<br>參考圖 2 所示，全連接神經網路的特色是，上一層的神經元與下一層所有的神經元相接。</p><p><img src="https://i.imgur.com/QpM15R6.png" alt="圖 2、全連接神經網路示意圖"></p><p>我們將帶有數值的輸入，當成一個獨立的神經元，構成圖 2 藍色處，神經網路的輸入層（input layer）<br>然後圖 2 右邊深綠框為會輸出結果的輸出層（output layer），中間紫色框是神經網路的主體，稱為隱藏層（hidden layer）</p><div class="note info">            <p>計算神經網路層數時，通常不計算輸入層（input layer），請參考 <a href="https://datascience.stackexchange.com/questions/14027/counting-the-number-of-layers-in-a-neural-network">Counting the number of layers in a neural network</a> </p>          </div><p>在邏輯回歸時，我們訓練一組 $\theta$ 來完成任務，在神經網路的情況也是一樣，<br>我們將訓練 $\Theta$ 權重，由於維度增加，我們用大寫取代小寫，而權重出現在每一條神經元的連接中。<br>（圖 2 中帶箭頭的線是沒有權重的，那僅是表示輸入、出的箭頭。）</p><div class="note warning">            <p>注意第一段「各種神經元」，說明了神經網路的神經元並非只有一種。</p>          </div><h1 id="前向傳播演算法"><a href="#前向傳播演算法" class="headerlink" title="前向傳播演算法"></a>前向傳播演算法</h1><p>還記得當初學習「函數」的時候，是怎麼想像函數的嗎？<br>函數是一個機器，你可以給它一個值，它就會給你另一個值。</p><p>現在，全連接神經網路就是那部機器！我們的函數名為 $h_{\Theta}(X)$<br>計算這個函數值的過程，就稱為「前向傳播演算法（forward propagation algorithm）」。</p><p>試想我們輸入為列向量 $\boldsymbol{x}^{T} &#x3D; [x_{1}, x_{2}, …, x_{n}]$ 是一筆具有 $n$ 個特徵的資料，<br>若為第 $j$ 筆，我們表示為 $(\boldsymbol{x}^{(j)})^{T} &#x3D; [x_{1}^{(j)}, x_{2}^{(j)}, …, x_{n}^{(j)}]$<br>當我們有 $m$ 筆資料構成一個批次（batch）時，輸入矩陣為：</p><p>$$<br>X &#x3D;<br>\left[ \begin{matrix}<br>(\boldsymbol{x}^{(1)})^{T} \\<br>(\boldsymbol{x}^{(2)})^{T} \\<br>\vdots               \\<br>(\boldsymbol{x}^{(m)})^{T}<br>\end{matrix} \right]<br>&#x3D;<br>\left[ \begin{matrix}<br>x_{1}^{(1)} &amp; x_{2}^{(1)} &amp; \dots &amp; x_{n}^{(1)} \\<br>x_{1}^{(2)} &amp; x_{2}^{(2)} &amp; \dots &amp; x_{n}^{(2)} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>x_{1}^{(m)} &amp; x_{2}^{(m)} &amp; \dots  &amp; x_{n}^{(m)}<br>\end{matrix} \right]<br>$$</p><div class="note info">            <p>輸入資料的行、列可能相反，只要公式做對應的改變即可。</p>          </div><div class="note info">            <p>訓練神經網路時，通常會多筆資料一起訓練，而這個多筆資料則稱為一個批次（batch）</p>          </div><p>而假設第 $k$ 層為 $a \times b$ 的神經網路層，權重矩陣為：</p><p>$$<br>\Theta^{(k)} &#x3D;<br>\left[ \begin{matrix}<br>\Theta_{1, 1}^{(k)} &amp; \Theta_{1, 2}^{(k)} &amp; \dots  &amp; \Theta_{1, b}^{(k)} \\<br>\Theta_{2, 1}^{(k)} &amp; \Theta_{2, 2}^{(k)} &amp; \dots  &amp; \Theta_{2, b}^{(k)} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\Theta_{a, 1}^{(k)} &amp; \Theta_{a, 2}^{(k)} &amp; \dots  &amp; \Theta_{a, b}^{(k)}<br>\end{matrix} \right]<br>$$</p><p>上一篇文章邏輯回歸中的 $f(x)$ 函數，在神經網路被稱為激勵函數（activation function）<br>所以當 $X$ 往前計算一層時，只要將兩個矩陣相乘，然後套用激勵函數即可。</p><div class="note info">            <p>激勵函數通常只在輸出層使用，有許多不同的函數可供選擇，請參考 <a href="https://en.wikipedia.org/wiki/Activation_function">Wikipedia: activation function</a>；<br>從這裡也可以知道，激勵函數的一個作用是限制輸出值域。</p>          </div><p>彙整一下，舉例來說，第 1 層有：</p><p>$$<br>X\Theta^{(1)} &#x3D;<br>\left[ \begin{matrix}<br>(\boldsymbol{x}^{(1)})^{T} \\<br>(\boldsymbol{x}^{(2)})^{T} \\<br>\vdots \\<br>(\boldsymbol{x}^{(m)})^{T}<br>\end{matrix} \right]<br>\left[ \begin{matrix}<br>\Theta_{1, 1}^{(1)} &amp; \Theta_{1, 2}^{(1)} &amp; \dots  &amp; \Theta_{1, b}^{(1)} \\<br>\Theta_{2, 1}^{(1)} &amp; \Theta_{2, 2}^{(1)} &amp; \dots  &amp; \Theta_{2, b}^{(1)} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\Theta_{a, 1}^{(1)} &amp; \Theta_{a, 2}^{(1)} &amp; \dots  &amp; \Theta_{a, b}^{(1)}<br>\end{matrix} \right]<br>&#x3D;<br>\left[ \begin{matrix}<br>x_{1}^{(1)} &amp; x_{2}^{(1)} &amp; \dots &amp; x_{n}^{(1)} \\<br>x_{1}^{(2)} &amp; x_{2}^{(2)} &amp; \dots &amp; x_{n}^{(2)} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>x_{1}^{(m)} &amp; x_{2}^{(m)} &amp; \dots  &amp; x_{n}^{(m)}<br>\end{matrix} \right]<br>\left[ \begin{matrix}<br>\Theta_{1, 1}^{(1)} &amp; \Theta_{1, 2}^{(1)} &amp; \dots &amp; \Theta_{1, b}^{(1)} \\<br>\Theta_{2, 1}^{(1)} &amp; \Theta_{2, 2}^{(1)} &amp; \dots &amp; \Theta_{2, b}^{(1)} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\Theta_{a, 1}^{(1)} &amp; \Theta_{a, 2}^{(1)} &amp; \dots &amp; \Theta_{a, b}^{(1)}<br>\end{matrix} \right]<br>$$<br>$$<br>&#x3D;<br>\left[ \begin{matrix}<br>\sum\limits_{i &#x3D; 1}^{a} x_{i}^{(1)}\Theta_{i, 1}^{(k)} &amp; \sum\limits_{i &#x3D; 1}^{a} x_{i}^{(1)}\Theta_{i, 2}^{(k)} &amp; \dots &amp; \sum\limits_{i &#x3D; 1}^{a} x_{i}^{(1)}\Theta_{i, b}^{(k)} \\<br>\sum\limits_{i &#x3D; 1}^{a} x_{i}^{(2)}\Theta_{i, 1}^{(k)} &amp; \sum\limits_{i &#x3D; 1}^{a} x_{i}^{(2)}\Theta_{i, 2}^{(k)} &amp; \dots &amp; \sum\limits_{i &#x3D; 1}^{a} x_{i}^{(2)}\Theta_{i, b}^{(k)} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>\sum\limits_{i &#x3D; 1}^{a} x_{i}^{(m)}\Theta_{i, 1}^{(k)} &amp; \sum\limits_{i &#x3D; 1}^{a} x_{i}^{(m)}\Theta_{i, 2}^{(k)} &amp; \dots &amp; \sum\limits_{i &#x3D; 1}^{a} x_{i}^{(m)}\Theta_{i, b}^{(k)} \\<br>\end{matrix} \right]<br>$$</p><p>這是全部寫出來的情況，雖然看起來有點複雜，<br>但我們仔細觀察注標，可以發現這個矩陣大小關係為：</p><ul><li>$X$ 大小為 $m \times n$</li><li>$\Theta^{(1)}$ 大小為 $a \times b$</li><li>$X\Theta^{(1)}$ 大小為 $m \times b$</li></ul><div class="note info">            <p>輸入層的神經元數量，等於輸入資料的特徵數量，即有 $n &#x3D; a$ 的關係。</p>          </div><p>而第 2 層為 $b \times c$ 的神經網路，以 $X\Theta^{(1)}$ 作為輸入，<br>以此類推，假設我們有 $L$ 層，而激活函數為 $\phi(z)$，則前向傳播為：</p><p>$$<br>h_{\Theta}(X) &#x3D; \phi(X\Theta^{(1)}\Theta^{(2)} \dots \Theta^{(L)})<br>$$</p><p>參考圖 2 的情況，輸入我們可以寫成：</p><p>$$<br>h_{\Theta}(X) &#x3D; \phi(X\Theta^{(1)}\Theta^{(2)}) &#x3D;<br>\phi \left(<br>\begin{bmatrix}<br>x_{1, 1} &amp; x_{1, 2} \\<br>x_{2, 1} &amp; x_{2, 2}<br>\end{bmatrix}<br>\left[ \begin{matrix}<br>\Theta_{1, 1}^{(1)} &amp; \Theta_{1, 2}^{(1)} &amp; \Theta_{1, 3}^{(1)} &amp; \Theta_{1, 4}^{(1)} \\<br>\Theta_{2, 1}^{(1)} &amp; \Theta_{2, 2}^{(1)} &amp; \Theta_{2, 3}^{(1)} &amp; \Theta_{2, 4}^{(1)}<br>\end{matrix} \right]<br>\left[ \begin{matrix}<br>\Theta_{1, 1}^{(2)} &amp; \Theta_{1, 2}^{(2)} &amp; \Theta_{1, 3}^{(2)} \\<br>\Theta_{2, 1}^{(2)} &amp; \Theta_{2, 2}^{(2)} &amp; \Theta_{2, 3}^{(2)} \\<br>\Theta_{3, 1}^{(2)} &amp; \Theta_{3, 2}^{(2)} &amp; \Theta_{3, 3}^{(2)} \\<br>\Theta_{4, 1}^{(2)} &amp; \Theta_{4, 2}^{(2)} &amp; \Theta_{4, 3}^{(2)}<br>\end{matrix} \right]<br>\right)<br>$$</p><h1 id="反向傳播演算法"><a href="#反向傳播演算法" class="headerlink" title="反向傳播演算法"></a>反向傳播演算法</h1><p>對於神經網路來說，反向傳播算法（back propagation algorithm）才是訓練的重點，<br>具體來說，我們的訓練的過程為：</p><ol><li>準備輸入的值 $X$ 與訓練的標籤 $Y$</li><li>隨機初始化各權重 $\Theta$，通常在 $(0, 1)$ 區間中</li><li>使用前向傳播演算法求得 $h_{\Theta}(X)$</li><li>使用反向傳播演算法更新 $\Theta$</li><li>重複 4~5 步，直到神經網路訓練結束</li><li>使用 $h_{\Theta}(X)$ 預測值（這相當於做一次第 4 步的前向傳播算法）</li></ol><p>如果我們使用 <a href="https://en.wikipedia.org/wiki/Mean_squared_error">均方誤差（Mean Squared Error, MSE）</a> 成本函數：</p><p>$$<br>Cost(\theta) &#x3D; \frac{1}{2m} \sum\limits_{i&#x3D;1}^m (y^{(i)} - \hat{y}^{(i)})^{2}<br>$$</p><div class="note info">            <p>習慣上，我們會多乘一個 $\frac{1}{2}$ 來消去微分後的項</p>          </div><p>我們重寫一次，當輸入批次共 $m$ 筆資料、每筆資料都有 $n$ 個特徵：</p><p>$$<br>X &#x3D;<br>\left[ \begin{matrix}<br>(\boldsymbol{x}^{(1)})^{T} \\<br>(\boldsymbol{x}^{(2)})^{T} \\<br>\vdots               \\<br>(\boldsymbol{x}^{(m)})^{T}<br>\end{matrix} \right]<br>&#x3D;<br>\left[ \begin{matrix}<br>x_{1}^{(1)} &amp; x_{2}^{(1)} &amp; \dots &amp; x_{n}^{(1)} \\<br>x_{1}^{(2)} &amp; x_{2}^{(2)} &amp; \dots &amp; x_{n}^{(2)} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>x_{1}^{(m)} &amp; x_{2}^{(m)} &amp; \dots  &amp; x_{n}^{(m)}<br>\end{matrix} \right]<br>$$</p><p>對應的標籤為 $m$ 筆資料、每筆資料都有 $p$ 個特徵（最後一層神經元數量也會為 $p$）：</p><p>$$<br>Y &#x3D;<br>\left[ \begin{matrix}<br>(\boldsymbol{y}^{(1)})^{T} \\<br>(\boldsymbol{y}^{(2)})^{T} \\<br>\vdots               \\<br>(\boldsymbol{y}^{(m)})^{T}<br>\end{matrix} \right]<br>&#x3D;<br>\left[ \begin{matrix}<br>y_{1}^{(1)} &amp; y_{2}^{(1)} &amp; \dots &amp; y_{p}^{(1)} \\<br>y_{1}^{(2)} &amp; y_{2}^{(2)} &amp; \dots &amp; y_{p}^{(2)} \\<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\<br>y_{1}^{(m)} &amp; y_{2}^{(m)} &amp; \dots  &amp; y_{p}^{(m)}<br>\end{matrix} \right]<br>$$</p><p>則我們可以將成本函數寫完整：</p><p>$$<br>Cost(\Theta)<br>&#x3D; \frac{1}{2m} \sum\limits_{i&#x3D;1}^m (Y - \hat{Y})^{2}<br>&#x3D; \frac{1}{2m} \sum\limits_{i&#x3D;1}^m (Y - h_{\Theta}(X))^{2}<br>$$</p><p>$$<br>&#x3D; \frac{1}{2m} \sum\limits_{i&#x3D;1}^m<br>(\left[y_{j}^{(i)}\right] - \left[ h_{\Theta}(X)^{(i)}_{j} \right]  )^{2}<br>$$</p><p>我們關注的是，當權重 $\Theta$ 改變時，成本 $Cost(\Theta)$ 的變化，<br>假設我們激活函數為 Sigmoid 函數 $\phi(z) &#x3D; \frac{1}{1 + e ^{-z}}$</p><p>接下來，我們要處理每一層的誤差。</p><h2 id="Sigmoid-函數微分"><a href="#Sigmoid-函數微分" class="headerlink" title="Sigmoid 函數微分"></a>Sigmoid 函數微分</h2><p>在開始之前，我們先處理激活函數的微分，這個部分在後面會使用到。</p><p>$$<br>\phi(z) &#x3D; \frac{1}{1 + e ^{-z}}<br>$$</p><p>對 $z$ 偏微分有：</p><p>$$<br>\frac{\partial \phi(z)}{\partial z}<br> &#x3D; \frac{\partial}{\partial z} \left( \frac{1}{1 + e ^{-z}} \right)<br> &#x3D; \frac{\partial (1 + e ^{-z})^{-1}}{\partial (1 + e ^{-z})} \frac{\partial (1 + e ^{-z})}{\partial z}<br> &#x3D; \left[ -(1 + e ^{-z})^{-2} \right] \left[ -e^{-z} \right]<br>$$<br>$$<br> &#x3D; \left[ (1 + e ^{-z})^{-1} \right] \left[ (1 + e ^{-z})^{-1}e^{-z} \right]<br> &#x3D; \phi(z) \left( \frac{e^{-z}}{1 + e ^{-z}} + \frac{1}{1 + e ^{-z}} - \frac{1}{1 + e ^{-z}} \right)<br>$$<br>$$<br> &#x3D; \phi(z) \left( \frac{1 + e^{-z}}{1 + e ^{-z}} - \phi(z) \right)<br> &#x3D; \phi(z) \left( 1 - \phi(z) \right)<br>$$</p><h2 id="輸出層的誤差"><a href="#輸出層的誤差" class="headerlink" title="輸出層的誤差"></a>輸出層的誤差</h2><p>在接下去之前，我們把符號定義清楚，先前的討論中，我們得到結論是：<br>$$<br>h_{\Theta}(X) &#x3D; \phi(X\Theta^{(1)}\Theta^{(2)} \dots \Theta^{(L)})<br>$$</p><p><img src="https://i.imgur.com/zOAQra2.png" alt="圖 3、輸出層的誤差"></p><p>如果僅考慮一筆資料的情況，即 $ X &#x3D; (\boldsymbol{x}^{(1)})^{T}$<br>參考圖 3 所示，接著定義：<br>$$<br>a^{(1)} &#x3D; X\Theta^{(1)} &#x3D; (\boldsymbol{x}^{(1)})^{T}\Theta^{(1)} \\<br>a^{(2)} &#x3D; a^{(1)}\Theta^{(2)} \\<br>\vdots \\<br>a^{(L)} &#x3D; a^{(L-1)}\Theta^{(L)}<br>$$</p><p>不難發現，第 $l$ 層的第 $k$ 個神經元的輸出為 $a_{k}^{(l)}$<br>另外總輸出為 $h_{\Theta}(X) &#x3D; \phi(a^{(L)})$<br>同理，第 $k$ 個神經元的輸出為 $\phi(a_{k}^{(L)})$ </p><p>我們觀察第 $L-1$ 層的第 $i$ 個神經元連接到第 $L$ 層第 $j$ 個神經元的權重為 $\Theta_{ij}^{(L)}$<br>所以我們對 $Cost(\Theta)$ 的特定神經元做偏微分有：</p><p>$$<br>\frac{\partial Cost(\Theta) }{\partial\Theta_{ij}^{(L)}}<br> &#x3D; \frac{1}{2}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2} }{\partial \Theta_{ij}^{(L)}}<br>$$<br>$$<br> &#x3D; \frac{1}{2}<br> \frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2} }{\partial y_{j} - \phi(a_{j}^{(L)})}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))}{\partial \Theta_{ij}^{(L)}}<br>$$<br>$$<br>&#x3D; \frac{1}{2}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2} }{\partial y_{j} - \phi(a_{j}^{(L)})}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))}{\partial \phi(a_{j}^{(L)})}<br>\frac{\partial \phi(a_{j}^{(L)})}{\partial \Theta_{ij}^{(L)}}<br>$$<br>$$<br>&#x3D;<br>\frac{1}{2}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2}}{\partial (y_{j} - \phi(a_{j}^{(L)}))}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))}{\partial \phi(a_{j}^{(L)})}<br>\frac{\partial \phi(a_{j}^{(L)})}{\partial a_{j}^{(L)}}<br>\frac{\partial a_{j}^{(L)}}{\partial \Theta_{ij}^{(L)}}<br>$$</p><p>然後我們逐項討論，第一乘項是：</p><p>$$<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2}}{\partial (y_{j} - \phi(a_{j}^{(L)}))} &#x3D; 2(y_{j} - \phi(a_{j}^{(L)}))<br>$$</p><p>$$<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))}{\partial \phi(a_{j}^{(L)})} &#x3D; -1<br>$$</p><p>使用 Sigmoid 偏微分的結果：</p><p>$$<br>\frac{\partial \phi(a_{j}^{(L)})}{\partial a_{j}^{(L)}} &#x3D; \phi(a_{j}^{(L)}) \left( 1 - \phi(a_{j}^{(L)}) \right)<br>$$</p><p>然後根據先前連接的定義，即前一層第 $k$ 個（任意的）神經元的輸出，<br>經過權重 $\Theta_{kj}^{(L)}$ 都可以連到輸出層第 $j$ 個神經元：</p><p>$$<br>\frac{\partial a_{j}^{(L)}}{\partial \Theta_{ij}^{(L)}} &#x3D;<br>\frac{\partial}{\partial \Theta_{ij}^{(L)}} \left( \sum\limits_{k} \phi(a_{k}^{(L-1)})\Theta_{kj}^{(L)} \right) &#x3D;<br>\phi(a_{i}^{(L-1)})<br>$$</p><div class="note info">            <p>當 $k &#x3D; i$ 時，那條權重才會影響，微分後才有項被保留</p>          </div><p>則輸出層的誤差為：</p><p>$$<br>\frac{\partial Cost(\Theta) }{\partial\Theta_{ij}^{(L)}}<br>&#x3D; \frac{1}{2} \left[ 2(y_{j} - \phi(a_{j}^{(L)})) (-1) \phi(a_{j}^{(L)}) \left(1 - \phi(a_{j}^{(L)}) \right) \phi(a_{i}^{(L-1)}) \right]<br>$$<br>$$<br>&#x3D; (y_{j} - \phi(a_{j}^{(L)})) (-1) \phi(a_{j}^{(L)}) \left(1 - \phi(a_{j}^{(L)}) \right) \phi(a_{i}^{(L-1)})<br>$$<br>$$<br>&#x3D; (\phi(a_{j}^{(L)}) - y_{j}) \phi(a_{j}^{(L)}) \left(1 - \phi(a_{j}^{(L)}) \right) \phi(a_{i}^{(L-1)})<br>$$</p><p>然後我們定義最後一層（即第 $L$ 層）第 $j$ 個神經元的的誤差為：</p><p>$$<br>\delta_{j}^{(L)} &#x3D;<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2}}{\partial (y_{j} - \phi(a_{j}^{(L)}))}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))}{\partial \phi(a_{j}^{(L)})}<br>\frac{\partial \phi(a_{j}^{(L)})}{\partial a_{j}^{(L)}}<br>$$<br>$$<br> &#x3D; (\phi(a_{j}^{(L)}) - y_{j}) \phi(a_{j}^{(L)}) \left(1 - \phi(a_{j}^{(L)}) \right)<br>$$</p><p>所以可以表示為：</p><p>$$<br>\frac{\partial Cost(\Theta) }{\partial\Theta_{ij}^{(L)}} &#x3D; \delta_{j}^{(L)} \phi(a_{i}^{(L-1)})<br>$$</p><h2 id="隱藏層的誤差"><a href="#隱藏層的誤差" class="headerlink" title="隱藏層的誤差"></a>隱藏層的誤差</h2><p>有了輸出層的經驗，隱藏層便不會太過困難。</p><p><img src="https://i.imgur.com/wPg7VqS.png" alt="圖 4、隱藏層的誤差"></p><p>觀察圖 4 的內容，我們接下來要討論倒數第 2 層（即 $L-1$ 層）的誤差，<br>很顯然地，一樣是對成本函數做偏微分。</p><p>不難發現，最後一層所有的誤差都傳遞到了隱藏層中，<br>可以視作多變數函數的全微分，所以有：</p><p>$$<br>\frac{\partial Cost(\Theta) }{\partial\Theta_{st}^{(L-1)}}<br>&#x3D;<br>\frac{1}{2} \sum\limits_{j} \left[<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2}}{\partial (y_{j} - \phi(a_{j}^{(L)}))}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))}{\partial \phi(a_{j}^{(L)})}<br>\frac{\partial \phi(a_{j}^{(L)})}{\partial a_{j}^{(L)}}<br>\right]<br>\frac{\partial a_{j}^{(L)}}{\partial\Theta_{st}^{(L-1)}}<br>$$</p><p>直至這一步都是幾乎一樣的，接下來拆開最後一項。</p><p>$$<br>\frac{\partial Cost(\Theta) }{\partial\Theta_{st}^{(L-1)}}<br>&#x3D;<br>\frac{1}{2} \sum\limits_{j} \left[<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2}}{\partial (y_{j} - \phi(a_{j}^{(L)}))}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))}{\partial \phi(a_{j}^{(L)})}<br>\frac{\partial \phi(a_{j}^{(L)})}{\partial a_{j}^{(L)}}<br>\right]<br>\frac{\partial a_{j}^{(L)}}{\partial\Theta_{st}^{(L-1)}}<br>$$<br>$$<br>&#x3D;<br>\frac{1}{2} \sum\limits_{j} \left[<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))^{2}}{\partial (y_{j} - \phi(a_{j}^{(L)}))}<br>\frac{\partial (y_{j} - \phi(a_{j}^{(L)}))}{\partial \phi(a_{j}^{(L)})}<br>\frac{\partial \phi(a_{j}^{(L)})}{\partial a_{j}^{(L)}}<br>\right]<br>\frac{\partial \sum\limits_{k} \left( \phi(a_{k}^{(L-1)}) \Theta_{kj}^{(L)} \right)}{\partial a_{i}^{(L-1)}}<br>\frac{\partial a_{i}^{(L-1)}}{\partial\Theta_{st}^{(L-1)}}<br>$$<br>$$<br>&#x3D;<br>\frac{1}{2} \sum\limits_{j} \delta_{j}^{(L)}<br>\frac{\partial \sum\limits_{k} \left( \phi(a_{k}^{(L-1)}) \Theta_{kj}^{(L)} \right)}{\partial a_{i}^{(L-1)}}<br>\frac{\partial a_{i}^{(L-1)}}{\partial\Theta_{st}^{(L-1)}}<br>$$</p><p>逐項討論，這裡用了激活函數的結果，<br>注意偏微分，當 $k \neq i$ 的項都被視為常數：</p><p>$$<br>\frac{\partial \sum\limits_{k} \left( \phi(a_{k}^{(L-1)}) \Theta_{kj}^{(L)} \right)}{\partial a_{i}^{(L-1)}}<br>&#x3D; \frac{\partial \phi(a_{i}^{(L-1)}) \Theta_{ij}^{(L)}}{\partial a_{i}^{(L-1)}}<br>$$<br>$$<br>&#x3D; \frac{\partial \phi(a_{i}^{(L-1)})}{\partial a_{i}^{(L-1)}} \Theta_{ij}^{(L)} + \phi(a_{i}^{(L-1)}) \frac{\partial \Theta_{ij}^{(L)}}{\partial a_{i}^{(L-1)}}<br>&#x3D; \Theta_{ij}^{(L)} \phi(a_{i}^{(L-1)}) \left( 1 - \phi(a_{i}^{(L-1)})\right)<br>$$</p><p>最後一項，跟輸出層的時候一樣（觀察圖 3 可以得到 $t &#x3D; i$）<br>所以只有 $k &#x3D; s$ 的時候才有值：</p><p>$$<br>\frac{\partial a_{i}^{(L-1)}}{\partial\Theta_{st}^{(L-1)}} &#x3D;<br>\frac{\partial}{\partial \Theta_{st}^{(L-1)}} \left( \sum\limits_{k} \phi(a_{k}^{(L-2)})\Theta_{ki}^{(L-1)} \right) &#x3D;<br>\frac{\partial}{\partial \Theta_{st}^{(L-1)}} \left( \sum\limits_{k} \phi(a_{k}^{(L-2)})\Theta_{kt}^{(L-1)} \right) &#x3D;<br>\phi(a_{s}^{(L-2)})<br>$$</p><p>同樣地，我們做個總整理：</p><p>$$<br>\frac{\partial Cost(\Theta) }{\partial\Theta_{st}^{(L-1)}}<br>&#x3D;<br>\frac{1}{2} \sum\limits_{j} \delta_{j}^{(L)}<br>\frac{\partial \sum\limits_{k} \left( \phi(a_{k}^{(L-1)}) \Theta_{kj}^{(L)} \right)}{\partial a_{i}^{(L-1)}}<br>\frac{\partial a_{i}^{(L-1)}}{\partial\Theta_{st}^{(L-1)}}<br>$$<br>$$<br>&#x3D;<br>\frac{1}{2} \sum\limits_{j} \delta_{j}^{(L)}<br>\Theta_{ij}^{(L)} \phi(a_{i}^{(L-1)}) \left( 1 - \phi(a_{i}^{(L-1)}) \right) \phi(a_{s}^{(L-2)})<br>$$</p><p>重新定義第 $L-1$ 層第 $t &#x3D; i$ 個神經元的的誤差為：</p><p>$$<br>\delta_{t}^{(L-1)} &#x3D; \left[<br>\left( \sum\limits_{j} \delta_{j}^{(L)} \Theta_{ij}^{(L)} \right)<br>\phi(a_{i}^{(L-1)}) \left( 1 - \phi(a_{i}^{(L-1)}) \right)<br>\right]<br>$$</p><p>所以可以表示為：</p><p>$$<br>\frac{\partial Cost(\Theta) }{\partial\Theta_{st}^{(L-1)}} &#x3D; \frac{1}{2} \delta_{t}^{(L-1)} \phi(a_{s}^{(L-2)})<br>$$</p><p>我們可以對任意權重 $\Theta_{ab}^{(c)}$ 同理推論出：</p><p>$$<br>\frac{\partial Cost(\Theta) }{\partial\Theta_{ab}^{(c)}} &#x3D; \frac{1}{2} \delta_{b}^{(c)} \phi(a_{a}^{(c-1)})<br>$$</p><div class="note info">            <p>從這裡可以發現 $\delta$ 是可以重複利用的，而且誤差是由最後一層，層層向前傳遞。</p>          </div>]]></content>
      
      
      <categories>
          
          <category> 人工智慧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊與羊的草原 04</title>
      <link href="//sheeps-04/"/>
      <url>//sheeps-04/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password incorrect!" data-whm="Hash wrong!">  <script id="hbeData" type="hbeData" data-hmacdigest="befc46fdaa4dc69db6ccce0f952f0ff7ff9f0d787f3615ccb83552ec41f6ac44">b86d4129f36541f97caeda0e7cd510caa52cd3aa6073614a64850db0d95da2ad022c9f89eb3a18c23562992c5d6fd33bd1fc648953161ace0e30ed893e00caaf87e69c3bc86a16f9ee53ae607859d02db9208ffd00709809afd44e6a10231aa75e5a6328d08c2625621560a2645fe25f017e9126bece7258a4b97cd9eee3ad4df409934a9658be84064281af4c012a4e517483a498aa8571876e1ec553d867ea25283b04a4010e355245a0260d4fac1f0ba11bf63c37bef269d08f973f660bb5bc65e83fc5e40359148c2fe78b3845735c4d28b221582822a0c4763c9b29c1fc4767474e213e2e4f5d8fd57503ea75d22c899ae15846a214dd6d8972b022b50d934fe513e25344269676010eeef23fe436827ae41b3aaf05190d309d1a6a3eb1329ad7afef1afb34fd2d6321765c4413252797974f166a281218a6e6adc0dcaa0161e3b5399eeda2620b3b4c681c3d2e1342fa2ea9d0d8e4dc1d63fb304c775aa6f8e178a506fd7a02eb41cc814aad5f6c50b66fad8aa9ffffad0c47ec0bee485176471ce644512534d20773ad3c2be25b2134b8370a4d825cfaab2b414973effbaddbefa0c97825fba574ff34c5a1a6abf744b44bafdb8198ccea232e569a24e357a917a7458f0a6f047248e09b83f33bd620943659ff29593a378ff4fc8cd242d65220df6f56bfca79b61c48818ff250948190ac48100163c6d1eba93195da26652c6b5dfcb14a14e42466df782cf71c534839cc4b90a67ccd63a2f549817564949f233082382e5e80b7950995cc18c25682b1af9c2aeef36a40fb707eec2ff3f46a53481f3c655347d6686f8b018559f6d20e3d0b56523ca2cb730787dfd65b44d202952f79066b97389d5e622aee901f9abaceba806c9200eba899e9c6df9ac0367c13362e6bcc0055e1f1577851939cf10691c244082a92b1aeba10de884d0608a29215089b7738e5043a86c8dcc0fb3907aa5314296d9e4c6a36e095d88fda09111be8389c6fdb110387622a9162a1e5a24d05207d783697d718dc569d186e1518ec27bcd648b49c6a61e0427a1b54bd51a8cf010e40461e245cf940b8b46d95b0fbdd4f7ea1e4793e53f70d1e5e7556b1553f5be131230cc76bb719e3c544c9596c1892f58f856e68e7ea554ec86029cc83238f5df1d867a302523cbcdf64254ff5bde58a35b43dfde5f77ed0fe7f2796d7e415fb82b493678f5d23a3a1c2b50f339c8eb204fbfc1eff3e78108bc83d757122bc5e51a60d71223538ea8e5c18d0421e3f4ba33ecd1a1c9b43ad7a254deaf3349ff4f823c96a4922bab0caaf0e658c55de882efe8a5971515f9da99290e4d2059ab44d1926ba57b73d6c7233388b0c5edba9d9889c7e5ea5e6ac3d8358c4a7744129da011fc6dbceccf2957ad6b27d191209bc795a9f70a87625745a1e671821902c51c3cd3695ec723f4b7bd0e5e95b53861fe3c4298cf551d3eb325d3fed13a3a5101c4075d313cff55b4fe3fd9d127b2f2f39b8bc343498746d2c403b0ed92bc87ad0016fd8d84dbf304e49d26f04cee6787351a44c3fcfafefffae87d7cf5477fdff55d68d5cdf17e409e238c90ba3159e7bfa23b469d1efc02e551ef4ea2bc1649d9f86b4dd633b7c3be0fab426a39b34686b0a00757bb3d70e17aeb06cc74130b549a2a117ef563ccf2290346d92c4b1759d7df10c22ba52b85cf78f1ea9dd28e8752e8510e4f6bd8c3a095298ad4beabddf4333de59f975ba18f86c75f74dc1210245b5b9534536be983e906568f7b6867455184161a69c4fa9ea8fa2fc5b4567d5db4c3dfd3472e3ea9e3221c78eb6e59848c039f8da3cffcbd6d39b0d1f0a9065eee7f067b9b8d86bd0660cdf8b84a271865361b8a68fe8b5d1c33970dc4a1006eb951661ddbf6dc49b3ea6061639c400621d621b44957b72abcf46e1316bdcaf91464f4fb8305b042e34a72e77bf8132b0c1ba2199c3f04a677abacb89eb40d91bc8b8748bd8272d34b9b19f485de81e359c116b43588d5720a92c640ba6dca32727cdb4623633f9e074e0b09a2d76ee135a62427360da31986945b8fcf9359ad07640c48fd77a37376f664280c48ac8825c3bbe50cf34089f2564544969913b66bf9c9b9780eb1a6161bb6ccd7639cdc02a800146844a0a5a2e052650f69d10904d262d4eabb6190fbf0cc5d6733ed5cbf2a96c5670151854d59615125305a36f57b8f702e9114fd3a2e5ce359568c8fe8fbae8079755adfa01bb23f3b971e82d5e435b9a4c32fa27277bd9c1153feb5953c26a50e45aba4c23cecc98e00b28de12ee17bf8e1e6c0edb361f16c59f5aed37ab19372ed894ac292a547d750043f84424274f2dbae30fec5d8d27a159be66b5fcacc6623ed196d6aba1440268926a1a5691a08f67a587317e8240cf70c9de7c05fb8ea2767fe2bb5e9792ded2fdc439eb640b16aaa17db534be2b6e53b1f65a3132e7273d61abfb6d67e3afdc780883226ab0459adbbba747865f87305643d8ea52f72b8db20b27b6cb87d754d9e0de4508cf45501f4e601f7ed2be9d6f5d7295721f72067899af2a072c5c457c364558738c80c038b2e66e911365f77313d9b5c53de01a6a46333532050f2d000924e7e5a69a591d7cebdbe5cee279cf11020513cdd3b021ccd29b87338aa655da6216deed38995b072decc8e385aa012eb58cfda53aedaaed64cdd59e7fee446b70bccd6d58fa3b7d648ff031accf588df5e3a4bc78f1c29cf0963da48fc8a3db9326cafb15af0fadc7eae1e999da667e47966ddd3213ff01abf9f7637f36c3fb8912ab685fb14bf52b2bba6ba67324f77b75f71662a973483e998bff939457698847d315434bdd68c5e20b81e774902103bf7ce47a19ffc7ae843b3f7d2cf76d4e045aa585789945535ce614921e275e7f968804a3f42782f0de940a34def02a2360158d231ba44617673df86ccb7c7985811d1356f490fde907cf5f901fef84919030d41d8f371cf88c0b577d616a4e21a64c3bf3a8511342ac098a2ad18d4525471cfea0c21541338faf7a0ff8c752368403bc360616a63613f41eee37b05dc9235a30fde9e0afb446dcdb60bfc10b374b8f251ee47b295694ba9964c1afc2a7c4d6c9a38c6ce35e51179c9b192efeb4d06d500faf7c22843ba18661be4400c6ee395dc87eec64d8b0400c5b26f6e6659eebe905b25b04fc9da6383a2f0aa640ca9abf427bb8b1654ed3e23b5d269978c5e7e3e09519b08d02baddb3e1a1cf753aeef259c217115c25e643493a6e2869e30d1a7a6d2a46253563b61323dee9dc1a9417b1891d302bcd55c5ac026de744c13fa684e6abf66ce93ea0c6895bf335ea429e2ee559bf344fdfbb2fa750e101229c9478c374e9112c95200998c500c3a5c5e32fa14a30cec5c11a48ca6ca080bf294dbab4d760a351db16889f0ca43c27f4ed113552afc51f7fab9439c2035bc7852405c0f88e0091dc3e1feb061afba3b2a705e2624cc7d9b520315d97c166ac2cc6f16d52f5ea8373e8705863b21395cb10e05ab4175eae23fba6afa17d3db651a5f24b649f82d0a251d2d6bdedd7a546870dc6c86dac48abb270d038dc5470ffad3fc7d2a6965fe7fa6c8dd743a9d0a17b636a262cdee50d06b95aa4f0cb499048b7bb674b2bfa180c74d7b71dd32869e4e84cfed7395614fe544981e9bb1507746308787e3009fad6b8a3ebd79337bf93a5273b066c3871ef80bcc1e713cc1279f81851177e72077f3b0a019d7510f0b9e60350b4242c84d2752f9b21840ed5d19684be31c3f82820fedb73d4c4873794de3a3f79d28228190366bbe772676f79fc5ac8bb4b541c480712f2704963e3041b9ee159adaefedd5727105e22e0d2f53238c94b55ea8dcb7d822cff4c21f4a54b193a99e1a53f412151148b821317389c19fabbdd317c9349956efb67f72cb7d16a45c1270c01ba85fa91ea98c4dac875394bea6d5c0b8becc96c78c605662495381f5c27a4902c18965b930958ab8b6c6e15e0f87c80a9351a6987e52c2cd5b3bc3817e080a9379cd5266905e665724b4c006a69ac7f03f1f75855ef8e8a581cc344dd1bb1ec5294234e09f78b6553ad0ac2b7e60adbf8849a7871a7d7ce0197c7035592dd8c2550bf06c919eb1e8e571246c94673a7f228dd2d0801b9042dcbf6ffde5c9dd2dbbdb9b44288b303e81883f58129e45b83ef0ca1d6db459cacff1b72189f534c648d4adb679958972d3e93630d2f59bcf2ff3c6ccac63acc6fbccd790014f626b10b4e81be7b453c7e92f8d7712e29e844a0f3ea438512689e01922bf61a9a828a03b05f4a595a25fe12615286dba9269fc737b4a1351918c75f7ffaaed686c4aa16ee9ad0ad24992b48e7a4b2f4a8744e7a5ac640524a3505edef2316b2045148bc6f2ad3088a6ccc0c1bdf99199711ff542b30404c98abfe5102e853d9ab7744dfaa58f0b043eb5049bfba9221a074eabf2ec78f6bd2b9214d77be7d9e2ede3f4622719b1954ed68c4f53e8b5144bbed5a098a900f00280e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">🔒 Encrypted Article      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass" placeholder="Password">    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 獨立遊戲製作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊與羊的草原 03</title>
      <link href="//sheeps-03/"/>
      <url>//sheeps-03/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password incorrect!" data-whm="Hash wrong!">  <script id="hbeData" type="hbeData" data-hmacdigest="48b4ba32a7222891e5c4bce537c2f3ab7b7476ecbdb147b55bd0ec24c8831525">b86d4129f36541f97caeda0e7cd510caa52cd3aa6073614a64850db0d95da2ad022c9f89eb3a18c23562992c5d6fd33bd1fc648953161ace0e30ed893e00caaf87e69c3bc86a16f9ee53ae607859d02db9208ffd00709809afd44e6a10231aa75e5a6328d08c2625621560a2645fe25f017e9126bece7258a4b97cd9eee3ad4df409934a9658be84064281af4c012a4e517483a498aa8571876e1ec553d867ea25283b04a4010e355245a0260d4fac1f0ba11bf63c37bef269d08f973f660bb5bc65e83fc5e40359148c2fe78b3845735c4d28b221582822a0c4763c9b29c1fc4767474e213e2e4f5d8fd57503ea75d22c899ae15846a214dd6d8972b022b50d57bc560f804776995472d330e6eceed7b40a34d4e3b9d1e686213c4b709c4f1e40c18e8d6e0848e1de721ad6ff7b68b7ca18bc78a060a86bf7bbf612f68ec9cf48acef18efee4453df8ccb3bcc858e3ebfde3b86a338efe5e1a83b6839ce61b6b5726ec329a6173338d06e5f8374b2d6a58d3da03bbb6a265cc4f8beb8835d44d52d774ca8ce9bfc01d2978171dae9f2caca32931c203a275074540d8108cacd7ba139b8832ea7d75bb1e72fc37c141811f20b07535875adad4356947f76063cba98ff1f54f734afe7f4f6b83177d739dfc8f788144eed8346259a7ad74783d62a7f0c5700eb0bd645e21f2b05c8dc81bf9528df99600a2db6074225788e3fb5f071fd7e40dc79a1b348acf0b2488474d2f75aef19bf555322b16c7774cc524eada1fd451ba2793c3d76d1803afe0f4542a57ecba95a6f63267be2e289a6d59e7c775250152048cf4fa6f8abdda8e544bc07e644496eb100a43b0a8257b8fc5f2a4814a47c58476ed2d7e1d00954cff25ab08d6e724c78b7e23831de8083156e0f7ae031fcb3fece06a18758fa324c9ccb14e9e1c8c6455486121cddb26ec570a101f6ca4d93107ab6476ec0bccfd31488771b5d91e66c4c098f331cdc6c6ed55e379326909b95c227651bdb38632e134b952deb4e9ef6673eb383989b2c4e2202978bf78ad95c0aeb4ad666236655b494cbacbc7167804348d66867ac531537c9d1e9b9f2ff9f71847cead1e318b3b90ded0302384b514bd64f85f60ea896eb76099c7d0e8273f588b214e574400ea63925873dfd694b79c33ea7c14969a7c085a49e35e100d8478f18e523a84e21d584ca52f69d160444c6d16c6a75436ad35512808a972be003dbc78ee89521b8a55cd51596fc64bd9a07f0f22596e4a752e42b6adbbf3ba5689a119ee01857defce4420faac1990060284c582d823758a4881cdc81b6920d4fe621612843ba6819aac96d91a6e1065e49af75a4ad22447f545b3e018c67fa594a1eee8c40072c7e18631549cee1557936b9990b27a53e3950fc38119f0c2394939c53df656ecc976c6e7675f50f9b1efdf1a0c47c8648fe31c851d01707fcd359a438e6490cd5d98aca710624bb1c22f6ef69f43b1ef58383d4c46bef01172a4e1fc4fd6efccc7f3ddcc8e1ca081d6cc13ffc1e740484b0ce3731ae08c645ad0dd393c6e8940dace2b07340d3aebd1e7ccdddac40b73efdc6615fdcf005753d2877c2c6c9cd887394fbede73b70ff0160ec68f3be023c4d6c5c2b3b8c448fa4b60cda5462a9e167f60ec0e40d3bf544d1f735d07ea4ce70be25b9fffa0da44117fddda591dcbde8c8795cc3fdbf90a7173c52c7fe0f3d3d6e229bf429682590cfdfb5d6b416214e2c73febc643edf6d1b8222790f04ebb3ab2374f557d345e26dff5bd310a04fe39de89616eeda2dd5b69a91b833f6992cded88807a14538cd214bc0ae4015c216c323f7d379b6eca5884f23cd53f82bdcf2fd9e2d560bf596be79c6a6e47a8f01906fa20d1c02be4f62657a5990c00ed4d6e442ada04ee9aa32c89f55281ab1f3c53d5bfdf21e9e2efcd52d3ace6e1a20ca6a8d127863db27f1f1d8b2d8939838f494f79dabe0a74780f971d402a2062be022a7bb0cb7431b4996c50b5caf01924471a39b653521858a57938bc5c29544d434aa214b2b4b4d4f19cb7dc95b190369d4f5ebe58cbe8eb5967b8263cd3186ac428e06783a22ee6315b4182f82ef10d3d7667848fe8d73964ac26ef3ec7ffd345a26a98a4d1e360e59f36a6fba5e6cb04ff5837a728f2ba9665ba6179f086f66ddfa4e2a1ed3932d3d468e0d70970a68ae7a752c53c50605b7b88520e2370bee4db8179f4884e500c26ea76428c181754213f13f34af27e3ab96eaca1a14034ef30738f1e2f391d019d2c3eb59c19ef3c7421f22b7c4b8132f900907083c582a09990e27ccda347b42eb844ad69795fdc4d5045b64ce4d526cbbd368b6111de9d30ebc1bd5cf7d2bb2de3acae5bed9d2d0efbaf319a72974fd75eb5492d97de1676881be2e630a0eada9f61c0468f752749a79a8781d55ddedba2a9432f3af77b89c7ea6dea6f99cad1ae2b4df01b1578a7a375078e1ba6bd42b9f47f86e6d0b2fd6c8519346d72c86477a310ead161477dbf93f82d65026dbfc507b94a3e2816168f0bf0f27e66421847f77e09af0dd152da04ee713fc503beedb956b2b5aa234a31705e162c0a4be5dcf1821911afa8e8c4a1f6031b8b231ac14c9df9b1e7dc2c371a6835c4dc7d55eff476326a5e2f7abb7369ef506866dda4faa360a51fb1b49957a032a5e57452d04cb5b05cb799d4e77061d01a392343783bbb533de48ec1d02e2d3f7736222584d2cb1b93944b09aad01fe8baa55ff97cb716fbd000211396ada922fb196beef11d3b8f523c8682d9ebf8913bb8f060cca69c2f2a3cb25c57240d0871fb7a12c64e1875e5caa60b77662095c6bf51b53167b0ed6b8354347480b6eb2edb8849e97c4db36a9c09ba50d2295f3cc55aeb4fb79e9c75ca16c20cd64822468f3542739f51351f9f5bca73b949d3ff72f52257a390d85b63bc0e578261600b7c1e8330e5ea2035eb06bd20b90e23c59dd3ed3d635b1142666f3f49fddea641ccd39f9eaf845be2c654b1d010367cfe578c404596cef32f53ba10ebb917af976270d73f42664cb1c24fc3166dd63de36ee0132ecee71572a5afe859cb35b0cc1c6c295536f95b3db9e2bfa9cebdc22b87d6d44327ab4dacbbfc4eac18202bfe2d40010b5efba8526b0476428d60ef5e7a161fdeebd1c95bde1633a7163be503761e551fc3e4de8c97ca78b4f5cdb41debbca4bbec97403c61e9bd176ffcfb3193ca1a6fb7e37bb7148c3b6189eb7fc81b86ace3d656d86d105be285bf0b578206dd6477e0c5e73a4bf1b0ef3db58311a74fc6ab6a81cc0290ff1c0406caa3c5d1ba7493c902bb266ef0b5d1f10d3f2698a61d075ab16c4fd76186c9c04c62e2b0db0d24e3074a6f8842f5e4849a817258c0b27400af60d7d83f913b9bfd8de6e7fae56266dba2c9049863fd10d0cfb0f79bb32a8e1fbc4b38079c0436addaf90214f3502c0e6c3c06bde60a08e30ffaf13751cb9e0a2982392c6c84fbdf6b3ca849ad88d60ab19b51eafea57c69967b246952a51e224458c110f4754f9bbcfd2c2d49e4d004b28fd065932133f0ba5621611158943441237ff5b4b1b2d54025a77f1bcc59ec6a469d4b4c7fa16cdcadee494bfe7f45854836ac48e01cd63992e7270ee12ac0e7ff5f85d98cc04eda53fa887dcb35a2d54997b3c5c81334768902e95d78b21bc378f8f934e39e196d05ce7e3f862a2932c596e279d1d59d8fd516dc3471d47ebae7c315a83754dd7a2f07f33877b10934d7002982b7886b41adda5091ac7c8b3a62af60d1713299d4039eaa074956ee49f04f5fb80f50004cc0f925750d7415a8cf1a9dc2ed0f92ba4e4f9a7564df1e578ca4b2861ed3265b5d898a812b6a468da5e8d6c27a9a9260cd589d1f00c6e427eb9e1dc4f4c8956411d18172aaefd5c1a16f78365a4918944cd92820a4483f6cc7694ef539cc4e21a9e39ce8464b5559449f9714320d6fd674dca0ad9c6119daa4155e01ebcc71aedc5231ae7262439ebd8</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">🔒 Encrypted Article      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass" placeholder="Password">    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 獨立遊戲製作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>價值迭代 Value Iteration</title>
      <link href="//value-iteration/"/>
      <url>//value-iteration/</url>
      
        <content type="html"><![CDATA[<p>這篇文章是《人工智能：一種現代的方法》及 Udacity 上的強化學習課程筆記及其他內容的整理，<br>從馬可爾夫決策過程、價值迭代、策略迭代、Q 學習，最後到深度 Q 網路的思路。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這篇文章是上一篇文章《馬可爾夫決策過程 Markov Decision Process》的續篇，<br>如果沒有基礎或想看過那篇文章，可以先去看看。</p><div class="note success">            <p>這是 DQN 的系列文章，上一篇是 <a href="/markov-decision-process/" title="馬可爾夫決策過程 Markov Decision Process">馬可爾夫決策過程 Markov Decision Process</a></p>          </div><p>上一篇文章中，我們設計好了馬可爾夫決策過程的模型，但尚未提及如何解決問題。<br>為了解決序列式決策問題，本篇將會提到一個關鍵演算法「價值迭代」。</p><p>原本是要連策略迭代一起寫，結果價值迭代寫太長，後來決定分成兩篇了……</p><h1 id="問題建模"><a href="#問題建模" class="headerlink" title="問題建模"></a>問題建模</h1><p>為了避免讀者需要在兩個文章間不同切換，我在這邊簡單寫一些建模的內容，<br>當然符號方面也會跟上一篇文章差不多，但為了方便我們繼續討論下去，我們將做一些改變：</p><ul><li>地圖尋路及簡化二十一點的 $MOVE$ 跟 $ACTION$ 映射改成 $A$ 命名（A 表示動作，即 Action）</li><li>地圖尋路及簡化二十一點的 $POINT$ 跟 $SCORE$ 函數改成 $R$ 命名（R 表示回報，即 Reward）</li></ul><p>這樣一來文章讀起來比較順暢，再繼續之前，我們先重看一次建模的定義。</p><h2 id="地圖尋路"><a href="#地圖尋路" class="headerlink" title="地圖尋路"></a>地圖尋路</h2><p>請參考圖 1，問題定義寫在下方。</p><p><img src="https://i.imgur.com/8g4n6Sv.png" alt="圖 1、基本玩具問題"></p><p>問題建模為：</p><ul><li>狀態集合，即座標集合 $S &#x3D; \{(x, y)| x \in \{1, 2, 3\}, y \in \{1, 2, 3, 4\} \}$</li><li>動作函數，即在某一座標可以執行的動作 $A: S \mapsto \{\text{up}, \text{left}, \text{right}, \text{down}\}$</li><li>轉移模型，即在某座標、執行某動作後，轉移到下個狀態的機率 $P(s_{t+1}|s_{t}, a_{t})$ 其中 $s_{t}, s_{t+1} \in S$ 且 $a_{t} \in A(s_{t})$</li><li>回報函數，每個位置的得分 $R(s) &#x3D; R(x, y)$</li></ul><p>詳細定義的部分：</p>$R(s) = R(x, y) = \left\{\begin{array}{l}+1 && \text{if } s = (4, 3) \\-1 && \text{if } s = (4, 2) \\-0.04 && \text{otherwise}\end{array}\right .$<h2 id="簡化的二十一點"><a href="#簡化的二十一點" class="headerlink" title="簡化的二十一點"></a>簡化的二十一點</h2><p>前篇中，簡化二十一點的規則如下：</p><ul><li>牌面 1、2、3、4、5 每種牌都有無限多張且抽到每一種的機率相等</li><li>牌面 1、2、3、4、5 對應點數為牌面的數字</li><li>每一回合莊家、玩家決定要不要繼續抽牌</li><li>若某回合不抽牌，接下來的回合不能繼續抽牌</li><li>若超過 10 點，則判輸</li><li>若雙方皆超過 10 點，則平手</li><li>若雙方皆小於等於 10 點，則點數大者勝</li><li>所有牌都是明牌（玩家可觀察）</li><li>莊家先抽牌</li></ul><p>我們將其建模為：</p><ul><li>狀態集合，即各種手牌 $s$ 及允許抽牌標誌 $f$ 的集合 $S &#x3D; \{s &#x3D; (c, f) | c \subseteq \{1, 2, 3, 4, 5\},  f \in \{1, 0\}\}$</li><li>動作函數，即每回合可以執行的動作 $A: S \mapsto \{\text{draw}, \text{pass}\}$</li><li>轉移模型，即抽牌後，轉移到下個狀態的機率 $P(s_{t+1}|s_{t}, a_{t})$ 其中 $s_{t}, s_{t+1} \in S$ 且 $a_{t} \in A$</li><li>回報函數，即一局遊戲的牌面數字 $R(s)$ 其中 $s \in S$</li></ul><p>詳細定義的部分：</p>$A(c, f) = \left\{\begin{array}{l}\text{draw}, \text{pass} && \text{if } f = 1 \text{ and } \sum\limits_{x \in c}x \leq 10 \\\text{pass} && \text{if }  f = 0 \text{ or } \sum\limits_{x \in c}x > 10 \\\end{array}\right .$<br/>$R(s) = R(c, f) = \left\{\begin{array}{l}\sum\limits_{x \in c}x && \text{if } \sum\limits_{x \in c}x \leq 10 \\0 && \text{if } \sum\limits_{x \in c}x > 10 \\\end{array}\right .$<br/><div class="note warning">            <p>再次提醒，這裡的動作函數 $A$ 很可能是「一對多」映射；嚴格說「一對多」映射不構成函數，但習慣上會這樣稱呼。</p>          </div><h1 id="策略與效用"><a href="#策略與效用" class="headerlink" title="策略與效用"></a>策略與效用</h1><p>接下來，我們要討論策略與效用。</p><p>策略（policy）被定義為 $\pi(s_{t})$，其中 $s_{t} \in S$，指的是在狀態 $s_{t}$ 的情況下，推薦的行動，<br>行動通常是由 $A(s_{t})$ 一對多映射得到的「多種結果」，而 $\pi(s_{t})$ 會必然會給出其中一種。</p><p>為了對比，最優策略（best policy）通常表示為 $\pi^{*}(s_{t})$，<br>是理想狀態下可以得到的最佳決策，也是之後 AI 算法收斂的目標。</p><p>「效用」其實就是得分，為 $R(s_{t})$ 的加總。<br>若隨著時間我們有不同的狀態 $s_{0}, s_{1}, s_{2}, …$，則效用可以表示成：</p><p>$U_{h}([s_{0}, s_{1}, s_{2}, …]) &#x3D; R(s_0) + \gamma R(s_1) + \gamma^{2} R(s_2) + …$</p><p>其中 $\gamma \in [0, 1]$ 為折扣因子，折扣因子越接近 $0$，則對未來的效用越不敏感，<br>通常這種效用的定義方式，被稱作折扣回報（discounted reward），<br>當 $\gamma &#x3D; 1$ 效用退化成單純的加總，被稱為累加回報（addictive reward）。</p><h1 id="貝爾曼方程"><a href="#貝爾曼方程" class="headerlink" title="貝爾曼方程"></a>貝爾曼方程</h1><p>在進行算法前，我們這邊要介紹一個效用方程式，<br>被稱為「貝爾曼方程」又名動態規劃方程，定義如下：</p><p>$U(s_{t}) &#x3D; R(s_{t}) + \gamma\max\limits_{a \in A(s_{t})}\sum\limits_{s_{t+1}}P(s_{t+1}|s_{t}, a)U(s_{t+1})$</p><p>回憶上面建模的定義，其中 $s_{t}, s_{t+1} \in S$ 且 $a_{t} \in A(s_{t})$</p><p>雖然看起來很複雜，但其實不太困難，具體來說：</p><ol><li>在某個時間 $t$ 有某一個狀態 $s_{t}$</li><li>這個 $s_{t}$ 的效用 $U(s_{t})$ 為「目前的效用 $R(s_{t})$」</li><li>執行某一個動作 $a$ 後，下一個狀態的期望值 $\sum\limits_{s_{t+1}}P(s_{t+1}|s_{t}, a)U(s_{t+1})$</li><li>這個狀態的效用，其中包含到折扣因子 $\gamma$ 及下一狀態期望的最佳效用</li></ol><p>其中第 3 點，單純這樣看可能難以理解；<br>因為抽牌具有隨機性，所以用我們的簡化二十一點說明：</p><ol><li><p>假設折扣因子為 $\gamma &#x3D; 0.9$</p></li><li><p>舉例來說，在某個時間 $t$ 有某一個狀態 $s_{t} &#x3D; (\{1, 3, 5\}, 1)$ 即「手牌有 1、3、5 點，還沒 PASS 過」</p></li><li><p>目前的效用 $R(s_{t}) &#x3D; R(\{1, 3, 5\}, 1) &#x3D; 1 + 3 + 5 &#x3D; 9$</p></li><li><p>可以執行的動作為 $A(s_{t}) &#x3D; A(c_{t}, f_{t}) &#x3D; \text{draw, pass}$</p></li><li><p>執行抽牌動作 $a &#x3D; \text{draw}$ 的話，期望值有：</p><ul><li>$P((\{1, 3, 5, 1\}, 1)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 20% \cdot U(s_{t+1}) &#x3D; 20% \cdot U(\{1, 3, 5, 1\}, 1) &#x3D; 2$<br/><br> （由於接下來 $s_{t+2}$ 都超過 10 點，選擇 PASS 為最大，所以不必計算 $U(s_{t+2})$ 的值。）</li><li>$P((\{1, 3, 5, 2\}, 1)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 20% \cdot U(s_{t+1}) &#x3D; 0$（超過 10 點）</li><li>$P((\{1, 3, 5, 3\}, 1)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 20% \cdot U(s_{t+1}) &#x3D; 0$（超過 10 點）</li><li>$P((\{1, 3, 5, 4\}, 1)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 20% \cdot U(s_{t+1}) &#x3D; 0$（超過 10 點）</li><li>$P((\{1, 3, 5, 5\}, 1)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 20% \cdot U(s_{t+1}) &#x3D; 0$（超過 10 點）</li><li>$P((\{1, 3, 5, 1\}, 0)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 20% \cdot U(s_{t+1}) &#x3D; 0$（再抽牌，超過 10 點）</li><li>$P((\{1, 3, 5, 2\}, 0)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 0% \cdot U(s_{t+1}) &#x3D; 0$（不能抽牌）</li><li>$P((\{1, 3, 5, 3\}, 0)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 0% \cdot U(s_{t+1}) &#x3D; 0$（不能抽牌）</li><li>$P((\{1, 3, 5, 4\}, 0)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 0% \cdot U(s_{t+1}) &#x3D; 0$（不能抽牌）</li><li>$P((\{1, 3, 5, 5\}, 0)|(\{1, 3, 5\}, 1), \text{draw})U(s_{t+1}) &#x3D; 0% \cdot U(s_{t+1}) &#x3D; 0$（不能抽牌）</li></ul></li><li><p>執行停止動作 $a &#x3D; \text{pass}$ 的話，期望值有：<br>$P((\{1, 3, 5\}, 0)|(\{1, 3, 5\}, 1), \text{pass})U(s_{t+1}) &#x3D; 100% \cdot U(s_{t+1}) &#x3D; 9$（接下來不能抽牌）<br>$P((\{1, 3, 5\}, 1)|(\{1, 3, 5\}, 1), \text{pass})U(s_{t+1}) &#x3D; 0% \cdot U(s_{t+1}) &#x3D; 0$（PASS 後，能繼續抽牌的機率為 0）</p></li><li><p>則「最大的下一個狀態期望值」是 $\max\limits_{a \in A(s_{t})}\sum\limits_{s_{t+1}}P(s_{t+1}|s_{t}, a)U(s_{t+1}) &#x3D; 9$</p></li><li><p>這個狀態的效用為 $U(s_{t}) &#x3D; R(s_{t}) + \gamma\max\limits_{a \in A(s_{t})}\sum\limits_{s_{t+1}}P(s_{t+1}|s_{t}, a)U(s_{t+1}) &#x3D; 9 + 0.9 \cdot 9 &#x3D; 17.1$</p></li></ol><h1 id="價值迭代"><a href="#價值迭代" class="headerlink" title="價值迭代"></a>價值迭代</h1><p>有了效用的評估，我們可以計算每個狀態的效用，<br>然後利用效用來決策，這個過程稱為價值迭代（value iteration）。</p><p>下面為價值迭代的步驟：</p><ol><li>輸入變數：狀態集合 $S$、動作函數 $A(s)$、轉換模型 $P(s’|s, a)$、回報函數 $R$、折扣因子 $\gamma$與停止誤差 $\epsilon$</li><li>建立區域變數：初期效用 $U(s)$、暫存效用 $U’(s)$ 及效用差 $\delta$</li><li>$U \leftarrow U’$、$\delta \leftarrow 0$</li><li>$U’(s) \leftarrow R(s) + \gamma\max\limits_{a \in A(s)}\sum\limits_{s’}P(s’|s_{t}, a)U(s’), \forall s \in S$</li><li>若 $|U’(s) - U(s)| &gt; \delta$ 則 $\delta \leftarrow |U’(s) - U(s)|$</li><li>重複 3~5 步，直到 $\delta &lt; \epsilon (1 - \gamma) &#x2F; \gamma$</li><li>回傳 $U$</li></ol><div class="note info">            <p>其中 $s’$ 跟 $s_{t+1}$ 是相同的，指某狀態 $s$（或 $s_{t}$）的下一個可能狀態<br>但在迴圈中，避免讀者誤會 $t$ 會遞增，故改以 $s’$ 表示</p>          </div><div class="note info">            <p>$U$ 跟 $U’$ 是兩個大小為 $|S|$ 的向量</p>          </div><p>不難發現，價值迭代不斷更新 $U(s)$ 向量去計算每個狀態的效用，<br>而中止條件是 </p><p>$$\delta &lt; \epsilon (1 - \gamma) &#x2F; \gamma$ 其中 $\delta &#x3D; \max\limits_{s}|U’(s) - U(s)|$$</p><p>要理解終止條件，我們要來討論貝爾曼方程的收斂，先定義兩個內容：</p><ul><li>貝爾曼算子 $B$ 相當於執行：</li></ul><p>$$R(s) + \gamma\max\limits_{a \in A(s)}\sum\limits_{s’}P(s’|s_{t}, a)U(s’)$$</p><ul><li>以及，最大范數 $\|U\|$：</li></ul><p>$$\|U\|&#x3D;\max\limits_{s}|U(s)|$$</p><p>即向量中最大的值</p><p>那麼，兩個效用的最大距離為 $\|U - U’\| &#x3D; \max\limits_{s}|U’(s) - U(s)|$ 即演算法中的 $\delta$</p><p>接下來，考慮第 $t+1$ 次迭代的距離為 $\|U_{t+1} - U_{t+1}’\|$<br>考慮演算法中第 4 步，即 $U_{t+1} \leftarrow BU_{t}$，可以發現 $U_{t+1}$ 為 $BU_{t}$<br>故 $\|U_{t+1} - U_{t+1}’\| &#x3D; \|BU_{t} - BU_{t}’\|$</p><p>因為<br>$$\|BU_{t} - BU_{t}’\| &#x3D; \|R(s) + \gamma\max\limits_{a \in A(s)}\sum\limits_{s’}P(s’|s_{t}, a)U_{t}(s’) - [R(s) + \gamma\max\limits_{a \in A(s)}\sum\limits_{s’}P(s’|s_{t}, a)U_{t}’(s’)]\|$$<br>$$&#x3D; \|\gamma\max\limits_{a \in A(s)}\sum\limits_{s’}P(s’|s_{t}, a)U_{t}(s’) - \gamma\max\limits_{a \in A(s)}\sum\limits_{s’}P(s’|s_{t}, a)U_{t}’(s’)\|$$<br>$$&#x3D; \gamma \|\max\limits_{a \in A(s)}\sum\limits_{s’}P(s’|s_{t}, a)U_{t}(s’) - \max\limits_{a \in A(s)}\sum\limits_{s’}P(s’|s_{t}, a)U_{t}’(s’)\|$$<br>$$\leq \gamma \|\max\limits_{s}U_{t}(s’) - \max\limits_{s}U_{t}’(s’)\|$$</p><div class="note info">            <p>「選擇某個動作達到的最大效用」不會高於「遍歷所有狀態得到的最大效用」</p>          </div><p>簡單觀察 </p><p>$$|\max\limits_{a}f(a) - \max\limits_{a}g(a)| \leq \max\limits_{a}|f(a) - g(a)|$$</p><p>在 $\max\limits_{a}|f(a) - g(a)|$ 中，若 $f(a)$ 為最大值，即 $f(a) &#x3D; \max\limits_{a}f(a)$<br>同樣的 $a$ 對於 $g(a)$ 來說，可能不滿足 $g(a) &#x3D; \max\limits_{a}g(a)$，所以有上面那個結果（書中習題 17.6(a) 的內容）</p><p>又 </p><p>$$\|U - U’\| &#x3D; \max\limits_{s}|U’(s) - U(s)|$$</p><p>所以 </p><p>$$\|BU_{t} - BU_{t}’\| \leq \gamma \|\max\limits_{s}U_{t}(s’) - \max\limits_{s}U_{t}’(s’)\| \leq \max\limits_{s}|U’(s) - U(s)| &#x3D; \|U - U’\|$$</p><p>可得 </p><p>$$\|BU_{t} - BU_{t}’\| \leq |U_{t} - U_{t}’|$$</p><p>考慮效用的極值：</p><p>$$U_{h}([s_{0}, s_{1}, s_{2}, …]) &#x3D; R(s_0) + \gamma R(s_1) + \gamma^{2} R(s_2) + …$$</p><p>$$\leq \max\limits_{s}R(s) + \gamma \max\limits_{s}R(s) + \gamma^{2} \max\limits_{s}R(s) + … &#x3D; \frac{\max\limits_{s}R(s)}{1-\gamma}$$</p><p>（由於 $\gamma &lt; 1$ 使用等比級數公式）</p><p>若有負回報 $R(s) \leq 0$ 同理，則有：</p><p>$$U_{max} &#x3D; \pm\frac{\max\limits_{s}R(s)}{1-\gamma}$$</p><div class="note info">            <p>這個步驟透漏了一個訊息，當 $\gamma &#x3D; 1$ 時，很可能貝爾曼方程不會收斂。</p>          </div><p>透過最大、小值範圍，不難推導出 $\|U_{0} - U_{t}’\| \leq \frac{2\max\limits_{s}R(s)}{1-\gamma}$</p><p>若 $N$ 次迭代的誤差不超過 $\epsilon$，又每一次誤差降低 $\gamma$ 倍，則 $\gamma^{N}\frac{2\max\limits_{s}R(s)}{1-\gamma}\leq \epsilon$</p><p>解出 $N$：<br>$$\gamma^{N}\frac{2\max\limits_{s}R(s)}{1-\gamma}\leq \epsilon$$<br>$$\gamma^{N}2\max\limits_{s}R(s) \leq \epsilon(1-\gamma)$$<br>$$\gamma^{N} \leq \frac{\epsilon(1-\gamma)}{2\max\limits_{s}R(s)}$$<br>$$N \leq log_{\gamma}(\frac{\epsilon(1-\gamma)}{2\max\limits_{s}R(s)})$$<br>$$N \leq log(\frac{\epsilon(1-\gamma)}{2\max\limits_{s}R(s)})&#x2F;log(\gamma)$$（換底公式）</p><p>則 $N$ 至多迭代 $\lceil log(\frac{\epsilon(1-\gamma)}{2\max\limits_{s}R(s)})&#x2F;log(\gamma) \rceil$ 次，<br>這是一整個系統的迭代上界，若我們只考慮一步：</p><p>$$\gamma\frac{2\max\limits_{s}R(s)}{1-\gamma}\leq \epsilon$$<br>$$2\gamma\max\limits_{s}R(s) \leq \epsilon(1-\gamma)$$<br>$$2\max\limits_{s}R(s) \leq \frac{\epsilon(1-\gamma)}{\gamma}$$</p><p>另外由於 </p><p>$$\|U_{t+1} - U_{t}\| &#x3D; \|U_{t} - U_{t+1}\| \leq \|U_{0} - U_{t}’\| $$</p><p>所以 </p><p>$$\|U_{t+1} - U_{t}\| \leq \|U_{0} - U_{t}’\| \leq 2\max\limits_{s}R(s) \leq \frac{\epsilon(1-\gamma)}{\gamma}$$</p><p>可得中止條件為：</p><p>$$\|U_{t+1} - U_{t}\| &#x3D; \max\limits_{s}|U’(s) - U(s)| &#x3D; \delta \leq \frac{\epsilon(1-\gamma)}{\gamma}$$</p><h1 id="問題解決"><a href="#問題解決" class="headerlink" title="問題解決"></a>問題解決</h1><p>接下來，我們來看實際解決問題時，價值迭代是如何運作的，<br>雖然表面上價值迭代計算每個狀態的效用，然後選擇動作朝著效用較大的方向前進，<br>但有時狀態顯示的效用並不能協助我們做出較佳的決策。</p><h2 id="地圖巡路"><a href="#地圖巡路" class="headerlink" title="地圖巡路"></a>地圖巡路</h2><p>這是書中玩具問題，再加上一點修改而成；<br>具體來說，我們的移動是確定的，導致期望值的部分是確定的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 宣告變數 */</span></span><br><span class="line"><span class="keyword">const</span> up = <span class="number">0</span>, down = <span class="number">1</span>, left = <span class="number">2</span>, right = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> A = [up, down, left, right];                        <span class="comment">// 動作 A</span></span><br><span class="line"><span class="keyword">let</span> U = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">() =&gt;</span>                   <span class="comment">// 效用</span></span><br><span class="line">        <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">4</span>&#125;, <span class="function">() =&gt;</span> <span class="number">0</span>));              <span class="comment">// 大小 width = 4, height = 3</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Ut</span> = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">() =&gt;</span>                  <span class="comment">// 效用暫存</span></span><br><span class="line">         <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">4</span>&#125;, <span class="function">() =&gt;</span> <span class="number">0</span>));             <span class="comment">// 大小同效用 U</span></span><br><span class="line"><span class="keyword">let</span> D = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="function">() =&gt;</span>                   <span class="comment">// 決策表</span></span><br><span class="line">         <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">4</span>&#125;, <span class="function">() =&gt;</span> <span class="number">0</span>));             <span class="comment">// 大小同效用 U</span></span><br><span class="line"><span class="keyword">let</span> epsilon = <span class="number">0.01</span>;                                     <span class="comment">// 迭代停止參數</span></span><br><span class="line"><span class="keyword">let</span> gamma = <span class="number">0.9</span>;                                        <span class="comment">// 折扣因子</span></span><br><span class="line"><span class="keyword">let</span> delta;                                              <span class="comment">// 迭代差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回報函數 */</span></span><br><span class="line"><span class="keyword">let</span> R = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(x == <span class="number">3</span> &amp;&amp; y == <span class="number">0</span>) &#123;                                <span class="comment">// 終點</span></span><br><span class="line">    <span class="keyword">return</span> +<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">3</span> &amp;&amp; y == <span class="number">1</span>) &#123;                          <span class="comment">// 陷阱</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>) &#123;                          <span class="comment">// 牆（不評分）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">0.04</span>;                                         <span class="comment">// 其他狀態</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 動作的期望值 */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Exp</span> = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> exp = [];</span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    exp.<span class="title function_">push</span>(<span class="number">1.0</span> * U[y][x - <span class="number">1</span>]);                        <span class="comment">// 向左移動</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    exp.<span class="title function_">push</span>(<span class="number">1.0</span> * U[y][x + <span class="number">1</span>]);                        <span class="comment">// 向右移動</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    exp.<span class="title function_">push</span>(<span class="number">1.0</span> * U[y - <span class="number">1</span>][x]);                        <span class="comment">// 向上移動</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    exp.<span class="title function_">push</span>(<span class="number">1.0</span> * U[y + <span class="number">1</span>][x]);                        <span class="comment">// 向下移動</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> exp;                                           <span class="comment">// 回傳期望值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 演算法主體 */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;                         <span class="comment">// 複製效用暫存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;</span><br><span class="line">      U[y][x] = <span class="title class_">Ut</span>[y][x];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  delta = <span class="number">0</span>;                                            <span class="comment">// 初始化迭代差</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; <span class="number">3</span>; y++) &#123;                         <span class="comment">// 對所有狀態</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; <span class="number">4</span>; x++) &#123;  </span><br><span class="line">      <span class="keyword">if</span>((x == <span class="number">3</span> &amp;&amp; y == <span class="number">0</span>) ||                          <span class="comment">// 終點的效用固定</span></span><br><span class="line">         (x == <span class="number">3</span> &amp;&amp; y == <span class="number">1</span>) ||                          <span class="comment">// 陷阱的效用固定</span></span><br><span class="line">         (x == <span class="number">1</span> &amp;&amp; y == <span class="number">1</span>)) &#123;                          <span class="comment">// 牆的效用固定</span></span><br><span class="line">        <span class="title class_">Ut</span>[y][x] = <span class="title function_">R</span>(x, y);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;                                            <span class="comment">// 其他狀態的效用</span></span><br><span class="line">        <span class="keyword">let</span> exp = <span class="title class_">Exp</span>(x, y);</span><br><span class="line">        <span class="title class_">Ut</span>[y][x] = <span class="title function_">R</span>(x, y) + gamma * <span class="title class_">Math</span>.<span class="title function_">max</span>(...exp);  <span class="comment">// 貝爾曼方程</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Ut</span>[y][x] - U[y][x]) &gt; delta) &#123;       <span class="comment">// 計算最大迭代差</span></span><br><span class="line">        delta = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Ut</span>[y][x] - U[y][x]);           <span class="comment">// 儲存迭代差</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (delta &gt;= epsilon * (<span class="number">1</span> - gamma) / gamma);       <span class="comment">// 中止條件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 Console 輸出表格 */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(U);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>程式輸出請參考圖 2 所示，<br>雖然表面上，只要沿著效用較大的格子走，就可以到達終點，<br>但實際的決策可能要參考 $\max\limits_{a \in A(s)}$ 的動作選擇，<br>具體請參考簡化二十一點的程式輸出。</p><p><img src="https://i.imgur.com/1Z7xib3.png" alt="圖 2、地圖巡路：程式輸出"></p><h2 id="簡化二十一點"><a href="#簡化二十一點" class="headerlink" title="簡化二十一點"></a>簡化二十一點</h2><p>接著看我們自己設計的玩具問題，幫助我們理解更全面一點。</p><p>考慮任何狀態 $s_{t} &#x3D; (c, f) \in S$ 與 $s_{t}’ &#x3D; (c’, f’) \in S$<br>若滿足 $\sum\limits_{x \in c}x &#x3D; \sum\limits_{x \in c’}x$ 則效用評估有：$U(s_{t}) &#x3D; U(s_{t}’)$<br>因為效用等於牌面點數和 $R(s) &#x3D; R(s’)$，而動作只有抽不抽牌，故雖然看起來 $|S|$ 很大，<br>但其實 $|S|$ 有意義的範圍，只有 $\sum\limits_{x \in c}x \leq 10$ 的部分而已。</p><p>故 $S$ 大小為總和的可能值域：即 0（手上沒牌）到 15（剛好手上總和為 10 點時，又抽了一張 5 點）<br>加上抽不抽牌的旗標有 0 與 1 兩種，共 2*15 &#x3D; 30 種狀態，<br>然而實際程式碼中，狀態其實只是效用 $U$ 與 $U’$ 的引索而已。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 宣告變數 */</span></span><br><span class="line"><span class="keyword">const</span> pass = <span class="number">0</span>, draw = <span class="number">1</span>;                               <span class="comment">// 動作 A</span></span><br><span class="line"><span class="keyword">let</span> U = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">2</span>&#125;, <span class="function">() =&gt;</span>                   <span class="comment">// 效用, s = (c, f)</span></span><br><span class="line">        <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">16</span>&#125;, <span class="function">() =&gt;</span> <span class="number">0</span>));             <span class="comment">// 大小 |c| = 16, |f| = 2 </span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Ut</span> = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">2</span>&#125;, <span class="function">() =&gt;</span>                  <span class="comment">// 效用暫存</span></span><br><span class="line">         <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">16</span>&#125;, <span class="function">() =&gt;</span> <span class="number">0</span>));            <span class="comment">// 大小同效用 U</span></span><br><span class="line"><span class="keyword">let</span> epsilon = <span class="number">0.01</span>;                                     <span class="comment">// 迭代停止參數</span></span><br><span class="line"><span class="keyword">let</span> gamma = <span class="number">0.9</span>;                                        <span class="comment">// 折扣因子</span></span><br><span class="line"><span class="keyword">let</span> delta;                                              <span class="comment">// 迭代差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回報函數 */</span></span><br><span class="line"><span class="keyword">let</span> R = <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c &gt; <span class="number">10</span> ? <span class="number">0</span> : c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 動作的期望值</span></span><br><span class="line"><span class="comment">   若 f = 0: 只能選擇 &quot;pass&quot; (其中 exp = [pass_value])</span></span><br><span class="line"><span class="comment">   若 f = 1: 可能選擇 &quot;draw&quot; 或 &quot;pass&quot; (其中 exp = [pass_value, draw_value]) */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Exp</span> = <span class="keyword">function</span>(<span class="params">c, f</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> exp = [];</span><br><span class="line">  <span class="keyword">if</span> (f == <span class="number">0</span>) &#123;                                         <span class="comment">// 若 f = 0: 只能選 &quot;pass&quot;</span></span><br><span class="line">    exp.<span class="title function_">push</span>(<span class="number">1.0</span> * <span class="title function_">R</span>(c));                               <span class="comment">// pass 成功機率為 100%</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f == <span class="number">1</span>) &#123;                                  <span class="comment">// 若 f = 1: 能選 pass 或 draw</span></span><br><span class="line">    exp.<span class="title function_">push</span>(<span class="number">1.0</span> * <span class="title function_">R</span>(c));                               <span class="comment">// pass 成功機率為 100%</span></span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">0</span>;                                          <span class="comment">// draw 下個狀態的機率為牌面 + 1~5 (各20%)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> d = <span class="number">1</span>; d &lt;= <span class="number">5</span>; d++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c + d &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        t += <span class="number">0.2</span> * U[f][c + d];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exp.<span class="title function_">push</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> exp;                                           <span class="comment">// 回傳期望值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 演算法主體 */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> f = <span class="number">0</span>; f &lt;= <span class="number">1</span>; f++) &#123;                        <span class="comment">// 複製效用暫存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt;= <span class="number">15</span>; c++) &#123;</span><br><span class="line">      U[f][c] = <span class="title class_">Ut</span>[f][c];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  delta = <span class="number">0</span>;                                            <span class="comment">// 初始化迭代差</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> f = <span class="number">0</span>; f &lt;= <span class="number">1</span>; f++) &#123;                        <span class="comment">// 對所有狀態 s = (c, f)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">0</span>; c &lt;= <span class="number">15</span>; c++) &#123;</span><br><span class="line">      <span class="keyword">let</span> exp = <span class="title class_">Exp</span>(c, f);</span><br><span class="line">      <span class="title class_">Ut</span>[f][c] = <span class="title function_">R</span>(c) + gamma * <span class="title class_">Math</span>.<span class="title function_">max</span>(...exp);       <span class="comment">// 貝爾曼方程</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Ut</span>[f][c] - U[f][c]) &gt; delta) &#123;       <span class="comment">// 計算最大迭代差</span></span><br><span class="line">        delta = <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="title class_">Ut</span>[f][c] - U[f][c]);           <span class="comment">// 儲存迭代差</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (delta &gt;= epsilon * (<span class="number">1</span> - gamma) / gamma);       <span class="comment">// 中止條件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 Console 輸出表格 */</span></span><br><span class="line"><span class="keyword">let</span> arr = [[], []];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c = <span class="number">0</span>; c &lt;= <span class="number">15</span>; c++) &#123;</span><br><span class="line">    arr[<span class="number">0</span>].<span class="title function_">push</span>(<span class="built_in">parseFloat</span>(U[<span class="number">0</span>][c].<span class="title function_">toFixed</span>(<span class="number">2</span>)));</span><br><span class="line">    arr[<span class="number">1</span>].<span class="title function_">push</span>(<span class="built_in">parseFloat</span>(U[<span class="number">1</span>][c].<span class="title function_">toFixed</span>(<span class="number">2</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">table</span>(arr);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>參考圖 3 可以看到執行結果，<br>查看完整演示之前，我們可能需要分析一下結果的合理性。</p><p><img src="https://i.imgur.com/cpzMqL4.png" alt="圖 3、簡化二十一點：程式輸出"></p><p>若狀態 $s &#x3D; (c, f)$，那麼列（row）方向是 $f$ 的標誌，而行（cloumn）方向是 $\sum\limits_{x \in c}x$ 的值。</p><p>可以發現 $s &#x3D; (9, 1)$ 的值，跟 <a href="#%E8%B2%9D%E7%88%BE%E6%9B%BC%E6%96%B9%E7%A8%8B">貝爾曼方程段落</a> 的手算結果一致，<br>不過看起來表格怪怪的，這主要是因為我們沒有顯式地把 $\max\limits_{a \in A(s)}$ 的選擇保留，<br>導致這張表格本身雖然能看到效用值 $U$，但是不能為我們做決策。</p><p>舉兩個例來說：</p><ol><li><p>如果我狀態在 $s &#x3D; (1, 10)$ 則我會選擇 $s &#x3D; (0, 10)$ 為下個狀態（也就是 pass 動作），<br>因為與 $(1, i), i &#x3D; 11, 12, …, 15$ 相比，該位置效用值較大。</p></li><li><p>如果我狀態在 $s &#x3D; (1, 9)$ 則我會選擇 $s &#x3D; (1, 10)$ 為下個狀態（也就是 draw 動作），<br>因為與 $(1, i), i &#x3D; 10, 12, …, 14$ 相比，該位置效用值較大。</p></li></ol><p>第二個例子，就是這張表不合邏輯的地方了，<br>從另一個角度來說，如果我狀態是 $s &#x3D; (1, 9)$，抽牌的風險非常大。</p><div class="note info">            <p>敏銳的讀者可能發現，可以將這個玩具問題轉換成地圖尋路。</p>          </div><h3 id="結果修正"><a href="#結果修正" class="headerlink" title="結果修正"></a>結果修正</h3><p>事實上，如果我們將 $\max\limits_{a \in A(s)}$ 記錄下來，可以發現 AI 其實是選擇 pass 動作，才使效用最大化的，<br>具體參考圖 4 的 $s &#x3D; (1, 9)$ 處。</p><p><img src="https://i.imgur.com/3LjuaW5.png" alt="圖 4、簡化二十一點：MAX 函數的動作選擇"></p><p>題外話，若改變 $R(s)$ 在 $\sum\limits_{x \in c}x &gt; 10$ 條件下的值，決策可能發生變化；<br>具體來說，當 $0$ 變成 $-\infty$ 時，決策會趨近絕對保守（盡量 PASS），反之亦然。</p><p>另一個修正方法是，將 $R(s)$ 重新定義，順便將 $(1, i), i &#x3D; 11, 12, …, 15$ 固定下來。<br>我們規定，狀態為 $pass$ 時，會有回報的加成，則重新定義的 $R$ 為：</p>$R(s) = R(c, f) = \left\{\begin{array}{l}(1 - f) + \sum\limits_{x \in c}x && \text{if } \sum\limits_{x \in c}x \leq 10\\0 && \text{if } \sum\limits_{x \in c}x > 10\\\end{array}\right .$<p>結果請參考圖 5，此時我們便可以透過效用直接選擇動作了。</p><p><img src="https://i.imgur.com/Jof8bqT.png" alt="圖 5、簡化二十一點：重新定義回報的結果"></p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><iframe scrolling="no" width="100%" height="200px" src="https://jsfiddle.net/bzL638xf/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><div class="note info">            <p>雖然邏輯上是 AI 高於 7 點則不再抽牌，但這個結論是透過計算而來的；<br>可以想見在更複雜的狀態環境中，仍可建立決策模式。</p>          </div>]]></content>
      
      
      <categories>
          
          <category> 人工智慧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊與羊的草原 02</title>
      <link href="//sheeps-02/"/>
      <url>//sheeps-02/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password incorrect!" data-whm="Hash wrong!">  <script id="hbeData" type="hbeData" data-hmacdigest="e4ba23feef8532250745b9c41cb358e06c6ab18d476df5660cc150233df1678a">b86d4129f36541f97caeda0e7cd510caa52cd3aa6073614a64850db0d95da2ad022c9f89eb3a18c23562992c5d6fd33bd1fc648953161ace0e30ed893e00caaf87e69c3bc86a16f9ee53ae607859d02db9208ffd00709809afd44e6a10231aa75e5a6328d08c2625621560a2645fe25f017e9126bece7258a4b97cd9eee3ad4df409934a9658be84064281af4c012a4e517483a498aa8571876e1ec553d867ea25283b04a4010e355245a0260d4fac1f0ba11bf63c37bef269d08f973f660bb5bc65e83fc5e40359148c2fe78b3845735c4d28b221582822a0c4763c9b29c1fc4767474e213e2e4f5d8fd57503ea75d2d4464d55fe360971dd49aa815c27741459aeb8751e16ff1461ea7521a8a8d7e334520130b4755e08de842f549966dc8459050aa65342d11db0c3a12df80468239fd74cdc035f5905438d8a8293b5c8bf8d55bc1f46599369fc7ea1198d2b26a71299a08af66025d279cdb0cf6fee85667dd56b1c28c767b67e8bb3e603389203aa5c8308aeef3ba41306e6191e6711dd3da37e218b76e79a27e55f7c4c78594a1fea15d751bb1a047851ebab4af386eb6997049ad39ddfcbf24335cd31b95567b4b300311cf73bd2e6559eabd6c856c173729a03ef0bdcd4e0900c4776c91e874dc2b0071aa38c11244206ac83c8c46c5c08485228d930e1214570d79630dd0944583bd494ae4cd6712d4c81afe7919c903f2af5d8e6a0d8c22a6bd893dac5e28dcd4daeaebdeb7e4007a3d3d41181db5de8bd6b79816a8f1a9f0266180cf4b97abbce01a063efe262216269d046587743eb9b368c219bcf37bbda9a681240136f8261848fd3d64dcac79a4a40d0d4853f4691c064269a5d40675009deed5e054d7c8eaee6a8c02c1555a8036b9badf35d3082baf43afcc707a40d64663075f8b4c008a648b0b737170edf586ffc390576b4ad7fd900eb93e43139712e9f819326ca396178e80d22a6a695b2e3b3bc19a675e895aaa002a988ed48f9c37b09a0837d602c743a56dab8d5ea419959ba1baa35953e3879b3fdc4b5d588aefe80decbe73d7793e464371454a67023a2ac4e359fe84690c9e205df782c8d480c296aed3b3497adc36b2e255845e08ec085dea893beb6d228851a63e774fb0f0f7597c07638bbdc1af11cc8249515fdefbdf5d098f0e67beffbdebfa1692c451b250dc641e666acb14fb2d9509ed0c58e061a5c559d0b694a734ac5681c9459fedde5480bb2a23b1075dc5e9da4b4c4c3ea008a51f4b5b8eb43f5d86fbb3f8c4d56337d7474c3a20d936fce17c427e3468361617465f24c05dae3b7e4b5922065e217f0bf40b0029f95249b5f43d76144ca162d32a06c48d8ca52555447630a40f98aff40217ebaf4e7904fbdb080ae91128d79867536b8bec82bef20dc39184381e6895f949cee4536698a5ac4812d3097d2e9b179bb95b32898e2b02dd81f4817057ba401a0373ee0703eb7499ab08422a4729a0ace73469b8b45e12ff71cb688e3b187d6ddb82309617d38e6e277980a3e586428d0ff92a44af5f53a77d7f42ebebaf553154196e388e8a478834f2a95a91674ae26c0cdb0b10ec042bb96aed231223f71d136a9c9abbac93b1436bd211cf6b6233425fd2ebb2dfaf2434c50072a6570b49be08192b8097fcda98aa4efca5d8e086dfe3bce79275fe03aa61f6bd4d35d8fda422cdf886ecc7fd073d5115e0c1b01fef8b9140e277bb7d52e3246307d8aac0489602b571e6b6aafb2d2af6a616b1da1f1b2f624d1e4f897887fcac3a62a6132f5bf41ff780525fe61f44a76c9a423ab315f841dfc7d45f9c9fc1c4630b89958e7e4c4d3aef4400a044ae072d2972e38274f9cb87d342fbbe23492952a738eff9f1bf2dbab5592415879d7fa9b8ba3c8157b7ce1cbada2086ca3a537210c799662f8c36da4b1e26e82000eb6b2c9bbcac3c4547316e7c01225c8bdd981bae1afd0a376da23ab93f991897214570519412a1a5ff99f881459262333e901e9dd147b49b4e2ce876d7169ef731a1c5b77daa1b2b5e113f50e820542ad6c00e2a0711cca352e5a934e739c1e88f440468c5ffa0fb633297cdeff7c555026fdb27efa489014ce86b71d308806ba8f245b70799b8182886e9e4c057eba5ea7633d04daa63a275e769a7375bcf42e8d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">🔒 Encrypted Article      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass" placeholder="Password">    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 獨立遊戲製作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊羽手札更新歷程 04</title>
      <link href="//tinytsunami-update-04/"/>
      <url>//tinytsunami-update-04/</url>
      
        <content type="html"><![CDATA[<p>最近比較開始有時間重新開始維護部落格了。</p><span id="more"></span><h1 id="更新歷程"><a href="#更新歷程" class="headerlink" title="更新歷程"></a>更新歷程</h1><ul><li>2016.10.24 羊羽手札v1（PHP）</li><li>2017.12.18 羊羽手札v2（Vue.js+Express）</li><li>2017.02.25 羊羽手札v3（Hexo）</li><li>2017.02.25 更新歷程 01 發表</li><li>2018.07.01 更新歷程 02 發表</li><li>2018.09.24 暫停更新</li><li>2018.09.24 更新歷程 03 發表</li><li>2019.03.28 重啟更新</li><li>2019.04.20 羊羽手札v4（Hexo&#x2F;Next Update）</li><li>2019.04.20 更新歷程 04 發表</li></ul><h1 id="系統更新"><a href="#系統更新" class="headerlink" title="系統更新"></a>系統更新</h1><ol><li>數學公式顯示系統「MathJax」的版本更新</li><li>文章中的標籤改成顯示圖示</li><li>留言系統更新</li><li>增加圖片的文字標題</li></ol>]]></content>
      
      
      <categories>
          
          <category> 羊羽手札 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊與羊的牧場 01</title>
      <link href="//sheeps-01/"/>
      <url>//sheeps-01/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Password incorrect!" data-whm="Hash wrong!">  <script id="hbeData" type="hbeData" data-hmacdigest="9bad6885146f7bfcf94312eaf7c73380d0758eb7143a53f0e6f74a513458ecac">b86d4129f36541f97caeda0e7cd510caa52cd3aa6073614a64850db0d95da2ad022c9f89eb3a18c23562992c5d6fd33bd1fc648953161ace0e30ed893e00caafeb6fcd3486f3b6f5ea6410141ee0324e2c4532b523b08229807c84d77e772f0adde43258990b5480605159db8b9af5f225f7979cf78afd16293c7b541db88a1cdcf48e300385fec2e3e554d8a48e0c7800d69f37277b85e66e17caf2d4865bed444b1c6ca2fc986d6e578e9171c68bd0809269e40c4de4d2b98bfd1fcd49fab78c6dd278b89a4c5665f23b9e2d44f4f15a8f3b11f9c8139c0d9bf964d28d5d2a461eceb87fcbe92d12a16f1f45f69d7ff90855910de2c666a124211cd255d676a9b29b3188c503ac6205b19aaaabef5af24f3257d7b3bc910a17231f0c6c4fe0c53977b723a633e579c346ce863babb51d9798a7c83897f0a859db493a17b9d82a372ec7a6f64d4684116528ff38f29260a9028170d747094d70849592d8917b5e885804d6b940ab6a8ee531f10167b4518dc9e5fdccb643f79babe46ba19f0a3aa5afbff407d2ea6277efe069243da3853fb4c8d523e043e8706f11eb5263d60231561f59ccac0eaf1401e5ffb3a0a472764c42b0c52e5467c6d78fc1641103024ee0c3ecdaaab4f81967083def301997c3d0213a0ff3573599bcae3e971c5dc3e65767146fb2471a0e15870f80c8f9f469c3c5d6e14b2d7074c788b03505d4deded0a39eb34186c7eb6aa60c4bdaa7bc78d894056f17f1b8d351d78847d5fc5b97f16d0beabcc885a6cb910647dc4cbaca7d0bd51ee8801a253f6f716c8e22285a4a5ddc356e50552e23bbaecfe40f267de628b22b9cacee1252007eda6c6340e7a77123bd989dd802305534b21e24de8ee19d89a6a8c536fd1588fdcaa57e38358e10ab19be18ea9459943c39d229cba4934153a8d8fa745123272bf612ca372dfae490e00637b866a8b4d4e4c4977d3b92dced36a8f70d8baaf7204b9ac3e194731584b31926fbc34f493d681c55721c5e08168cf4774d4a100f0bda4bca4ac6044485459e15085060038f4c74f0071f05f3684de7dff7619b22a04bbb4b80224486b6e016c95470788be69b79a3647809005ee8b5bf449d8c5a3e576eee7036603ad804cdc25629c630e591d62a4eeb5d9f5b52fa76d5e58803b1637d6a374cd8edd68d26e579dd321b22c3568558c5d86159890442ba0d906f95829a722b719b59a3411ca4662a1c701d280520b9e0470721f246235dc659a5258f3e4ec38cdcbf07b892c3ca050fc937c43912ec7b55f55810857373e76908b79bbcaf4f8ede43a73e3be6591e0da60d075a3e7426cc5dd174976cf85661db7566e02205fbf70c49d33394dd0c199c11b65e536b44386ab52d391fb0b49b230b507966a644f82e0dd2d73c1adfd648fa252bf78c0d01828c8a7cd2ea719b9a1c5e2ca5d14f4f71b0cc2db421195aeccabb4bca29986ba4b78d84a7dd14f9a68a03969155254985addfaae3a961b053023c9de9a51bf8578cd45b89a6e2653ab6f94bdce837af5bb6f3a6a47e492a4eb52338bce8a6db71563a6cd680be34b1ae022a276eaa22089695f17b04680f3d7441f3c123d611c827ed75db7e3bd6f0faf37a43a4eb356040ffdf27acf8cae5346d4850d7317c03eeb54790d3c3a521eb14a9a08271fdf1412e7f4cd25b326654c089f736750de0068ceb3bfbf23926e1156c45bc91f0bd465a8d6f632a3b273272468539a81b626edecc2188224f83941868b1bc147e52a8ecba96579dbd5705acac14c3f3198455cc3d5c599f1005a3625f9eac42d163a30185cebc2ac6595fe5e57106715abdb1c4f0ca822e96be5cac8fe7dbd49e2fc593e519d2a030fc987a825aa0779f6c1c725837e687a875b202dc7b571bb95d466f8329e0fef0e6452df19f04cf3a00e87366828c6c306710597c795b2d2f68e2a6706c18862651e7453477edbab1fb4b8dbdbebe06dd46e2f1f6814dbb8356dbea32ad03067ca09cd58bc697798e0e2f408b56c2d56d95c2fd0f2fc99c39a27817807878aebabc835b0c0df2702db5db52406c70fe9f383fa671ba417b9983c2d36f3279a167b8ec2bc424b4ccbabfafa8c38b0c80c5c9728a81b652f22a2472503317d25932404321dcf460af4d1489aeeb44e973f1aec8222298039df1ec6054777449cfe01046978dba20f51cc1cf58c9ff10a1a97bc45398fb96ccf1daef054c7f383cd514e852e7ea67c38a220c56d6b4e0af91bf4a01070bdf7a9e5fe1453b77aaf922b4be13156922788b4532d37a11b6f47e65194b79aba8cf0098ed2d70991afc120038e8ecd5f1a683d8a860e92ebee77a8a0880cd7c18ebd6a1092dcec82e3390951acaf02bebc8d338bdc4b01a1fc4f842fe1e5e722c14ec45807c08f17f67b3d6a7d387a4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-blink">🔒 Encrypted Article      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass" placeholder="Password">    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 獨立遊戲製作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>馬可爾夫決策過程 Markov Decision Process</title>
      <link href="//markov-decision-process/"/>
      <url>//markov-decision-process/</url>
      
        <content type="html"><![CDATA[<p>這篇文章是《人工智能：一種現代的方法》及 Udacity 上的強化學習課程筆記及其他內容的整理，<br>從馬可爾夫決策過程、價值迭代、策略迭代、Q 學習，最後到深度 Q 網路的思路。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前半年太忙一直沒時間更新 Blog，現在終於有時間寫新文章了 XD</p><p>強化學習（reinforcement learning）一直是非常有趣的主題，跟遊戲設計搭配更是如此。<br>我曾經在 RPG Maker MV 中使用手刻的 3 層全連接神經網路來做 ARPG（動作 RPG）怪物的 AI 設計，<br>雖然效果不是很理想，不過確實可以觀察到怪物可以學習到一些玩家的攻擊模式並且迴避。</p><p>全連接神經網路在分類上是屬於監督學習，而本篇著重於強化學習，<br>強化學習是不透過標籤（label），系統直接由環境中取得資訊來學習的 AI 系統。</p><p>當時初學時，關於 Q 學習的部分其實看不太懂，我後來發現有一系列的途徑去理解，<br>一開始是自己閱讀《人工智能：一種現代的方法》，好不容易看懂（筆者數學不好……），<br>後來在 Udacity 的強化學習課程，又做了一次整理才明白。</p><div class="note info">            <p>關於課程請至 <a href="https://www.udacity.com/course/reinforcement-learning--ud600">Udacity 的課程資訊</a></p>          </div><p>我認為的最佳學習途徑：</p><ul><li>馬可爾夫決策過程（Markov Decision Process, MDP）</li><li>價值迭代（value iteration）與策略迭代（policy iteration）</li><li>Q 學習（Q-learning）</li><li>深度 Q 網路（Deep Q-Network, DQN）</li></ul><p>其中，前兩部分是序列式決策問題（sequential decision problem）的入門，<br>第三部分 Q 學習是關於序列決策的變體，最後深度 Q 網路則是將 Q 學習結合神經網路所誕生的算法。</p><p>本篇是第一部分，重點擺在討論馬可爾夫決策過程與問題建模，<br>至於策略、效用與貝爾曼方程將在下一篇文章解決。</p><div class="note success">            <p>這是 DQN 的系列文章，下一篇是 <a href="/value-iteration/" title="價值迭代 Value Iteration">價值迭代 Value Iteration</a></p>          </div><div class="note info">            <p>於 2019.05.13 更新了部分數學符號的表示</p>          </div><h1 id="馬可爾夫決策"><a href="#馬可爾夫決策" class="headerlink" title="馬可爾夫決策"></a>馬可爾夫決策</h1><p>馬可爾夫決策由下列部分組成：</p><ul><li>狀態集合 $S$</li><li>動作函數 $ACTION: S \mapsto A$ 其中 $A$ 為可執行的動作</li><li>轉移模型 $P(s_{t+1}|s_{t}, a)$ 其中 $s_{t} \in S$ 為當前狀態、$s_{t+1} \in S$ 為下一個狀態，$a \in A$ 為時間 $t$ 時執行的動作</li><li>回報函數 $R(s)$</li></ul><p>其中轉移模型必須滿足馬可爾夫假設（Markov assumption）即「$s_{t+1}$ 的狀態僅受 $s_{t}$ 狀態影響」。</p><div class="note info">            <p>動作函數，通常被說是「動作集合」，但在書中公式表達像是「回傳集合的函數」，故在此以函數說明。</p>          </div><h1 id="玩具問題"><a href="#玩具問題" class="headerlink" title="玩具問題"></a>玩具問題</h1><p>筆者的經驗是，初學見到這些符號會水土不服，<br>所以可以先過渡到幾個其他的玩具問題（toy problem）來理解馬可爾夫決策的過程。<br>順便練習把問題定義清楚。</p><h2 id="地圖尋路"><a href="#地圖尋路" class="headerlink" title="地圖尋路"></a>地圖尋路</h2><p>這是《人工智能：一種現代的方法》第 17.1 節序列式決策出現的玩具問題。</p><p>地圖大小寬度為 3、長度為 4，位置 $(2, 2)$ 是一堵牆，<br>寶藏在 $(4, 3)$，陷阱在 $(4, 2)$。電腦從 $(1, 1)$ 開始，每次移動 1 格，移動會消耗 0.04 分，<br>目標是透過探索地圖，找到一個最佳策略來獲得高分。</p><p>很難想像的話，看下面的圖 1。</p><p><img src="https://i.imgur.com/8g4n6Sv.png" alt="圖 1、基本玩具問題"></p><p>對於這個問題來說，建模的四個部分分別為：</p><ul><li>狀態集合，即座標集合 $S &#x3D; \{(x, y)| x \in \{1, 2, 3\}, y \in \{1, 2, 3, 4\} \}$</li><li>動作函數，即在某一座標可以執行的動作 $MOVE: S \mapsto A$ 其中 $A &#x3D; \{\text{up}, \text{left}, \text{right}, \text{down}\}$</li><li>轉移模型，即在某座標、執行某動作後，轉移到下個狀態的機率 $P(s_{t+1}|s_{t}, a_{t})$ 其中 $s_{t}, s_{t+1} \in S$ 且 $a_{t} \in A$</li><li>回報函數，每個位置的得分 $SCORE(s) &#x3D; SCORE(x, y)$</li></ul><p>下面給出一段淺白的描述作為例子。</p><p>目前在某一個座標 $x &#x3D; 1$ 且 $y &#x3D; 3$，所以我的「狀態」是 $s &#x3D; (1, 3) \in S$<br>在這個狀態下，我可以執行的動作為 $MOVE(1, 3) &#x3D; \text{up}, \text{left}, \text{right}, \text{down}$<br>也就是上下左右；如果此時我選擇 $a &#x3D; \text{right} \in A$ 即向右移動。</p><div class="note info">            <p>注意這裡的動作函數 $MOVE$ 是「一對多映射」，正因如此，玩家才在某些狀態，可以選擇多種動作。</p>          </div><p>若動作「一定會成功」則轉移模型為：$P((2, 3)|(1, 3), \text{right}) &#x3D; 100\%$<br>至於環境的回報（得分）是：</p>$SCORE(s) = \left\{\begin{array}{l}+1 && \text{if } s = (4, 3) \\-1 && \text{if } s = (4, 2) \\-0.04 && \text{otherwise}\end{array}\right .$<br/><div class="note info">            <p>書中的轉移模型是不確定的。舉例來說，你決定往上移動，只有 80% 的機會成功之類的。</p>          </div><h2 id="簡化的二十一點"><a href="#簡化的二十一點" class="headerlink" title="簡化的二十一點"></a>簡化的二十一點</h2><p>為了更理解「轉移模型」的部分，筆者再針對簡化過後的二十一點（Black Jack）建模，<br>這個簡化過後的規則如下：</p><ul><li>牌面 1、2、3、4、5 每種牌都有無限多張且抽到每一種的機率相等</li><li>牌面 1、2、3、4、5 對應點數為牌面的數字</li><li>每一回合莊家、玩家決定要不要繼續抽牌</li><li>若某回合不抽牌，接下來的回合不能繼續抽牌</li><li>若超過 10 點，則判輸</li><li>若雙方皆超過 10 點，則平手</li><li>若雙方皆小於等於 10 點，則點數大者勝</li><li>所有牌都是明牌（玩家可觀察）</li><li>莊家先抽牌</li></ul><p>如果你覺得規則理解有點困難，請嘗試玩玩看：</p><iframe scrolling="no" width="100%" height="200px" src="https://jsfiddle.net/d6bues10/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><div class="note info">            <p>因為還沒介紹完策略，暫時不將完整的 AI 放出來，這裡的電腦僅是單純的邏輯模擬。</p>          </div><p>對於這個問題來說，建模的四個部分分別為：</p><ul><li>狀態集合，即各種手牌 $s$ 及允許抽牌標誌 $t$ 的集合 $S &#x3D; \{s &#x3D; (c, t) | c \subseteq \{1, 2, 3, 4, 5\},  t \in \{1, 0\}\}$</li><li>動作函數，即每回合可以執行的動作 $ACTION: S \mapsto A$ 其中 $A &#x3D; \{\text{draw}, \text{pass}\}$</li><li>轉移模型，即抽牌後，轉移到下個狀態的機率 $P(s_{t+1}|s_{t}, a_{t})$ 其中 $s_{t}, s_{t+1} \in S, a_{t} \in A$</li><li>回報函數，即一局遊戲的牌面數字 $POINT(s), s \in S$</li></ul><p>我們先看動作函數，對於每一種手牌的狀態，<br>除非已經超過 10 點或曾經放棄抽牌，否則可以繼續抽牌，所以有：</p>$ACTION(s) = ACTION(c, t) = \left\{\begin{array}{l}\text{draw}, \text{pass} && \text{if } t = 1 \text{ and } \sum\limits_{x \in c}x \leq 10 \\\text{pass} && \text{if }  t = 0 \text{ or } \sum\limits_{x \in c}x > 10 \\\end{array}\right .$<br/><p>然後轉移模型此時便不是「確定」的，轉移到不同的狀態是透過機率，<br>比方說目前我有手牌且可抽牌 $s &#x3D; (\{1, 2, 3\}, 1)$ 考慮動作函數有 $ACTION(c, t) &#x3D; \text{draw}, \text{pass}$<br>所以轉移模型，有兩種動作可以選擇：</p><p>若選擇不抽牌，那下回合一定保持原來的手牌，但抽牌標誌變成 0。<br>$P((\{1, 2, 3\}, 0)|(\{1, 2, 3\}, 1), \text{pass}) &#x3D; 100%$</p><p>若選擇抽牌，那下回合增加手牌（每種機率相等），抽牌標誌不變。<br>$P((\{1, 2, 3, 1\}, 1)|(\{1, 2, 3\}, 1), \text{draw}) &#x3D; 20%$（抽到點數 1）<br>$P((\{1, 2, 3, 2\}, 1)|(\{1, 2, 3\}, 1), \text{draw}) &#x3D; 20%$（抽到點數 2）<br>$P((\{1, 2, 3, 3\}, 1)|(\{1, 2, 3\}, 1), \text{draw}) &#x3D; 20%$（抽到點數 3）<br>$P((\{1, 2, 3, 4\}, 1)|(\{1, 2, 3\}, 1), \text{draw}) &#x3D; 20%$（抽到點數 4）<br>$P((\{1, 2, 3, 5\}, 1)|(\{1, 2, 3\}, 1), \text{draw}) &#x3D; 20%$（抽到點數 5）</p><p>不難發現，對於某一種動作，機率和必為 $1$。</p><p>回報函數為牌面點數和，點數和越高越好，而超過 10 點則給予 0 值：</p>$POINT(s) = POINT(c, t) = \left\{\begin{array}{l}\sum\limits_{x \in c}x && \text{if } \sum\limits_{x \in c}x \leq 10 \\0 && \text{if } \sum\limits_{x \in c}x > 10 \\\end{array}\right .$]]></content>
      
      
      <categories>
          
          <category> 人工智慧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊羽手札更新歷程 03</title>
      <link href="//tinytsunami-update-03/"/>
      <url>//tinytsunami-update-03/</url>
      
        <content type="html"><![CDATA[<p>原本以為暑假可以很閒，結果意外的忙，<br>沒意外的話，一直到明年過完年才會有時間更新。</p><span id="more"></span><h1 id="更新歷程"><a href="#更新歷程" class="headerlink" title="更新歷程"></a>更新歷程</h1><ul><li>2016.10.24 羊羽手札v1（PHP）</li><li>2017.12.18 羊羽手札v2（Vue.js+Express）</li><li>2017.02.25 羊羽手札v3（Hexo）</li><li>2017.02.25 更新歷程 01 發表</li><li>2018.07.01 更新歷程 02 發表</li><li>2018.09.24 暫停更新</li><li>2018.09.24 更新歷程 03 發表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 羊羽手札 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>推盤遊戲  n-puzzle</title>
      <link href="//n-puzzle/"/>
      <url>//n-puzzle/</url>
      
        <content type="html"><![CDATA[<p>這是人工智慧課程的教學筆記。<br>同時也是學期初上課的內容，因為不太好寫演示所以拖到暑假來完成。</p><span id="more"></span><p>原本以為寫起來很簡單，但筆者發現許多地方很難說明清楚，<br>增加了許多圖片輔助理解，也延後了完成的時間……</p><div class="note info">            <p>本篇內容與機器學習無關，更屬於早期推理與搜索人工智慧的部分。</p>          </div><h1 id="滑塊遊戲"><a href="#滑塊遊戲" class="headerlink" title="滑塊遊戲"></a>滑塊遊戲</h1><p>開始之前，先來討論遊戲本體。  </p><h2 id="規則"><a href="#規則" class="headerlink" title="規則"></a>規則</h2><p>通常而言，已完成的盤面有 2 種表示方法，就像圖 1 這樣：</p><p><img src="https://i.imgur.com/90Tj4xL.png" alt="圖 1、盤面表示的 2 種方法"></p><p>筆者採用前者這種。</p><p>遊戲的規則很簡單：</p><ul><li>移動空格（即 0 那格）周圍的拼圖到空格上</li><li>移動到拼圖完成（只剩空格那塊不在正確的位置上）</li></ul><p>以程式來講，規則是容易實作的，<br>反而是盤面資料的表示會有很多的考量。</p><p>接下來我們會先討論盤面與狀態的關係，再敘說表示方法。</p><h2 id="盤面與狀態"><a href="#盤面與狀態" class="headerlink" title="盤面與狀態"></a>盤面與狀態</h2><p>所謂的狀態，其實就是指儲存的盤面，盤面可以用各種方式儲存，<br>其實狀態大致上跟盤面是同義的；雖然嚴格說起來，狀態是盤面的抽象表示。</p><p>考慮到 3x3 的盤面，就已經有多種保存的方法：</p><ul><li>儲存陣列</li><li>儲存動態陣列的指標</li><li>儲存某個計算過的數值</li><li>儲存定義的物件</li><li>…</li></ul><p>儲存陣列在高階語言中，相當於額外開一塊記憶體空間，<br>而在 C&#x2F;C++ 中，儲存指標可能要有效率的多。</p><p>計算某個數值的方法，舉例來說可以計算 $V(S) &#x3D; \sum\limits_{i&#x3D;0}^{N^{2}-1} 10^{i}S_{i}$<br>像是 $S &#x3D; [4, 7, 6, 3, 1, 2, 8, 0, 5]$ 就有：</p><p>$V(S) &#x3D; 10^{0}S_{0} + 10^{1}S_{1} + … + 10^{8}S_{8}$<br>$&#x3D; 4 + 70 + 600 + 3000 + 10000 + 200000 + 8000000 + 0 + 500000000 &#x3D; 508213674$</p><p>儲存定義的物件，通常是用於需要中間盤面的時候，<br>而筆者的演示因為需要動畫，所以採用的是這種方式（陣列儲存在物件中）。</p><div class="note danger">            <p>儲存特定數值可能不是有效的方法，因為數值較大可能溢位（4x4）</p>          </div><h2 id="盤面動作"><a href="#盤面動作" class="headerlink" title="盤面動作"></a>盤面動作</h2><p>定義好盤面表示法（即狀態）之後，接下來要定義動作。</p><p>由於我們將 2 維陣列以 1 維表示，直觀上來講，<br>若盤面大小為 $N$ 且狀態為 $S_{i}$ 其中 $i$ 為陣列的註標，<br>先定義取得列的函數：</p><p>$row(x) &#x3D; \lfloor\frac{x}{N}\rfloor$</p><p>動作的部分：</p><ul><li>向上移動，即 $swap(S_{i}, S_{i-N})$ 其中 $row(i-N) \geq 0$</li><li>向下移動，即 $swap(S_{i}, S_{i+N})$ 其中 $row(i+N) \leq N-1$</li><li>向左移動，即 $swap(S_{i}, S_{i-1})$ 其中 $row(i) &#x3D; row(i-1)$</li><li>向右移動，即 $swap(S_{i}, S_{i+1})$ 其中 $row(i) &#x3D; row(i+1)$</li></ul><div class="note warning">            <p>若將空格視為圖塊，因為只能移動空格，則此處的 $S_{i}$ 必為 $0$</p>          </div><p>舉個例子。</p><p>下面以 $N &#x3D; 3$ 即 3x3 盤面為例，<br>假設此時的 $S &#x3D; [4, 7, 6, 3, 1, 2, 8, 0, 5]$ 畫成圖 2：</p><p><img src="https://i.imgur.com/HohLNkB.png" alt="圖 2、初始盤面"></p><div class="note info">            <p>圖的格子中間的數字是儲存的值，而右下角為註標。</p>          </div><p>我們先向下移動，如果不考慮條件，直接移動的話，會變成圖 3：</p><p><img src="https://i.imgur.com/yTodbyw.png" alt="圖 3、向下移動錯誤"></p><p>驗算一下，因為 $S_{7} &#x3D; 0$ 則 $row(7+N) &#x3D; \lfloor\frac{7+3}{3}\rfloor &#x3D; \lfloor\frac{10}{3}\rfloor &#x3D; 3$ 有 $3 \nleq 2$ 代表條件不成立，<br>所以移動失敗，如圖 4：</p><p><img src="https://i.imgur.com/mlYFT87.png" alt="圖 4、向下移動失敗"></p><p>接著向上移動。<br>則 $S_{7} &#x3D; 0$ 因為 $row(7-N) &#x3D; \lfloor\frac{7-3}{3}\rfloor &#x3D; \lfloor\frac{4}{3}\rfloor &#x3D; 1$ 則 $1 \geq 2$ 成立，所以移動成功，如圖 5。<br>做 $swap(state[7], state[4])$ 有：</p><p><img src="https://i.imgur.com/LGGN4hg.png" alt="圖 5、向上移動成功"></p><p>然後我們向右移動，現在 $S_{4} &#x3D; 0$ 的話：<br>$row(4) &#x3D; \lfloor\frac{4}{3}\rfloor &#x3D; 1$<br>$row(4+1) &#x3D; \lfloor\frac{5}{3}\rfloor &#x3D; 1$<br>有 $1 &#x3D; 1$ 成立，所以移動成功，如圖 6。<br>做 $swap(state[4], state[5])$ 有：</p><p><img src="https://i.imgur.com/zLKI65z.png" alt="圖 6、向右移動成功"></p><p>我們最後再向右移動一次，考慮 $S_{5} &#x3D; 0$<br>$row(5) &#x3D; \lfloor\frac{5}{3}\rfloor &#x3D; 1$<br>$row(5+1) &#x3D; \lfloor\frac{6}{3}\rfloor &#x3D; 2$<br>因為 $1 \neq 2$ 所以移動失敗，如圖 7。</p><p>如果錯誤移動，則會變成：</p><p><img src="https://i.imgur.com/AY2LFNK.png" alt="圖 7、向右移動錯誤"></p><p>正確應該是圖 8 的樣子：</p><p><img src="https://i.imgur.com/mlYFT87.png" alt="圖 8、向右移動失敗"></p><p>從上面例子可以看出來，條件只是為了維護空格的正確性。</p><p>注意上下移動時，我們只判斷是否出界，因為 $ S_{i \pm N}$ 保證會與 $S_{i}$ 在同一行上；<br>同理，在左右移動時，僅判斷是否為同一列的原因，在於兩個出界的情況都會換列。</p><div class="note info">            <p>為了程式的美觀，可以兩個條件都檢查，不過有些顯得多此一舉。</p>          </div><div class="note warning">            <p>行（column）、列（row）是借用矩陣的術語，其實我們使用的是 1 維陣列，並無這個概念。</p>          </div><p>寫成程式，大概長這樣子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 檢查範圍 */</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="property">include</span> = <span class="keyword">function</span>(<span class="params">v, a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt;= a &amp;&amp; v &lt; b;                       <span class="comment">// v 屬於 [a, b) 則為真</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 註標轉換成列 */</span></span><br><span class="line"><span class="keyword">let</span> row = <span class="keyword">function</span>(<span class="params">n, index</span>) &#123;                  <span class="comment">// 這裡將 N 也一併傳入</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(index / n);                 <span class="comment">// 計算列數</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 操作動作 */</span></span><br><span class="line"><span class="keyword">let</span> move = <span class="keyword">function</span>(<span class="params">s, a</span>) &#123;                     <span class="comment">// 傳入目前的狀態</span></span><br><span class="line">  <span class="keyword">let</span> nextS = <span class="title class_">Array</span>.<span class="title function_">from</span>(s);                    <span class="comment">// 複製一份狀態</span></span><br><span class="line">  <span class="keyword">let</span> p = s.<span class="title function_">indexOf</span>(<span class="number">0</span>);                         <span class="comment">// 檢查 0 的註標</span></span><br><span class="line">  <span class="keyword">switch</span>(a) &#123;                                   <span class="comment">// 檢查要執行的動作</span></span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">ACTIONS</span>.<span class="property">UP</span>:                            <span class="comment">// 向上移動</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">include</span>(<span class="title function_">row</span>(N, p - N), <span class="number">0</span>, N)) &#123;   <span class="comment">// 確認邊界範圍</span></span><br><span class="line">        nextS.<span class="title function_">swap</span>(p, p - N);                   <span class="comment">// 執行交換</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">ACTIONS</span>.<span class="property">RIGHT</span>:                         <span class="comment">// 向右移動</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="title function_">row</span>(N, p) == <span class="title function_">row</span>(N, p + <span class="number">1</span>)) &#123;          <span class="comment">// 檢查列相等</span></span><br><span class="line">        nextS.<span class="title function_">swap</span>(p, p + <span class="number">1</span>);                   <span class="comment">// 執行交換</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">ACTIONS</span>.<span class="property">DOWN</span>:                          <span class="comment">// 向下移動</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">include</span>(<span class="title function_">row</span>(N, p + N), <span class="number">0</span>, N)) &#123;   <span class="comment">// 確認邊界範圍</span></span><br><span class="line">        nextS.<span class="title function_">swap</span>(p, p + N);                   <span class="comment">// 執行交換</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable constant_">ACTIONS</span>.<span class="property">LEFT</span>:                          <span class="comment">// 向左移動</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="title function_">row</span>(N, p) == <span class="title function_">row</span>(N, p - <span class="number">1</span>)) &#123;          <span class="comment">// 確認邊界範圍</span></span><br><span class="line">        nextS.<span class="title function_">swap</span>(p, p - <span class="number">1</span>);                   <span class="comment">// 執行交換</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nextS;                                 <span class="comment">// 回傳下一個狀態</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="檢查狀態"><a href="#檢查狀態" class="headerlink" title="檢查狀態"></a>檢查狀態</h2><p>對於檢查是否完成的函數，<br>只要狀態在一個陣列中，則比對起來相當容易：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> state = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];    <span class="comment">// 初始狀態</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">let</span> goal = <span class="keyword">function</span>(<span class="params">state</span>) &#123;                <span class="comment">// 檢查結果</span></span><br><span class="line">  <span class="keyword">return</span> state.<span class="title function_">map</span>(<span class="function">(<span class="params">value, index</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value == index;                <span class="comment">// 檢查對錯</span></span><br><span class="line">  &#125;).<span class="title function_">reduce</span>(<span class="function">(<span class="params">previous, current</span>)=&gt;</span>&#123;          <span class="comment">// 全部正確才正確</span></span><br><span class="line">      <span class="keyword">return</span> previous &amp;&amp; current;           <span class="comment">// 總和結果</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>這個寫法是在 <a href="#%E8%A6%8F%E5%89%87">規則</a> 選擇表示法時確定下來的，不同的表示法有不同的檢查函數。</p>          </div><h2 id="解的類型"><a href="#解的類型" class="headerlink" title="解的類型"></a>解的類型</h2><p>所謂的解分成 2 種：</p><ul><li>普通解</li><li>最優解</li></ul><p>普通解是「不限移動多少步」只要完成盤面就可以；<br>最優解則是限制「一定要在最少步數」完成盤面。</p><p>下面兩個解都會提及。</p><h1 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h1><p>普通解法很簡單，但不太實用，<br>因為可能要很多步才能到完成盤面。</p><h2 id="狀態樹"><a href="#狀態樹" class="headerlink" title="狀態樹"></a>狀態樹</h2><p>考慮圖 9 的盤面：</p><p><img src="https://i.imgur.com/yiUwADa.png" alt="圖 9、初始盤面"></p><p>若將其下一步繪製出來，則有圖 10：</p><p><img src="https://i.imgur.com/rSXUXe2.png" alt="圖 10、盤面單層狀態樹"></p><p>這個樣貌的東西，每一個節點都是「狀態」，而整體稱作「狀態樹」<br>我們的目標，則是在這樣的分支中，尋找解答。</p><h2 id="貪婪搜索"><a href="#貪婪搜索" class="headerlink" title="貪婪搜索"></a>貪婪搜索</h2><p>這是一個 2 層的狀態樹，參考圖 11：</p><p><img src="https://i.imgur.com/OAV074x.png" alt="圖 11、盤面兩層狀態樹"></p><p>考慮到圖中狀態 $A &#x3D; D$ 且 $A &#x3D; G$ 代表我們需要紀錄已經存在的狀態，<br>否則可能陷入無窮迴圈（也可能不會，要看初始狀態。）</p><p>貪婪搜索的想法是：「哪一步更好，我就選擇哪一步。」</p><p>那麼，哪一步更好呢？考慮到我們檢查函數：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> goal = <span class="keyword">function</span>(<span class="params">state</span>) &#123;                <span class="comment">// 檢查結果</span></span><br><span class="line">  <span class="keyword">return</span> state.<span class="title function_">map</span>(<span class="function">(<span class="params">value, index</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value == index;                <span class="comment">// 檢查對錯</span></span><br><span class="line">  &#125;).<span class="title function_">reduce</span>(<span class="function">(<span class="params">previous, current</span>)=&gt;</span>&#123;          <span class="comment">// 全部正確才正確</span></span><br><span class="line">      <span class="keyword">return</span> previous &amp;&amp; current;           <span class="comment">// 總和結果</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以改寫成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">function</span>(<span class="params">state</span>) &#123;                   <span class="comment">// 檢查狀態</span></span><br><span class="line">  <span class="keyword">return</span> state.<span class="title function_">map</span>(<span class="function">(<span class="params">value, index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) &#123;                       <span class="comment">// 是否為空格</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                             <span class="comment">// 空格不算錯位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                  <span class="comment">// 不為空格</span></span><br><span class="line">      <span class="keyword">return</span> value == index ? <span class="number">1</span> : <span class="number">0</span>;        <span class="comment">// 檢查對錯</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">reduce</span>(<span class="function">(<span class="params">previous, current</span>)=&gt;</span>&#123;          <span class="comment">// 累計結果</span></span><br><span class="line">    <span class="keyword">return</span> previous + current;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如此一來，函數 $h$ 稱作「評估函數」<br>對於某一個狀態，可以評價目前的狀態「有多少錯誤的格子」<br>貪婪的兩層狀態樹，請參考圖 12。</p><p><img src="https://i.imgur.com/26Nh0U3.png" alt="圖 12、貪婪兩層狀態樹"></p><p>狀態 $A$ 在選擇下一個狀態：</p><ul><li>$h(B) &#x3D; 5$</li><li>$h(C) &#x3D; 3$</li></ul><p>所以選擇 $C$ 為下一步。同時，將狀態 $A$ 紀錄下來，<br>好在之後排除 $D$ 與 $G$ 兩個相同的狀態。</p><p>由於狀態 $C$ 下一步選擇評估最佳的 $H$ 並將 $C$ 記錄下來，<br>狀態 $H$ 選擇最佳的 $M$ 為下一步，且狀態 $M$ 選擇最佳的 $P$ 為下一步。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 求解盤面 */</span></span><br><span class="line"><span class="keyword">let</span> resolve = <span class="keyword">function</span>(<span class="params">state, h</span>) &#123;                    <span class="comment">// 給定狀態與策略</span></span><br><span class="line">  <span class="keyword">let</span> actions = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable constant_">ACTIONS</span>);                 <span class="comment">// 動作列表</span></span><br><span class="line">  <span class="keyword">let</span> bestH = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span>;                <span class="comment">// 最佳的評價值（先設最大）</span></span><br><span class="line">  <span class="keyword">let</span> bestState = <span class="literal">null</span>;                               <span class="comment">// 最佳的動作</span></span><br><span class="line">  record.<span class="title function_">push</span>(state);                                 <span class="comment">// 將目前狀態紀錄</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> actions) &#123;                             <span class="comment">// 對所有可執行的動作</span></span><br><span class="line">    <span class="keyword">let</span> nextState = <span class="title function_">move</span>(state, <span class="variable constant_">ACTIONS</span>[i]);          <span class="comment">// 生成下一步</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_">have</span>(record, nextState)) &#123;                    <span class="comment">// 檢查是否在紀錄中</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="title function_">h</span>(nextState) &lt; bestH) &#123;                      <span class="comment">// 評價是目前最佳</span></span><br><span class="line">        bestState = nextState;                        <span class="comment">// 保存最佳動作</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bestState;                                   <span class="comment">// 回傳下一個狀態</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>坦白說，這個做法很難找到解，<br>不過除了可以使不理解規則的讀者大致知道在做什麼外，<br>也為了其他方法做了事前準備。</p><h2 id="死路狀態"><a href="#死路狀態" class="headerlink" title="死路狀態"></a>死路狀態</h2><p>這個優先選擇最佳的方法，很有可能落入無路可走的狀態，<br>筆者稱之為「死路狀態」，圖 13 為死路狀態的例子。</p><p><img src="https://i.imgur.com/kCedGRl.png" alt="圖 13、死路狀態"></p><p>死路狀態容易發生在角落移動時，<br>因為往角落移動的時候，分支僅為 2 條，其中一條已經被用掉（上一狀態）<br>而若此時，另一條狀態也在先前的紀錄中，則程式便會當機。</p><p>下面列出一個最終出現死路狀態的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">...</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>] <span class="comment">// 注意此處</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>]</span><br><span class="line">...</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>死路狀態例子中，第一分支是 64 步出現的，而第二分支在 182 步，然後在 183 步進入死路狀態。</p>          </div><h2 id="隨機策略"><a href="#隨機策略" class="headerlink" title="隨機策略"></a>隨機策略</h2><p>由死路問題引出了另一個想法是：<br>「一旦搜尋不到更好且沒記錄過的解，則隨機移動一步。」</p><p>畢竟如果只搜索一層，則沒有其他資訊可以用了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 求解盤面 */</span></span><br><span class="line"><span class="keyword">let</span> resolve = <span class="keyword">function</span>(<span class="params">state, h</span>) &#123;                    <span class="comment">// 給定狀態與策略</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/* 貪婪搜索 */</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(bestState == <span class="literal">null</span>) &#123;                             <span class="comment">// 如果進入死路狀態</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*actions.<span class="property">length</span>); <span class="comment">// 隨機選一步</span></span><br><span class="line">    bestState = <span class="title function_">move</span>(state, <span class="variable constant_">ACTIONS</span>[actions[i]]);     <span class="comment">// 往下一步前進</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bestState;                                   <span class="comment">// 回傳下一個狀態</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>隨機是人工智慧的另一個慣用手法，其他例子像是隨機梯度下降（SGD）就用於跳脫局部最佳解。</p>          </div><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><iframe scrolling="no" width="100%" height="430px" src="https://jsfiddle.net/xz2n3tu1/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><div class="note warning">            <p>記憶體會隨記錄狀態而膨脹。本演示有記錄狀態的佇列上限，同時這也代表了可能找不到解。</p>          </div><h1 id="最優解法"><a href="#最優解法" class="headerlink" title="最優解法"></a>最優解法</h1><p>普通的做法需要步數太多了。<br>以至於動畫很難等到他找到解答（雖然筆者在寫文章時看到過幾次……）</p><p>所以我們需要找一個在「狀態樹」中，較短路徑的解答；<br>其中，在狀態樹中，那條最短路徑稱為「最優解」。</p><div class="note info">            <p>尋找最優解是一個 <a href="https://zh.wikipedia.org/wiki/NP%E5%9B%B0%E9%9A%BE">NP-hard</a> 問題</p>          </div><div class="note warning">            <p>最優解的意思不是速度最快，即使可以找到步數很少的解，但程式可能需要搜索很久。</p>          </div><h2 id="A-搜索"><a href="#A-搜索" class="headerlink" title="A*搜索"></a>A*搜索</h2><p>尋找最優解的過程，與先前的 <a href="#%E8%B2%AA%E5%A9%AA%E6%90%9C%E7%B4%A2">貪婪搜索</a> 類似，<br>只不過這次我們會將紀錄過的路徑拿出來使用。</p><p>原本的貪婪搜索是「選擇下一步中，最佳的狀態。」<br>而既然要挑最優解，策略變成「選擇『紀錄狀態』中，最佳的狀態。」</p><p>A* 搜索的策略，將原本的策略變成： $f(s) &#x3D; g(s) + h(s)$<br>其中 $h(s)$ 與原本貪婪搜索的函數一樣；而 $g(s)$ 代表這是第幾層的狀態，<br>狀態樹請參考圖 14。</p><p><img src="https://i.imgur.com/hqxmhmA.png" alt="圖 14、A*狀態樹"></p><p>兩個函數互相平衡的結果：</p><p>如果 $h(S_{a})$ 很棒，但 $g(S_{a})$ 很大（意味著步數很多）<br>則先不急著拓展 $S_{a}$ 狀態，找找看淺層（也就是 $g(s)$ 較小）有沒有解。</p><p>如果 $g(S_{b})$ 很小，但 $h(S_{b})$ 很糟，<br>顯然地，這個 $S_{b}$ 狀態可能距離盤面完成還有很多步，<br>則找找看有沒有 $h(s)$ 比較好的狀態。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 求解盤面 */</span></span><br><span class="line"><span class="keyword">let</span> resolve = <span class="keyword">function</span>(<span class="params">state, h</span>) &#123;                                          <span class="comment">// 給定狀態與策略</span></span><br><span class="line">  <span class="keyword">let</span> create = queue.<span class="property">node</span>;                                                  <span class="comment">// 建立優先佇列節點的函數</span></span><br><span class="line">  <span class="keyword">let</span> record = [];                                                          <span class="comment">// 紀錄的陣列</span></span><br><span class="line">  <span class="keyword">let</span> next = [];                                                            <span class="comment">// 下一步的暫存陣列</span></span><br><span class="line">  <span class="keyword">let</span> actions = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable constant_">ACTIONS</span>);                                       <span class="comment">// 動作列表</span></span><br><span class="line">  queue.<span class="title function_">insert</span>(<span class="title function_">create</span>(<span class="literal">null</span>, state, <span class="literal">null</span>, <span class="number">0</span>, <span class="title function_">h</span>(state)));                     <span class="comment">// 將初始狀態加入優先佇列</span></span><br><span class="line">  <span class="keyword">while</span>(!queue.<span class="title function_">empty</span>()) &#123;                                                   <span class="comment">// 優先佇列不為空</span></span><br><span class="line">    <span class="keyword">let</span> node = queue.<span class="title function_">get</span>();                                                 <span class="comment">// 從優先佇列取得一個節點</span></span><br><span class="line">    <span class="keyword">let</span> state = node.<span class="property">state</span>;                                                 <span class="comment">// 取得當前節點的狀態</span></span><br><span class="line">    record.<span class="title function_">push</span>(node);                                                      <span class="comment">// 將目前狀態紀錄</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">goal</span>(state)) &#123;                                                       <span class="comment">// 已經完成</span></span><br><span class="line">      <span class="keyword">return</span> record;                                                        <span class="comment">// 將所有狀態返回（建立動畫）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> recordStates = record.<span class="title function_">map</span>(<span class="function">(<span class="params">node</span>)=&gt;</span>node.<span class="property">state</span>);                      <span class="comment">// 取得所有紀錄的狀態</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> actions) &#123;</span><br><span class="line">      <span class="keyword">let</span> action = <span class="variable constant_">ACTIONS</span>[i];</span><br><span class="line">      <span class="keyword">let</span> nextStates = <span class="title function_">move</span>(state, action);                                 <span class="comment">// 生成下一步</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">have</span>(recordStates, nextStates)) &#123;                                <span class="comment">// 檢查是否在紀錄中</span></span><br><span class="line">        <span class="keyword">let</span> g = node.<span class="property">g</span> + <span class="number">1</span>;                                                 <span class="comment">// 這步的深度遞增（即下一層）</span></span><br><span class="line">        <span class="keyword">if</span> (g &gt;= maxDeep) &#123;                                                 <span class="comment">// 防止搜索過深（預防當機）</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.<span class="title function_">insert</span>(<span class="title function_">create</span>(node, nextStates, action, g, <span class="title function_">h</span>(nextStates)));   <span class="comment">// 將下一步全部插入優先佇列</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> record;                                                            <span class="comment">// 超出深度時直接把紀錄返回</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="優先佇列"><a href="#優先佇列" class="headerlink" title="優先佇列"></a>優先佇列</h2><p>A*搜索實作的重點之一是如何實現優先佇列；<br>一個簡單的方法是透過插入排序，在適當的位置插入狀態。</p><div class="note success">            <p>請參考：<a href="/sort/" title="排序 Sort">排序 Sort</a></p>          </div><p>不過在這裡，我們透過堆積完成優先佇列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 優先佇列 */</span></span><br><span class="line"><span class="keyword">let</span> queue = &#123;</span><br><span class="line">  <span class="attr">heap</span>: [&#123;<span class="attr">f</span>: -<span class="number">1</span>&#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 清除佇列 */</span></span><br><span class="line">  <span class="attr">clear</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span> = [&#123;<span class="attr">f</span>: -<span class="number">1</span>&#125;];</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 判斷佇列為空 */</span></span><br><span class="line">  <span class="attr">empty</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !(<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> &gt; <span class="number">1</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 重整佇列函數 */</span></span><br><span class="line">  <span class="attr">restore</span>: <span class="keyword">function</span>(<span class="params">node, leaf</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((node * <span class="number">2</span>) &lt;= leaf) &#123;                                            <span class="comment">// 樹的倒數二層之內</span></span><br><span class="line">      <span class="keyword">let</span> left = <span class="number">2</span> * node;                                                  <span class="comment">// 取得左子節點</span></span><br><span class="line">      <span class="keyword">let</span> right = <span class="number">2</span> * node + <span class="number">1</span>;                                             <span class="comment">// 取得右子節點</span></span><br><span class="line">      <span class="keyword">if</span> (right &gt; leaf) &#123;                                                   <span class="comment">// 超出葉子</span></span><br><span class="line">        right = left;                                                       <span class="comment">// 使左、右節點相等</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> target;                                                           <span class="comment">// 暫存節點</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heap</span>[left].<span class="property">f</span> &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[right].<span class="property">f</span>) &#123;                         <span class="comment">// 根據節點的 f(s) 值排序</span></span><br><span class="line">        target = left;                                                      <span class="comment">// 往左子節點去</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        target = right;                                                     <span class="comment">// 往右子節點去</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">heap</span>[node].<span class="property">f</span> &lt; <span class="variable language_">this</span>.<span class="property">heap</span>[target].<span class="property">f</span>) &#123;                        <span class="comment">// 順序是對的直接跳出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">swap</span>(node, target);                                         <span class="comment">// 往下交換節點</span></span><br><span class="line">      node = target;                                                        <span class="comment">// 前往子節點</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 插入節點 */</span></span><br><span class="line">  <span class="attr">insert</span>: <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">push</span>(node);                                                   <span class="comment">// 先直接塞進駐列</span></span><br><span class="line">    <span class="keyword">let</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>;                                           <span class="comment">// 從葉子開始整理佇列</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="title class_">Math</span>.<span class="title function_">floor</span>(i / <span class="number">2</span>)].<span class="property">f</span> &gt; node.<span class="property">f</span>;                            <span class="comment">// 根據節點的 f(x) 值處理</span></span><br><span class="line">        i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(i / <span class="number">2</span>)) &#123;                                            <span class="comment">// 往父節點整理</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">heap</span>[i] = <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="title class_">Math</span>.<span class="title function_">floor</span>(i / <span class="number">2</span>)];                          <span class="comment">// 父節點覆寫子節點</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>[i] = node;                                                    <span class="comment">// 在正確的位置插入</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 取得最小 f(x) 值的節點*/</span></span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">1</span>];                                                <span class="comment">// 樹根就是最小，取得樹根的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="number">1</span>] = <span class="variable language_">this</span>.<span class="property">heap</span>[<span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>];                         <span class="comment">// 把樹根移到葉子的位置上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="title function_">pop</span>();                                                        <span class="comment">// 把樹葉摘除</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">restore</span>(<span class="number">1</span>, <span class="variable language_">this</span>.<span class="property">heap</span>.<span class="property">length</span> - <span class="number">1</span>);                                  <span class="comment">// 從樹根開始重整堆積</span></span><br><span class="line">    <span class="keyword">return</span> node;                                                            <span class="comment">// 把最小節點回傳</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 節點的結構 */</span></span><br><span class="line">  <span class="attr">node</span>: <span class="keyword">function</span>(<span class="params">previous, state, action, g, h</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">previous</span>: previous,                                                   <span class="comment">// 來源的節點</span></span><br><span class="line">      <span class="attr">state</span>: state,                                                         <span class="comment">// 狀態陣列</span></span><br><span class="line">      <span class="attr">action</span>: action,                                                       <span class="comment">// 實行的動作</span></span><br><span class="line">      <span class="attr">g</span>: g,                                                                 <span class="comment">// g(x) 值，紀錄的深度</span></span><br><span class="line">      <span class="attr">f</span>: f                                                                  <span class="comment">// f(x) 值（f = g + h）</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>優先佇列不能取代紀錄陣列，原因是優先佇列會將最小節點丟出去拓展，紀錄會被破壞；<br>反之，如果持續保留最小節點，則根本無法拓展狀態樹。</p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p>與上一個演示不同，這個演示給讀者調整參數。<br>參數中最重要的是「Maximum deep」代表可以搜索的深度，<br>有時候解答藏在很深的狀態樹中，根據 <a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%97%E6%8E%A8%E7%9B%A4%E9%81%8A%E6%88%B2">wikipedia: 數字推盤遊戲</a> 的內容；<br>可以得知 3x3 的解，最深會藏在 31 層以內。</p><p>也就是說，當「Maximum deep &#x3D; 31」時，必有解；<br>但至於執行時間可能相當長（瀏覽器可能會當成沒有回應）。</p><iframe scrolling="no" width="100%" height="530px" src="https://jsfiddle.net/p8ghq1ds/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><div class="note danger">            <p>深度很深時，執行速度可能很慢。</p>          </div>]]></content>
      
      
      <categories>
          
          <category> 人工智慧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 Cordova Android APP 環境配置</title>
      <link href="//HTML5-Cordova-Android-APP-1/"/>
      <url>//HTML5-Cordova-Android-APP-1/</url>
      
        <content type="html"><![CDATA[<p>這篇是紀錄一個基於 HTML5 的 Android APP 開發流程。</p><p>雖然筆者常常寫 HTML、CSS 以及 JavaScript 程式，<br>也聽說 HTML5 對 APP 開發速度的幫助很大，但從未有自己的 APP 上架。</p><span id="more"></span><p>這篇文章將介紹 Cordova 的環境配置。</p><div class="note info">            <p>本篇預設讀者都已掌握開發技術，不會介紹 Web 程式的撰寫。</p>          </div><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>開發環境的配置需要安裝：</p><ul><li>Node.js</li><li>Cordova</li><li>Java Development Kit (JDK)</li><li>Android Software Development Kit (SDK)</li></ul><table><thead><tr><th align="left">名稱</th><th align="left">功能</th><th align="left">下載網站</th></tr></thead><tbody><tr><td align="left">Node.js</td><td align="left">Cordova 在 Node.js 的命令列上執行</td><td align="left"><a href="https://nodejs.org/en/">Node.js</a></td></tr><tr><td align="left">Cordova</td><td align="left">將 Web 專案部屬到指定行動裝置平台</td><td align="left"><a href="https://cordova.apache.org/">Apache Cordova</a></td></tr><tr><td align="left">Java Development Kit (JDK)</td><td align="left">Cordova 新增、部屬 Android 平台時需要</td><td align="left"><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle Technology Network</a></td></tr><tr><td align="left">Android Software Development Kit (SDK)</td><td align="left">Cordova 新增、部屬 Android 平台時需要</td><td align="left"><a href="https://developer.android.com/studio/">Android Developers</a></td></tr><tr><td align="left">Gradle*</td><td align="left">Android 的官方構建工具</td><td align="left"><a href="https://gradle.org/">Gradle Build Tool</a></td></tr></tbody></table><div class="note info">            <p>SDK 及 Gradle 的下載有無需要，請在 <a href="#%E5%AE%89%E8%A3%9D-SDK">安裝 SDK</a> 的章節中確認。</p>          </div><div class="note info">            <p>筆者接下來會將 Java Development Kit 簡稱為 JDK；而 Android Software Development Kit 簡稱為 SDK。</p>          </div><h1 id="安裝-Node-js"><a href="#安裝-Node-js" class="headerlink" title="安裝 Node.js"></a>安裝 Node.js</h1><p>先到 <a href="https://nodejs.org/en/">Node.js 官網</a> 下載 Node.js，<br>官網左邊的 LTS 表示推薦的穩定版本、而右邊的 Current 表示最新的版本，<br>官網畫面請參考圖 1，筆者這邊使用的是 LTS 版本：</p><p><img src="https://i.imgur.com/MPA5e7Ql.png" alt="圖 1、Node.js 官網示意圖"></p><p>然後安裝 Node.js 的部分，不會花太多時間，跟一般的安裝差不多。<br>安裝好後，透過下列指令測試正確安裝，畫面請參考圖 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/ftOp2ZBl.png" alt="圖 2、Node.js 測試示意圖"></p><div class="note info">            <p>通常情況下，可能 Node.js 版本與筆者不同，但操作應該大同小異。</p>          </div><h1 id="安裝-Cordova"><a href="#安裝-Cordova" class="headerlink" title="安裝 Cordova"></a>安裝 Cordova</h1><p>在 <a href="https://cordova.apache.org/">Apache Cordova</a> 官網有說明絕大多數操作，<br>透過 npm 安裝 Cordova 即可，指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cordova</span><br></pre></td></tr></table></figure><p>安裝好後，一樣透過指令測試，畫面請參考圖 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova --version</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/U2FzEL5l.png" alt="圖 3、測試 Cordova 示意圖"></p><p>上圖是安裝完後，透過指令測試的</p><div class="note info">            <p>Node Package Manager (npm) 是 Node.js 預設的套件包管理器；其中參數 -g 代表全局安裝。</p>          </div><h1 id="安裝-JDK"><a href="#安裝-JDK" class="headerlink" title="安裝 JDK"></a>安裝 JDK</h1><p>接著到 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle Technology Network</a> 網站，<br>下載 JDK，如圖 4 所示，注意下圖中藍框的同意條款要勾選才能下載：</p><p><img src="https://i.imgur.com/MVsvsq5l.png" alt="圖 4、下載 JDK 示意圖"></p><p>注意兩個安裝的路徑：</p><ul><li>JDK</li><li>Java Runtime Environment (JRE)</li></ul><p>這兩個路徑可能之後會使用到，務必記下來，<br>預設路徑是「C:\Program Files\Java\」或「C:\Program Files (x86)\Java\」。</p><h1 id="安裝-SDK"><a href="#安裝-SDK" class="headerlink" title="安裝 SDK"></a>安裝 SDK</h1><p>安裝 SDK 的部分，可以分成兩個方法：</p><ul><li>使用 Android Studio 附帶的 SDK 包</li><li>獨立安裝 SDK Tools 與 SDK Platform Tools</li></ul><p>如果已經安裝過 Android Studio 的話，就直接使用其附帶的 SDK 即可；<br>反之，如果沒有安裝過 Android Studio；且未來也不打算安裝，則推薦獨立安裝 SDK。<br>（如果讀者覺得可能會使用到 Android Studio 則建議安裝。）</p><p>安裝好 Android Studio 時，應該會指定安裝 SDK 的位置；<br>獨立下載時，解壓縮到喜歡的目錄下即可。</p><p>獨立安裝 SDK Tools 的下載網址：<a href="https://developer.android.com/studio/">Android Developers</a><br>此外，要再下載 SDK Platform Tools，網址：<a href="https://developer.android.com/studio/releases/platform-tools">SDK Platform Tools Release</a></p><h1 id="安裝-Gradle"><a href="#安裝-Gradle" class="headerlink" title="安裝 Gradle"></a>安裝 Gradle</h1><p>這個部分同樣取決於是否安裝 Android Studio：</p><ul><li>使用 Android Studio 附帶的 Gradle</li><li>獨立安裝 Gradle</li></ul><p>與 SDK 的狀況一樣，至於 Android Studio 安裝時，<br>不會另外讓你設定 Gradle 的安裝位置，預設在「Android Studio\gradle\gradle-x.x」<br>（其中 x.x 為 Gradle 的版本號。）</p><h1 id="配置環境變數"><a href="#配置環境變數" class="headerlink" title="配置環境變數"></a>配置環境變數</h1><p>接下來是比較容易出錯的部分，<br>由於安裝了很多東西，有一些自動幫你配置環境變數；有些則無。<br>我們需要配置的環境變數如下：</p><table><thead><tr><th>來源軟體</th><th>配置方法</th><th>環境變數名稱</th><th>環境變數位置</th></tr></thead><tbody><tr><td>Node.js</td><td>安裝 Node.js 時自動配置</td><td>Path（系統變數）</td><td>nodejs\</td></tr><tr><td>Node.js (npm)</td><td>安裝 Node.js 時自動配置</td><td>Path（使用者變數）</td><td>AppData\Roaming\npm\</td></tr><tr><td>Cordova</td><td>透過 npm 呼叫</td><td>無</td><td>無</td></tr><tr><td>JDK</td><td>使用者手動配置</td><td>JAVA_HOME（使用者變數）</td><td>jdk1.8.0_171\</td></tr><tr><td>SDK Tools（A.S. 附帶）</td><td>使用者手動配置</td><td>ANDROID_HOME（使用者變數）</td><td>SDK\</td></tr><tr><td>SDK Tools（獨立安裝）</td><td>使用者手動配置</td><td>ANDROID_HOME（使用者變數）</td><td>SDK\</td></tr><tr><td>SDK Platform Tools（A.S. 附帶）</td><td>使用者手動配置</td><td>Path（系統變數）</td><td>platform-tools\</td></tr><tr><td>SDK Platform Tools（獨立安裝）</td><td>使用者手動配置</td><td>Path（系統變數）</td><td>platform-tools\</td></tr><tr><td>SDK Tools（A.S. 附帶）</td><td>使用者手動配置</td><td>Path（使用者變數）</td><td>tools\bin\</td></tr><tr><td>SDK Tools（獨立安裝）</td><td>使用者手動配置</td><td>Path（使用者變數）</td><td>tools\bin\</td></tr><tr><td>Gradle（A.S. 附帶）</td><td>使用者手動配置</td><td>Path（系統變數）</td><td>gradle\gradle-x.x\bin\</td></tr><tr><td>Gradle（獨立安裝）</td><td>使用者手動配置</td><td>Path（系統變數）</td><td>gradle-x.x\</td></tr></tbody></table><div class="note info">            <p>記號「A.S.」表示「Android Studio」</p>          </div><div class="note warning">            <p>環境變數位置為相對位置，請依照安裝時設定的位置為準。</p>          </div><h1 id="測試環境變數"><a href="#測試環境變數" class="headerlink" title="測試環境變數"></a>測試環境變數</h1><p>這裡提供一個檢測環境變數的方法，<br>在這裡使用的 Cordova 專案可能不是最終使用的專案。</p><p>首先到自己喜歡的目錄下，透過指令建立 Cordova 專案，<br>其中 myApp 為自訂的專案名稱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova create myApp</span><br></pre></td></tr></table></figure><p>然後將進入建立好的目錄，透過指令將 Android 加入部屬的平台：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myApp</span><br><span class="line">cordova platform add android</span><br></pre></td></tr></table></figure><p>然後透過指令檢測環境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cordova requirements</span><br></pre></td></tr></table></figure><p>整個操作的示意如圖 5，<br>如果有錯誤，應該會提示哪裡沒有配置好：<br><img src="https://i.imgur.com/cglnTXb.png" alt="圖 5、檢測命令示意圖"></p>]]></content>
      
      
      <categories>
          
          <category> 行動裝置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊羽手札更新歷程 02</title>
      <link href="//tinytsunami-update-02/"/>
      <url>//tinytsunami-update-02/</url>
      
        <content type="html"><![CDATA[<p>這學期一開始還好，期中之後就很忙，<br>這個部落格也就在後半學期暫緩一下子了。</p><p>隨暑假的到來，雖然還是有很多事情，<br>但筆者又開始比較有空了，會趁暑假會繼續寫新文章。</p><span id="more"></span><h1 id="更新歷程"><a href="#更新歷程" class="headerlink" title="更新歷程"></a>更新歷程</h1><ul><li>2016.10.24 羊羽手札v1（PHP）</li><li>2017.12.18 羊羽手札v2（Vue.js+Express）</li><li>2017.02.25 羊羽手札v3（Hexo）</li><li>2017.02.25 更新歷程 01 發表</li><li>2018.07.01 更新歷程 02 發表</li></ul><h1 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h1><p>到目前為止，羊羽手札感覺還可以，<br>很多文章沒有發表的原因是很懶得打 LaTeX 公式。</p><p>下一幾篇「預計」會是：</p><ul><li>推盤遊戲 N-puzzle</li><li>全連接神經網路 Fully Connected Neural Network</li><li>前、中及後序 Preorder, Inorder and Postorder</li><li>…</li></ul><p>這學期上了人工智慧（古典）的內容，<br>其中包含了「推盤遊戲 N-puzzle」的搜索與解法。</p><p>考完期末考的時候，就已經把演示的核心大致寫好了，<br>但動畫真的不好做，而且可能還需要改一些程式碼才能發表。</p><p>全連接神經網路是舊坑，很早就該寫了，<br>只是對反向傳播演算法的推導，沒自信可以寫得很容易懂，<br>另外公式不好打（矩陣的部分）</p><h1 id="禮物演示"><a href="#禮物演示" class="headerlink" title="禮物演示"></a>禮物演示</h1><p>真的很感謝讀者的支持（雖然我不知道有誰 XD）<br>這個原本是「<a href="/HTML5-Cordova-Android-APP-1/" title="HTML5 Cordova Android APP 環境配置">HTML5 Cordova Android APP 環境配置</a>」文章續篇所使用的演示。</p><p>本來是要做成 Missile Command 的文青版，也就是「雨輕輕的飄落在屏幕上」的感覺，<br>後來關卡設計做一做，變成除了下雨，還加了黑雨（小說《黒い雨》）及隕石撞地球。</p><p>最後腦洞開太大，後來就只做成類似遊戲畫面的東西了。<br>（這張照片是筆者拍的，是我們學校後山。）</p><iframe scrolling="no" width="100%" height="520px" src="https://jsfiddle.net/8epx9rvo/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 羊羽手札 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高斯喬登消去法 Gauss-Jordan Elimination</title>
      <link href="//Gauss-Jordan-elimination/"/>
      <url>//Gauss-Jordan-elimination/</url>
      
        <content type="html"><![CDATA[<p>這篇文章是某同學跟我說消去法不好寫，所以才出現的，<br>原本當初在上線性代數時，其實也有這樣的感覺，覺得消去法的細節有點多。</p><p>想清楚之後就覺得消去法本身不會很困難，精度的維持才是最艱難之處。</p><span id="more"></span><h1 id="矩陣運算"><a href="#矩陣運算" class="headerlink" title="矩陣運算"></a>矩陣運算</h1><p>消去法有一些基本運算，包含：</p><ol><li>交換 A、B 兩個列</li><li>將一列 A 加到另一列 B</li><li>將一列 A 乘上一個倍數 c</li></ol><p>此外，建立「增廣矩陣」也要處理。</p><div class="note warning">            <p>注意這裡使用「直行橫列」意即列（Row）與行（Column）</p>          </div><h2 id="增廣矩陣"><a href="#增廣矩陣" class="headerlink" title="增廣矩陣"></a>增廣矩陣</h2><p>輸入係數矩陣 M 與列向量 b 建立增廣矩陣 A。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 取得增廣矩陣</span></span><br><span class="line"><span class="comment"> * 輸入係數矩陣 M 及列向量 b 組合</span></span><br><span class="line"><span class="comment"> * 回傳增廣矩陣 A</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> augmented = <span class="keyword">function</span>(<span class="params">M, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> A = <span class="title class_">Array</span>.<span class="title function_">from</span>(M, <span class="keyword">function</span>(<span class="params">v, k</span>) &#123;  <span class="comment">// 建立增廣矩陣 A</span></span><br><span class="line">    <span class="keyword">return</span> v.<span class="title function_">concat</span>(b[k]);                <span class="comment">// 將 M 的每一列都加上 b 的列</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> A;                               <span class="comment">// 回傳增廣矩陣 A</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>為了某些時候需要，<br>也可以撰寫將增廣矩陣 A 分解成係數矩陣 M 與列向量 b 的函數。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分解增廣矩陣</span></span><br><span class="line"><span class="comment"> * 輸入增廣矩陣 A 分解</span></span><br><span class="line"><span class="comment"> * 回傳為包含係數矩陣 M 及列向量 b 的物件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> unaugmented = <span class="keyword">function</span>(<span class="params">A</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;                                <span class="comment">// 回傳包含 M 及 b 的物件</span></span><br><span class="line">    <span class="attr">M</span>: <span class="title class_">Array</span>.<span class="title function_">from</span>(A, <span class="keyword">function</span>(<span class="params">r</span>) &#123;        <span class="comment">// 從增廣矩陣 A 建立</span></span><br><span class="line">      <span class="keyword">return</span> r.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v, i</span>) &#123;    <span class="comment">// 過濾掉 A 每一列的最後一個元素則為係數矩陣 M</span></span><br><span class="line">        <span class="keyword">return</span> i != (r.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">b</span>: <span class="title class_">Array</span>.<span class="title function_">from</span>(A, <span class="keyword">function</span>(<span class="params">r</span>) &#123;        <span class="comment">// 從增廣矩陣 A 建立</span></span><br><span class="line">      <span class="keyword">return</span> r.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">v, i</span>) &#123;    <span class="comment">// 過濾掉非 A 每一列的最後一個元素則為列向量 b</span></span><br><span class="line">        <span class="keyword">return</span> i == (r.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="兩列交換"><a href="#兩列交換" class="headerlink" title="兩列交換"></a>兩列交換</h2><p>交換兩個列，多用於軸（pivot）為零的情況。</p><div class="note info">            <p>「樞」為 pivot 而「軸」為 axis；<br>不過這裡的軸是指 pivot 才對，鑒於溝通上不太使用「樞」故此用「軸」稱呼。</p>          </div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 兩列交換</span></span><br><span class="line"><span class="comment"> * 輸入矩陣 A 交換 a 及 b 兩列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> exchange = <span class="keyword">function</span>(<span class="params">A, a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> T = <span class="title class_">Array</span>.<span class="title function_">from</span>(A[a]);               <span class="comment">// 複製第 a 列</span></span><br><span class="line">  A[a] = A[b];                            <span class="comment">// 令第 a 列為第 b 列</span></span><br><span class="line">  A[b] = T;                               <span class="comment">// 令第 b 列為複製的 a 列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="兩列加法"><a href="#兩列加法" class="headerlink" title="兩列加法"></a>兩列加法</h2><p>將一列乘上一個倍數加到另一列上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 兩列加法</span></span><br><span class="line"><span class="comment"> * 輸入矩陣 A 將第 a 列乘 scalar 加到第 b 列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> addition = <span class="keyword">function</span>(<span class="params">A, a, b, scalar</span>) &#123;</span><br><span class="line">  A[b] = A[b].<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">v, k</span>) &#123;        <span class="comment">// 使第 b 列變化</span></span><br><span class="line">    <span class="keyword">return</span> v + A[a][k] * scalar;          <span class="comment">// 將第 a 列乘 scalar 加上</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="單列縮放"><a href="#單列縮放" class="headerlink" title="單列縮放"></a>單列縮放</h2><p>將一列乘上一個常數。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 單列縮放</span></span><br><span class="line"><span class="comment"> * 輸入矩陣 A 將第 a 列乘上 scalar</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> scalar = <span class="keyword">function</span>(<span class="params">A, a, scalar</span>) &#123;</span><br><span class="line">  A[a] = A[a].<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">v, k</span>) &#123;        <span class="comment">// 將第 a 列變化</span></span><br><span class="line">    <span class="keyword">return</span> v * scalar;                    <span class="comment">// 將元素乘上 scalar</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="消去法"><a href="#消去法" class="headerlink" title="消去法"></a>消去法</h1><p>通過剛剛寫的副程式，可以使消去法變得更容易完成，<br>但考慮到一些情形，必須要在撰寫一些函數。</p><h2 id="取得軸"><a href="#取得軸" class="headerlink" title="取得軸"></a>取得軸</h2><p>取得矩陣 A 的從第 k 列開始的軸。<br>考慮到如果當前軸那個位置的元素為零，這個函數可以幫我們找到可以交換的列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 取得軸</span></span><br><span class="line"><span class="comment"> * 輸入矩陣 A 及第 k 列</span></span><br><span class="line"><span class="comment"> * 建立一個 row(A) - k 長度的陣列</span></span><br><span class="line"><span class="comment"> * 陣列元素值 e 為第 k 列開始第 e 行元素不為零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> findPivots = <span class="keyword">function</span>(<span class="params">A, k</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;</span><br><span class="line">    <span class="attr">length</span>: (A.<span class="property">length</span> - k)                        <span class="comment">// 建立長度為 row(A) - k 的陣列</span></span><br><span class="line">  &#125;, <span class="keyword">function</span>(<span class="params">e, i</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; A[k + i].<span class="property">length</span>; j++) &#123;   <span class="comment">// 遍歷 A 第 k + i 列的每個元素</span></span><br><span class="line">      <span class="keyword">if</span> (A[k + i][j] != <span class="number">0</span>) &#123;                     <span class="comment">// 如果 A 第 k + i 列的第 j 個元素不為零</span></span><br><span class="line">        <span class="keyword">return</span> j;                                 <span class="comment">// 返回 j</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>].<span class="property">length</span>;                           <span class="comment">// 第 k + i 列的所有元素都為零返回行的數量</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這個函數是之後消去法的關鍵，也是最難理解的部分。<br>為幫助理解可以看一個例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = [[ <span class="number">0</span>, -<span class="number">2</span>,  <span class="number">4</span>,  <span class="number">7</span>],</span><br><span class="line">         [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">5</span>,  <span class="number">8</span>],</span><br><span class="line">         [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">3</span>, -<span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line"><span class="title function_">findPivots</span>(A, <span class="number">0</span>);   <span class="comment">// [1, 2, 4, 0]</span></span><br><span class="line"><span class="title function_">findPivots</span>(A, <span class="number">1</span>);   <span class="comment">// [4, 2, 0]</span></span><br><span class="line"><span class="title function_">findPivots</span>(A, <span class="number">2</span>);   <span class="comment">// [4, 0]</span></span><br><span class="line"><span class="title function_">findPivots</span>(A, <span class="number">3</span>);   <span class="comment">// [0]</span></span><br></pre></td></tr></table></figure><p>之所以有這個函數，考慮如果第 k 列的軸為零，<br>只要透過這個函數取得從第 k 列開始的軸，找到陣列中最小值交換就好。</p><p>考慮剛才的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">0</span>, -<span class="number">2</span>,  <span class="number">4</span>,  <span class="number">7</span>],</span><br><span class="line"> [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">5</span>,  <span class="number">8</span>],</span><br><span class="line"> [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line"> [ <span class="number">3</span>, -<span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><p>其中第 0 列的軸位置為零，故計算第 0 列開始的軸位置為 [1, 2, 4, 0]<br>最小值為 0 註標為 3 則交換第 0 列與第 3 列。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">3</span>, -<span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line"> [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">5</span>,  <span class="number">8</span>],</span><br><span class="line"> [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line"> [ <span class="number">0</span>, -<span class="number">2</span>,  <span class="number">4</span>,  <span class="number">7</span>]]</span><br></pre></td></tr></table></figure><p>同樣的，再換一次為：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">3</span>, -<span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line"> [ <span class="number">0</span>, -<span class="number">2</span>,  <span class="number">4</span>,  <span class="number">7</span>],</span><br><span class="line"> [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line"> [ <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">5</span>,  <span class="number">8</span>]]</span><br></pre></td></tr></table></figure><h2 id="最小值註標"><a href="#最小值註標" class="headerlink" title="最小值註標"></a>最小值註標</h2><p>取得最小值註標是個簡單的功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 取得陣列最小值的註標</span></span><br><span class="line"><span class="comment"> * 輸入陣列 arr 最小值為 arr[i] 回傳 i</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> minIndex = <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;                          <span class="comment">// 假設最小值註標為 0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;   <span class="comment">// 遍歷陣列</span></span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt; arr[index]) &#123;             <span class="comment">// 如果值更小</span></span><br><span class="line">      index = i;                          <span class="comment">// 改變最小值註標</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> index;                           <span class="comment">// 回傳最小值註標</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="高斯部分"><a href="#高斯部分" class="headerlink" title="高斯部分"></a>高斯部分</h2><p>消去法的這個部分主要是將下三角的元素變為零，<br>即使矩陣 A 變成上三角矩陣。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 高斯消去法</span></span><br><span class="line"><span class="comment"> * 輸入增廣矩陣 A 使之變成上三角矩陣</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Gauss</span> = <span class="keyword">function</span>(<span class="params">A</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> m = A.<span class="property">length</span>;                               <span class="comment">// A 有 m 個列</span></span><br><span class="line">  <span class="keyword">let</span> n = A[<span class="number">0</span>].<span class="property">length</span>;                            <span class="comment">// A 有 n 個行</span></span><br><span class="line">  <span class="keyword">let</span> r = <span class="title class_">Math</span>.<span class="title function_">min</span>(m, n);                         <span class="comment">// A 最大會有 r 個軸</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;                   <span class="comment">// 對第 i 個列操作</span></span><br><span class="line">    <span class="keyword">let</span> pivots = <span class="title function_">findPivots</span>(A, i);                <span class="comment">// 計算從第 i 列開始的軸位置</span></span><br><span class="line">    <span class="keyword">let</span> p = &#123;                                     <span class="comment">// 建立目前軸 p 的位置</span></span><br><span class="line">      <span class="attr">i</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">j</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    p.<span class="property">i</span> = <span class="title function_">minIndex</span>(pivots);                       <span class="comment">// 取得最小軸位置的列</span></span><br><span class="line">    p.<span class="property">j</span> = pivots[p.<span class="property">i</span>];                            <span class="comment">// 取得最小軸位置</span></span><br><span class="line">    <span class="keyword">if</span> (p.<span class="property">j</span> == n) &#123;                               <span class="comment">// p.j 為 n 即整列是零</span></span><br><span class="line">      <span class="keyword">return</span>;                                     <span class="comment">// 已經不能再做下去了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">exchange</span>(A, i, i + p.<span class="property">i</span>);                      <span class="comment">// 交換最小軸位置的列到本列</span></span><br><span class="line">    <span class="title function_">scalar</span>(A, i, <span class="number">1</span> / A[i][p.<span class="property">j</span>]);                  <span class="comment">// 縮放本列的大小使軸為 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; m; j++) &#123;             <span class="comment">// 遍歷軸下面的列</span></span><br><span class="line">      <span class="title function_">addition</span>(A, i, j, -A[j][p.<span class="property">j</span>] / A[i][p.<span class="property">j</span>]);  <span class="comment">// 將其變為 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="喬登部分"><a href="#喬登部分" class="headerlink" title="喬登部分"></a>喬登部分</h2><p>消去法的這個部分是透過代入法，<br>使矩陣 A 只有對角線上的元素有值（且為 1）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代入法</span></span><br><span class="line"><span class="comment"> * 重複代入使軸上方元素為零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Jordan</span> = <span class="keyword">function</span>(<span class="params">A</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> m = A.<span class="property">length</span>;                               <span class="comment">// A 有 m 個列</span></span><br><span class="line">  <span class="keyword">let</span> n = A[<span class="number">0</span>].<span class="property">length</span>;                            <span class="comment">// A 有 n 個行</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;              <span class="comment">// 對第 i 個列操作</span></span><br><span class="line">    <span class="keyword">let</span> pivots = <span class="title function_">findPivots</span>(A, i);                <span class="comment">// 計算從第 i 列開始的軸位置</span></span><br><span class="line">    <span class="keyword">let</span> p = &#123;                                     <span class="comment">// 建立目前軸 p 的位置</span></span><br><span class="line">      <span class="attr">i</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">j</span>: pivots[<span class="number">0</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span>(p.<span class="property">j</span> == n) &#123;                                <span class="comment">// p.j 為 n 即整列是零</span></span><br><span class="line">      <span class="keyword">continue</span>;                                   <span class="comment">// 跳過這個列</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;            <span class="comment">// 遍歷軸上面的列</span></span><br><span class="line">      <span class="title function_">addition</span>(A, i, j, -A[j][p.<span class="property">j</span>] / A[i][p.<span class="property">j</span>]);  <span class="comment">// 將其變為 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="除錯技巧"><a href="#除錯技巧" class="headerlink" title="除錯技巧"></a>除錯技巧</h1><p>這裡整理一些除錯的技巧。</p><h2 id="自動測資"><a href="#自動測資" class="headerlink" title="自動測資"></a>自動測資</h2><p>人工設定測資可能也可以完成，<br>但如果能自動生成測資的話，就可以做比較大量的測試。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 產生測資矩陣</span></span><br><span class="line"><span class="comment"> * 建立大小為 (m, n) 的矩陣 M 及大小為 (m, 1) 的列向量 b</span></span><br><span class="line"><span class="comment"> * 組合出元素值 [a, b] 整數的增廣矩陣 A</span></span><br><span class="line"><span class="comment"> * 其中 m 與 n 為 [4, 7]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> generateMatrix = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> v = <span class="keyword">function</span>(<span class="params"></span>) &#123;                                <span class="comment">// 取得述職的函數</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (b - a)) + a;   <span class="comment">// 數值為 [a, b]</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span>) + <span class="number">4</span>;          <span class="comment">// 取得 m = [4, 7]</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">3</span>) + <span class="number">4</span>;          <span class="comment">// 取得 n = [4, 7]</span></span><br><span class="line">  <span class="keyword">let</span> M = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: m&#125;, <span class="keyword">function</span>(<span class="params"></span>) &#123;        <span class="comment">// 建立矩陣 M</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: n&#125;, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">v</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">let</span> b = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: m&#125;, <span class="keyword">function</span>(<span class="params"></span>) &#123;        <span class="comment">// 建立列向量 b</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">v</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  A = <span class="title function_">augmented</span>(M, b);                                <span class="comment">// 組合出增廣矩陣 A</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>) &#123;                           <span class="comment">// 是否建立空列</span></span><br><span class="line">    <span class="title function_">scalar</span>(A, <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m), <span class="number">0</span>);      <span class="comment">// 使隨機一列元素為 0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span>) &#123;                           <span class="comment">// 是否建立相同列</span></span><br><span class="line">    <span class="keyword">let</span> z = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m);            <span class="comment">// 使隨機一列 z 等於另一列</span></span><br><span class="line">    <span class="title function_">scalar</span>(A, z, <span class="number">0</span>);                                  <span class="comment">// 先使 z 列變成 0</span></span><br><span class="line">    <span class="title function_">addition</span>(A, <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * m), z, <span class="number">1</span>); <span class="comment">// 隨機找一列加到 z 列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> A;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="印出矩陣"><a href="#印出矩陣" class="headerlink" title="印出矩陣"></a>印出矩陣</h2><p>陣列在 JavaScript 中屬於參考的變數，<br>意思是，如果寫的方法為：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A);</span><br><span class="line"><span class="comment">/* 更改 A 矩陣（陣列） */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>則兩個輸出會完全一樣。<br>為了正常印出矩陣，可以建立矩陣的副本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A.<span class="title function_">slice</span>());</span><br><span class="line"><span class="comment">/* 更改 A 矩陣（陣列） */</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A.<span class="title function_">slice</span>());</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><iframe scrolling="no" width="100%" height="460px" src="https://jsfiddle.net/6j4ru96n/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 線性代數 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>五子棋 Gomoku</title>
      <link href="//gomoku/"/>
      <url>//gomoku/</url>
      
        <content type="html"><![CDATA[<p>五子棋，作為一款家喻戶曉的桌上遊戲，<br>可能是程式新手練習程式、設計遊戲 AI 的好起點。</p><span id="more"></span><p>其實這篇文章是以筆者做的 Python 遊戲為範本；<br>那時做出了連珠棋（六子棋）的 AI（雖然沒用到 AI 技術）</p><p>後來一直想找機會把這個做法記錄下來。</p><div class="note success">            <p>筆者原始的 <a href="https://github.com/tinytsunami/PythonGame">Python 程式</a></p>          </div><div class="note info">            <p>本篇將用 JavaScript 進行說明；其他程式可參考算法。</p>          </div><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>初始化階段，我們需要清空棋盤的二維陣列，<br>除此之外，還需要定義一些基本變數。</p><div class="note info">            <p>這邊棋盤大小以 19 x 19 為例。</p>          </div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 常數 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">CONNECT</span> = <span class="number">5</span>;                          <span class="comment">// 取勝的連珠數量</span></span><br><span class="line"><span class="keyword">const</span> N = <span class="number">19</span>;                               <span class="comment">// 棋盤大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">EMPTY</span> = <span class="number">0</span>;                            <span class="comment">// 定義棋盤的空值</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">WHITE</span> = <span class="number">1</span>;                            <span class="comment">// 定義棋盤白子的值</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BLACK</span> = <span class="number">2</span>;                            <span class="comment">// 定義棋盤黑子的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 變數 */</span></span><br><span class="line"><span class="keyword">let</span> board = <span class="literal">null</span>;                           <span class="comment">// 二維棋盤</span></span><br><span class="line"><span class="keyword">let</span> player = <span class="literal">null</span>;                          <span class="comment">// 玩家棋的顏色</span></span><br><span class="line"><span class="keyword">let</span> computer = <span class="literal">null</span>;                        <span class="comment">// 電腦棋的顏色</span></span><br><span class="line"><span class="keyword">let</span> now = <span class="literal">null</span>;                             <span class="comment">// 目前是哪方落子</span></span><br><span class="line"><span class="keyword">let</span> end = <span class="literal">null</span>;                             <span class="comment">// 遊戲結束的旗標</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 輸入我方回傳對手的函數 */</span></span><br><span class="line"><span class="keyword">let</span> other = <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(c == <span class="variable constant_">WHITE</span>) &#123;                          <span class="comment">// 如果輸入白子</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">BLACK</span>;                           <span class="comment">// 回傳黑方</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="variable constant_">BLACK</span>) &#123;                     <span class="comment">// 如果輸入黑子</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable constant_">WHITE</span>;                           <span class="comment">// 回傳白方</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable constant_">EMPTY</span>;                             <span class="comment">// 傳入值有問題，回傳空</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 初始化函數 */</span></span><br><span class="line"><span class="keyword">let</span> initialize = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  player = <span class="variable constant_">BLACK</span>;                           <span class="comment">// 定義由玩家下黑子</span></span><br><span class="line">  computer = <span class="title function_">other</span>(player);                 <span class="comment">// 電腦為玩家的另一方</span></span><br><span class="line">  now = <span class="variable constant_">BLACK</span>;                              <span class="comment">// 由黑子先下</span></span><br><span class="line">  end = <span class="literal">false</span>;                              <span class="comment">// 遊戲尚未結束</span></span><br><span class="line">  board = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: N&#125;, <span class="function">()=&gt;</span>&#123;     <span class="comment">// 初始化棋盤</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: N&#125;, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable constant_">EMPTY</span>;                         <span class="comment">// 棋盤預設內容為空</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="title function_">refresh</span>();                                <span class="comment">// 更新畫面</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="title function_">initialize</span>();                               <span class="comment">// 調用初始化函數</span></span><br></pre></td></tr></table></figure><p>玩家不一定要下黑方，<br>可以設定由玩家選擇顏色，但這裡為了方便就固定下黑子。</p><p>接下來就可以撰寫繪製棋盤的 refresh() 函數了。</p><h1 id="繪製棋盤"><a href="#繪製棋盤" class="headerlink" title="繪製棋盤"></a>繪製棋盤</h1><p>在遊戲可以開始提供給玩家操作前，<br>我們要先把棋盤繪製出來。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* HTML DOM */</span></span><br><span class="line"><span class="keyword">const</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;canvas&quot;</span>)[<span class="number">0</span>];        <span class="comment">// 取得畫布元素</span></span><br><span class="line"><span class="keyword">const</span> context = canvas.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);                          <span class="comment">// 取得繪畫物件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 常數 */</span> </span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">BLOCK</span> = <span class="number">24</span>;                                                 <span class="comment">// 每格的大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">MARGIN</span> = <span class="number">15</span>;                                                <span class="comment">// 棋盤外邊框的大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TEXT</span> = <span class="number">12</span>;                                                  <span class="comment">// 棋盤下方顯示文字區域的大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">WIDTH</span> = (N - <span class="number">1</span>) * <span class="variable constant_">BLOCK</span> + <span class="variable constant_">MARGIN</span> * <span class="number">2</span>;                       <span class="comment">// 畫布寬度</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">HEIGHT</span> = (N - <span class="number">1</span>) * <span class="variable constant_">BLOCK</span> + <span class="variable constant_">MARGIN</span> * <span class="number">2</span> + <span class="variable constant_">TEXT</span>;               <span class="comment">// 畫布高度</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 畫布初始化 */</span> </span><br><span class="line">canvas.<span class="property">width</span> = <span class="variable constant_">WIDTH</span>;</span><br><span class="line">canvas.<span class="property">height</span> = <span class="variable constant_">HEIGHT</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 根據棋子回傳顏色 */</span> </span><br><span class="line"><span class="keyword">let</span> color = <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(c == <span class="variable constant_">WHITE</span>)                                                  <span class="comment">// 如果是白方</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;#FFFFFF&quot;</span>;                                             <span class="comment">// 回傳白色色碼</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="variable constant_">BLACK</span>)                                             <span class="comment">// 如果是黑方</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;#000000&quot;</span>;                                             <span class="comment">// 回傳黑色色碼</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;                                                    <span class="comment">// 傳入值有問題，回傳無</span></span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 刷新畫面 */</span> </span><br><span class="line"><span class="keyword">let</span> refresh = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">let</span> ox, oy, tx, ty, r;                                          <span class="comment">// 宣告一些暫存變數</span></span><br><span class="line">  context.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);           <span class="comment">// 清空畫面</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; N; x++) &#123;                                    <span class="comment">// 遍歷棋盤畫線</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; N; y++) &#123; </span><br><span class="line">      context.<span class="title function_">beginPath</span>();                                        <span class="comment">// 初始化路徑</span></span><br><span class="line">      ox = x * <span class="variable constant_">BLOCK</span> + <span class="variable constant_">MARGIN</span>;                                    <span class="comment">// 設定座標</span></span><br><span class="line">      tx = ox; </span><br><span class="line">      oy = <span class="variable constant_">MARGIN</span>; </span><br><span class="line">      ty = (N - <span class="number">1</span>) * <span class="variable constant_">BLOCK</span> + <span class="variable constant_">MARGIN</span>; </span><br><span class="line">      context.<span class="title function_">moveTo</span>(ox, oy);                                     <span class="comment">// 移到起始座標</span></span><br><span class="line">      context.<span class="title function_">lineTo</span>(tx, ty);                                     <span class="comment">// 繪製直線</span></span><br><span class="line">      ox = <span class="variable constant_">MARGIN</span>;                                                <span class="comment">// 直向路徑</span></span><br><span class="line">      tx = (N - <span class="number">1</span>) * <span class="variable constant_">BLOCK</span> + <span class="variable constant_">MARGIN</span>; </span><br><span class="line">      oy = y * <span class="variable constant_">BLOCK</span> + <span class="variable constant_">MARGIN</span>; </span><br><span class="line">      ty = oy; </span><br><span class="line">      context.<span class="title function_">moveTo</span>(ox, oy);                                     <span class="comment">// 移到起始座標</span></span><br><span class="line">      context.<span class="title function_">lineTo</span>(tx, ty);                                     <span class="comment">// 橫向路徑</span></span><br><span class="line">      context.<span class="title function_">stroke</span>();                                           <span class="comment">// 繪製線條</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; N; x++) &#123;                                    <span class="comment">// 遍歷棋盤畫棋子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; N; y++) &#123; </span><br><span class="line">      context.<span class="title function_">beginPath</span>();                                        <span class="comment">// 初始化新路徑</span></span><br><span class="line">      <span class="keyword">if</span>(board[x][y] != <span class="variable constant_">EMPTY</span>) &#123;                                  <span class="comment">// 棋盤不為空</span></span><br><span class="line">        ox = x * <span class="variable constant_">BLOCK</span> + <span class="variable constant_">MARGIN</span>;                                  <span class="comment">// 設定座標</span></span><br><span class="line">        oy = y * <span class="variable constant_">BLOCK</span> + <span class="variable constant_">MARGIN</span>; </span><br><span class="line">        r = <span class="variable constant_">BLOCK</span> / <span class="number">2</span>;                                            <span class="comment">// 設定半徑</span></span><br><span class="line">        context.<span class="title function_">arc</span>(ox, oy, r, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>);                   <span class="comment">// 圓弧路徑（注意後兩個參數是弧度）</span></span><br><span class="line">        context.<span class="property">fillStyle</span> = <span class="title function_">color</span>(board[x][y]);                   <span class="comment">// 選取顏色</span></span><br><span class="line">        context.<span class="title function_">fill</span>();                                           <span class="comment">// 填充圓型</span></span><br><span class="line">        context.<span class="property">strokeStyle</span> = <span class="string">&quot;#000000&quot;</span>;                          <span class="comment">// 棋子邊線顏色</span></span><br><span class="line">        context.<span class="title function_">stroke</span>();                                         <span class="comment">// 繪製邊線</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(end == <span class="literal">true</span>) &#123;                                               <span class="comment">// 遊戲結束繪製提示字</span></span><br><span class="line">    ...                                                           <span class="comment">// 繪製結束字的部分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>繪製棋盤雖然比較麻煩，但內容不困難，<br>座標的暫存變數可以直接寫在繪圖函數的傳入值內也可以。</p><div class="note info">            <p>關於 beginPath() 的用法請參閱 <a href="https://www.w3schools.com/tags/canvas_beginpath.asp">w3school: beginPath()</a>。</p>          </div><h1 id="遊戲進行"><a href="#遊戲進行" class="headerlink" title="遊戲進行"></a>遊戲進行</h1><p>遊戲進行是透過玩家按下滑鼠來推動，<br>這樣處理比起透過 setInterval() 函數重複執行要有效率。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 落子在棋盤上的函數 */</span></span><br><span class="line"><span class="keyword">let</span> chess = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(board[x][y] == <span class="variable constant_">EMPTY</span>) &#123;                                  <span class="comment">// 選的位置是空的</span></span><br><span class="line">    board[x][y] = now;                                        <span class="comment">// 代表棋子可以下這裡</span></span><br><span class="line">    <span class="keyword">if</span>(...) &#123;                                                 <span class="comment">// 勝利的條件</span></span><br><span class="line">      end = <span class="literal">true</span>;                                             <span class="comment">// 讓遊戲結束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                    <span class="comment">// 還沒勝利</span></span><br><span class="line">      now = <span class="title function_">other</span>(now);                                       <span class="comment">// 換對手下棋</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">refresh</span>();                                                  <span class="comment">// 更新畫面</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 畫布被玩家按下 */</span></span><br><span class="line">canvas.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(end == <span class="literal">true</span>) &#123;                                           <span class="comment">// 遊戲結束</span></span><br><span class="line">    ...                                                       <span class="comment">// 遊戲結束的處理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;                                                      <span class="comment">// 遊戲還沒結束</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">round</span>((event.<span class="property">offsetX</span> - <span class="variable constant_">MARGIN</span>) / <span class="variable constant_">BLOCK</span>);     <span class="comment">// 抓取玩家滑鼠按下的 x 座標</span></span><br><span class="line">    <span class="keyword">let</span> y = <span class="title class_">Math</span>.<span class="title function_">round</span>((event.<span class="property">offsetY</span> - <span class="variable constant_">MARGIN</span>) / <span class="variable constant_">BLOCK</span>);     <span class="comment">// 抓取玩家滑鼠按下的 y 座標</span></span><br><span class="line">    <span class="title function_">chess</span>(x, y);                                              <span class="comment">// 玩家落子在 (x, y)</span></span><br><span class="line">    <span class="keyword">if</span>(now == computer) &#123;                                     <span class="comment">// 現在換電腦下？（有可能玩家落子失敗）</span></span><br><span class="line">      ...                                                     <span class="comment">// 電腦的 AI 策略</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>設定 chess() 函數檢查落子規則，使得主函數變得很簡潔。</p><h1 id="勝負判斷"><a href="#勝負判斷" class="headerlink" title="勝負判斷"></a>勝負判斷</h1><p>這裡開始的設計是五子棋程式冗長與否的關鍵！</p><p>由於可能會重複使用「是否超出棋盤」的邏輯，<br>這裡先寫一個 belong() 函數為之後做準備。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 是否在範圍中 */</span></span><br><span class="line"><span class="keyword">let</span> belong = <span class="keyword">function</span>(<span class="params">v, min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt;= min &amp;&amp; v &lt; max;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接著這邊取得連珠數量的方式是這樣的，<br>我們先考慮一個方向的情況，在這個方向上，<br>連珠的數量為：「A 部分的數量 + 1 + B 部分的數量」</p><p>數量說明請參考圖 1。</p><p><img src="https://i.imgur.com/mLNHoUH.jpg" alt="圖 1、連珠數量說明"></p><p>另外觀察所有的方向：<br>考慮給定一個 (x, y) 加上一個 (dx, dy) 的偏移量，<br>由於 A 部分跟 B 部分是完全相反的。</p><p>也就是說 A &#x3D; (x + dx, y + dy) 的話，<br>有 B &#x3D; (x + (-dx), y + (-dy)) 的關係。</p><p>圖 2 使用顏色把原方向及反方向標出來。</p><p><img src="https://i.imgur.com/SmaJU1x.jpg" alt="圖 2、連珠方向說明"></p><p>這裡列出所有座標變化：</p><table><thead><tr><th>方向</th><th>dx 偏移量範圍</th><th>dy 偏移量範圍</th></tr></thead><tbody><tr><td>左上 → 右下（上圖藍色部分）</td><td>dx &#x3D; [-1, -2, -3, -4]</td><td>dy &#x3D; [-1, -2, -3, -4]</td></tr><tr><td>左上 → 右下（上圖紅色部分）</td><td>dx &#x3D; [+1, +2, +3, +4]</td><td>dy &#x3D; [+1, +2, +3, +4]</td></tr><tr><td>直向（上圖藍色部分）</td><td>dx &#x3D; [-0, -0, -0, -0]</td><td>dy &#x3D; [-1, -2, -3, -4]</td></tr><tr><td>直向（上圖紅色部分）</td><td>dx &#x3D; [+0, +0, +0, +0]</td><td>dy &#x3D; [+1, +2, +3, +4]</td></tr><tr><td>右上 → 左下（上圖藍色部分）</td><td>dx &#x3D; [+1, +2, +3, +4]</td><td>dy &#x3D; [-1, -2, -3, -4]</td></tr><tr><td>右上 → 左下（上圖紅色部分）</td><td>dx &#x3D; [-1, -2, -3, -4]</td><td>dy &#x3D; [+1, +2, +3, +4]</td></tr><tr><td>橫向（上圖藍色部分）</td><td>dx &#x3D; [-1, -2, -3, -4]</td><td>dy &#x3D; [-0, -0, -0, -0]</td></tr><tr><td>橫向（上圖紅色部分）</td><td>dx &#x3D; [+1, +2, +3, +4]</td><td>dy &#x3D; [+0, +0, +0, +0]</td></tr></tbody></table><p>如果令：</p><table><thead><tr><th>偏移量代號</th><th>偏移量範圍</th></tr></thead><tbody><tr><td>fixed</td><td>[0, 0, 0, 0]</td></tr><tr><td>forward</td><td>[+1, +2, +3, +4]</td></tr><tr><td>reverse</td><td>[-1, -2, -3, -4]</td></tr></tbody></table><p>可以把上表化簡成：</p><table><thead><tr><th>方向</th><th>dx 偏移量範圍</th><th>dy 偏移量範圍</th></tr></thead><tbody><tr><td>左上 → 右下（上圖藍色部分）</td><td>reverse</td><td>reverse</td></tr><tr><td>左上 → 右下（上圖紅色部分）</td><td>forward</td><td>forward</td></tr><tr><td>直向（上圖藍色部分）</td><td>fixed</td><td>reverse</td></tr><tr><td>直向（上圖紅色部分）</td><td>fixed</td><td>forward</td></tr><tr><td>右上 → 左下（上圖藍色部分）</td><td>forward</td><td>reverse</td></tr><tr><td>右上 → 左下（上圖紅色部分）</td><td>reverse</td><td>forward</td></tr><tr><td>橫向（上圖藍色部分）</td><td>reverse</td><td>fixed</td></tr><tr><td>橫向（上圖紅色部分）</td><td>forward</td><td>fixed</td></tr></tbody></table><p>這樣就可以設計一個函數，<br>傳入目前座標、棋子顏色及變化量範圍，<br>回傳有多少連珠：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 確認某個方向內的棋子數量</span></span><br><span class="line"><span class="comment"> * (x, y)   : 目前座標</span></span><br><span class="line"><span class="comment"> * c        : 棋子顏色</span></span><br><span class="line"><span class="comment"> * (dx, dy) : 偏移量範圍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> check = <span class="keyword">function</span>(<span class="params">x, y, c, dx, dy</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;                                      <span class="comment">// 連珠數量</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable constant_">CONNECT</span> - <span class="number">1</span>; i++) &#123;              <span class="comment">// 最大連珠範圍</span></span><br><span class="line">    <span class="keyword">let</span> tx = x + dx[i];                               <span class="comment">// 偏移後的 x 座標</span></span><br><span class="line">    <span class="keyword">let</span> ty = y + dy[i];                               <span class="comment">// 偏移後的 y 座標</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_">belong</span>(tx, <span class="number">0</span>, N) || !<span class="title function_">belong</span>(ty, <span class="number">0</span>, N)) &#123;      <span class="comment">// 超出範圍</span></span><br><span class="line">      <span class="keyword">continue</span>;                                       <span class="comment">// 直接看下個偏移座標</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(board[tx][ty] == c) &#123;                          <span class="comment">// 如果目前偏移座標是指定顏色</span></span><br><span class="line">      count++;                                        <span class="comment">// 連珠數量增加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                            <span class="comment">// 如果不是指定顏色（被截斷）</span></span><br><span class="line">      <span class="keyword">break</span>;                                          <span class="comment">// 終止計數</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;                                       <span class="comment">// 回傳連珠數量</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有了這樣的函數後，可以直接調用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 從指定座標出發的連珠數量</span></span><br><span class="line"><span class="comment"> * (x, y)   : 目前座標</span></span><br><span class="line"><span class="comment"> * c        : 棋子顏色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> connect = <span class="keyword">function</span>(<span class="params">x, y, c</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> assess = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">4</span>&#125;, <span class="function">(<span class="params">v, i</span>)=&gt;</span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;);                            <span class="comment">// 記錄四個方向的連珠數量</span></span><br><span class="line">  <span class="keyword">let</span> fixed = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="variable constant_">CONNECT</span>&#125;, <span class="function">(<span class="params">v, i</span>)=&gt;</span>&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;);                       <span class="comment">// 建立 fixed 偏移表</span></span><br><span class="line">  <span class="keyword">let</span> forward = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="variable constant_">CONNECT</span>&#125;, <span class="function">(<span class="params">v, i</span>)=&gt;</span>&#123;<span class="keyword">return</span> i;&#125;);                     <span class="comment">// 建立 forward 偏移表</span></span><br><span class="line">  <span class="keyword">let</span> reverse = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="variable constant_">CONNECT</span>&#125;, <span class="function">(<span class="params">v, i</span>)=&gt;</span>&#123;<span class="keyword">return</span> -i;&#125;);                    <span class="comment">// 建立 reverse 偏移表</span></span><br><span class="line">  fixed.<span class="title function_">shift</span>();                                                                        <span class="comment">// 偏移表的第 0 項不要（參考上表）</span></span><br><span class="line">  forward.<span class="title function_">shift</span>();</span><br><span class="line">  reverse.<span class="title function_">shift</span>();</span><br><span class="line">  assess[<span class="number">0</span>] = <span class="title function_">check</span>(x, y, c, forward, fixed) + <span class="title function_">check</span>(x, y, c, reverse, fixed) + <span class="number">1</span>;      <span class="comment">// 橫向的連珠數量</span></span><br><span class="line">  assess[<span class="number">1</span>] = <span class="title function_">check</span>(x, y, c, fixed, forward) + <span class="title function_">check</span>(x, y, c, fixed, reverse) + <span class="number">1</span>;      <span class="comment">// 直向的連珠數量</span></span><br><span class="line">  assess[<span class="number">2</span>] = <span class="title function_">check</span>(x, y, c, reverse, reverse) + <span class="title function_">check</span>(x, y, c, forward, forward) + <span class="number">1</span>;  <span class="comment">// 左上到右下的連珠數量</span></span><br><span class="line">  assess[<span class="number">3</span>] = <span class="title function_">check</span>(x, y, c, reverse, forward) + <span class="title function_">check</span>(x, y, c, forward, reverse) + <span class="number">1</span>;  <span class="comment">// 右上到左下的連珠數量</span></span><br><span class="line">  max = assess.<span class="title function_">reduce</span>(<span class="function">(<span class="params">previous, current</span>)=&gt;</span><span class="title class_">Math</span>.<span class="title function_">max</span>(previous, current));                <span class="comment">// 四個方向取最大值</span></span><br><span class="line">  <span class="keyword">return</span> max;                                                                           <span class="comment">// 回傳最大連珠數量</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因為勝出一定是「當前回合落子」造成遊戲結束，<br>所以勝負條件會寫在 chess() 函數內，<br>給定座標就是當前落子的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 落子在棋盤上的函數 */</span></span><br><span class="line"><span class="keyword">let</span> chess = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">connect</span>(x, y, now) &gt;= <span class="variable constant_">CONNECT</span>) &#123;                       <span class="comment">// 勝利的條件</span></span><br><span class="line">      end = <span class="literal">true</span>;                                             <span class="comment">// 讓遊戲結束</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>這裡的這個做法還有其他功能。將於 <a href="#%E9%9B%BB%E8%85%A6%E5%B0%8D%E5%BC%88">電腦對弈</a> 段落介紹。</p>          </div><h1 id="結束處理"><a href="#結束處理" class="headerlink" title="結束處理"></a>結束處理</h1><p>既然勝負判斷已經完成，就可以順便實作結束處理。<br>這邊就顯示一行字在底部，然後再次點擊畫面可以重複遊戲這樣。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 畫布被玩家按下 */</span></span><br><span class="line">canvas.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(end == <span class="literal">true</span>) &#123;                                           <span class="comment">// 遊戲結束</span></span><br><span class="line">    <span class="title function_">initialize</span>();                                             <span class="comment">// 重新初始化</span></span><br><span class="line">    end = <span class="literal">false</span>;                                              <span class="comment">// 讓遊戲重新開始</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;                                                      <span class="comment">// 遊戲還沒結束</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>則畫布的更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 刷新畫面 */</span> </span><br><span class="line"><span class="keyword">let</span> refresh = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span>(end == <span class="literal">true</span>) &#123;                                               <span class="comment">// 遊戲結束繪製提示字</span></span><br><span class="line">    context.<span class="property">font</span> = <span class="string">&quot;12px Verdana&quot;</span>                                 <span class="comment">// 設定字型與大小</span></span><br><span class="line">    context.<span class="property">fillStyle</span> = <span class="string">&quot;#000000&quot;</span>;                                <span class="comment">// 繪製顏色</span></span><br><span class="line">    <span class="keyword">let</span> winner = (now == <span class="variable constant_">BLACK</span> ? <span class="string">&quot;black&quot;</span> : <span class="string">&quot;white&quot;</span>);              <span class="comment">// 取得勝利方名稱</span></span><br><span class="line">    <span class="keyword">let</span> text = <span class="string">`<span class="subst">$&#123;winner&#125;</span> is won!(click screen to play again)`</span>;   <span class="comment">// 勝利提字文字</span></span><br><span class="line">    context.<span class="title function_">fillText</span>(text, <span class="variable constant_">MARGIN</span>, canvas.<span class="property">height</span> - <span class="variable constant_">TEXT</span>);         <span class="comment">// 繪製文字</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="電腦對弈"><a href="#電腦對弈" class="headerlink" title="電腦對弈"></a>電腦對弈</h1><p>電腦 AI 其實是最難寫的。</p><p>不過我們別有用心的設計了 connect() 函數後，<br>這裡可以在這裡使用這兩個函數。</p><p>由於連珠棋有輪流落子的規則，<br>所以只要輪到我方時，我盤面上最長的連珠大於對手最大連珠，<br>我方繼續加子，如果對方不阻擋，則我方就會勝出。</p><p>反之，如果對手的最大連珠大於我方，我方應該先阻擋對方。</p><p>具體的說，透過我們的 connect() 函數傳入可以落子的座標，<br>找到「如果這個座標落子的話」這裡會形成的最大連珠。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 搜索盤面上的特定顏色 </span></span><br><span class="line"><span class="comment"> * c: 棋子顏色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> search = <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;                                          <span class="comment">// 回傳物件</span></span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,                                                 <span class="comment">// 特定的 x 位置</span></span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,                                                 <span class="comment">// 特定的 y 位置</span></span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>                                              <span class="comment">// 最大連珠</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; N; x++) &#123;                            <span class="comment">// 遍歷棋盤</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; N; y++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(board[x][y] == <span class="variable constant_">EMPTY</span>) &#123;                          <span class="comment">// 如果這個棋盤位置可以落子</span></span><br><span class="line">        <span class="keyword">let</span> max = <span class="title function_">connect</span>(x, y, c);                       <span class="comment">// 取得落子後的最大連珠</span></span><br><span class="line">        <span class="keyword">if</span>(target.<span class="property">count</span> &lt; max) &#123;                          <span class="comment">// 如果連珠更大則</span></span><br><span class="line">          target.<span class="property">x</span> = x;                                   <span class="comment">// 保存最大連珠處的 x 位置</span></span><br><span class="line">          target.<span class="property">y</span> = y;                                   <span class="comment">// 保存最大連珠處的 y 位置</span></span><br><span class="line">          target.<span class="property">count</span> = max;                             <span class="comment">// 保存最大連珠數量</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;                                          <span class="comment">// 回傳最大連珠的資料</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>電腦 AI 的部分就很簡單了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 畫布被玩家按下 */</span></span><br><span class="line">canvas.<span class="property">onmousedown</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(end == <span class="literal">true</span>) &#123;                                           <span class="comment">// 遊戲結束</span></span><br><span class="line">    ...                                                       <span class="comment">// 遊戲結束的處理</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;                                                      <span class="comment">// 遊戲還沒結束</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(now == computer) &#123;                                     <span class="comment">// 現在換電腦下？（有可能玩家落子失敗）</span></span><br><span class="line">      playerTarget = <span class="title function_">search</span>(player);                          <span class="comment">// 搜尋玩家的最大連珠</span></span><br><span class="line">      computerTarget = <span class="title function_">search</span>(computer);                      <span class="comment">// 搜尋電腦的最大連珠</span></span><br><span class="line">      <span class="keyword">if</span>(playerTarget.<span class="property">count</span> &gt; computerTarget.<span class="property">count</span>) &#123;         <span class="comment">// 玩家最大連珠大於電腦</span></span><br><span class="line">        <span class="title function_">chess</span>(playerTarget.<span class="property">x</span>, playerTarget.<span class="property">y</span>);                <span class="comment">// 擋在玩家會形成最大連珠的地方</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;                                                  <span class="comment">// 電腦連珠比玩家的大</span></span><br><span class="line">        <span class="title function_">chess</span>(computerTarget.<span class="property">x</span>, computerTarget.<span class="property">y</span>);            <span class="comment">// 我方繼續落子在最大的地方</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info">            <p>雖然這裡稱作電腦「AI」對弈，但實際上是傳統的暴力搜索。</p>          </div><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>來下棋吧！</p><iframe scrolling="no" width="100%" height="550px" src="https://jsfiddle.net/xw8LuLvz/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 人工智慧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序 Sort</title>
      <link href="//sort/"/>
      <url>//sort/</url>
      
        <content type="html"><![CDATA[<p>排序是演算法最基本內容。</p><p>當初給我這樣印象似乎是網路上某篇文章，雖然已經找不到來源，<br>但隨著瞄過《算法導論》以及上過大學演算法後，這個想法深植心中。</p><span id="more"></span><p>那時學校作業好像只要求實作兩種排序並比較速度，<br>基於興趣，我實作了許多排序。</p><div class="note warning">            <p>當時未收入睡眠排序；且初次實作大量排序，程式碼品質似乎欠佳。</p>          </div><h1 id="測資"><a href="#測資" class="headerlink" title="測資"></a>測資</h1><p>本篇所有的程式全都是「由小到大」排序，<br>另外對於所有程式碼的函數，你可以預設存在這樣一筆測資：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> len = <span class="number">5</span>;                    <span class="comment">// 陣列長度</span></span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];          <span class="comment">// 測資陣列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)    <span class="comment">// 設定初始值</span></span><br><span class="line">  arr[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;        <span class="comment">// 範圍為 [0, 100)</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">sort</span>(arr, len);                 <span class="comment">// 調用排序函數</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note warning">            <p>陣列大小設定為變數不是所有編譯器都支援，故此採用動態宣告。</p>          </div><h1 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h1><p>中文為「氣泡排序」<br>應該是最容易理解的排序之一，同時程式設計課程幾乎都會提及，<br>以 C 語言初學者來說，不熟練 STL 與其他排序時，會用上的排序技巧。</p><p>大致上的想法是，掃描陣列的兩個值，<br>保持兩個值一前一後，如果出現前值大於後值，則交換兩個值。</p><h2 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h2><div class="note primary">            <p>筆者在這裡致歉，舊版文章的 Bubble sort 沒有符合相鄰元素才交換的要件；使得程式碼更接近插入排序，在後續 Odd-Even Sort 會造成理解困難，特此聲明。</p>          </div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 整數交換函數 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = *a;                             <span class="comment">// 保存 a 值</span></span><br><span class="line">    *a = *b;                                <span class="comment">// 以 b 值覆蓋 a 值</span></span><br><span class="line">    *b = t;                                 <span class="comment">// 以 a 值覆蓋 b 值</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 氣泡排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)            <span class="comment">// 選取第 i 個值（前項）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)    <span class="comment">// 選取第 j 個值（後項）</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j<span class="number">-1</span>] &gt; arr[j])           <span class="comment">// 如果前項比後項大</span></span><br><span class="line">                <span class="built_in">swap</span>(&amp;arr[j<span class="number">-1</span>], &amp;arr[j]);   <span class="comment">// 交換前項與後項</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以發現 <code>i</code> 最小為 0，而 <code>j</code> 最小為 <code>i+1</code> 即 1，可以推得 <code>j-1</code> 最小為 0 不會超出邊界。</p><div class="note warning">            <p>交換函數 (swap) 在 C++ 中有預先定義，請參考 <a href="http://www.cplusplus.com/reference/algorithm/swap/">cplusplus std::swap</a></p>          </div><h1 id="Selection-Sort"><a href="#Selection-Sort" class="headerlink" title="Selection Sort"></a>Selection Sort</h1><p>中文為「選擇排序」<br>選擇排序是很直觀的一種排序，可以視作氣泡排序的加強版，<br>雖然概念很簡單，但註標的設定對於初學者來說是有可能混亂的。</p><p>原先氣泡排序要不斷地交換陣列的元素，<br>選擇排序提供了一種思路：「找到最小的交換」取代了「每次比較的交換」。</p><p>與氣泡排序相同，要掃描兩個值，<br>但這次將前值固定，後值從未排序的元素中選擇最小的跟前值換。<br>（未排序的陣列包含前值那個位置）</p><h2 id="實作-1"><a href="#實作-1" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 選擇排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)           <span class="comment">// 對於每個元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = i;                        <span class="comment">// 假設元素 i 是 [i, len) 內最小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)   <span class="comment">// 尋找 [i+1, len) 內更小的 j 元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[min] &gt; arr[j])          <span class="comment">// 如果元素 j 更小</span></span><br><span class="line">                min = j;                    <span class="comment">// 取代原本的最小假設</span></span><br><span class="line">        <span class="built_in">swap</span>(&amp;arr[i], &amp;arr[min]);           <span class="comment">// 使元素 i 的位置為 [i, len) 內最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>交換函數 (swap) 於前面段落有提及，有需要請參考 <a href="#Bubble-Sort">氣泡排序</a></p>          </div><h1 id="Insertion-Sort"><a href="#Insertion-Sort" class="headerlink" title="Insertion Sort"></a>Insertion Sort</h1><p>中文為「插入排序」<br>插入排序是《算法導論》起初就介紹的排序方法。</p><p>概念其實很容易，就像是在玩撲克牌，<br>如果你整理你的手牌，你會把需要整理的牌取出，<br>然後一張張挪動比他大的牌，直到找到插入的位置。</p><h2 id="實作-2"><a href="#實作-2" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;                                           <span class="comment">// 註標 i, j</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)                           <span class="comment">// 檢查每一個元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = arr[i];                               <span class="comment">// 取出要排序的元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - <span class="number">1</span>]; j--)     <span class="comment">// 往前尋找插入點</span></span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];                        <span class="comment">// 挪動元素的位置</span></span><br><span class="line">        arr[j] = tmp;                                   <span class="comment">// 插入元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Cocktail-Sort"><a href="#Cocktail-Sort" class="headerlink" title="Cocktail Sort"></a>Cocktail Sort</h1><p>中文為「雞尾酒排序」<br>可以視為氣泡排序的加強版，氣泡排序從單邊處理；<br>而雞尾酒的想法是從陣列的兩端，像在搖瓶子那樣把兩頭逐漸處理完。</p><h2 id="實作-3"><a href="#實作-3" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 雞尾酒排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cocktail_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;                               <span class="comment">// 一方面從左邊開始</span></span><br><span class="line">    <span class="type">int</span> right = len - <span class="number">1</span>;                        <span class="comment">// 一方面從右邊開始</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)                        <span class="comment">// 尚未結束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt; right; j++)      <span class="comment">// 最大的元素會被換到右邊</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(&amp;arr[j], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">        right--;                                <span class="comment">// 最右邊排序完成</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = right; j &gt; left; j--)      <span class="comment">// 最小的元素會被換到左邊</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(&amp;arr[j], &amp;arr[j - <span class="number">1</span>]);</span><br><span class="line">        left++;                                 <span class="comment">// 最左邊排序完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>交換函數 (swap) 於前面段落有提及，有需要請參考 <a href="#Bubble-Sort">氣泡排序</a></p>          </div><h1 id="Comb-Sort"><a href="#Comb-Sort" class="headerlink" title="Comb Sort"></a>Comb Sort</h1><p>中文為「梳排序」<br>梳排序意思就是「梳子排序」借用了梳子的想法。</p><p>與氣泡排序一樣，每次掃描兩個元素，<br>但每次掃描的當下，掃描的元素距離是固定的，<br>並隨著每次掃描，寬度逐漸縮小。</p><p>就像是梳理凌亂的頭髮，<br>一開始會用齒距大的梳子，後來越用越小，<br>當然也會越來越整齊了。</p><h2 id="實作-4"><a href="#實作-4" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 梳排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">comb_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> width = len - <span class="number">1</span>; width &gt; <span class="number">0</span>; width--)               <span class="comment">// 兩元素的間距逐漸遞減</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> begin = <span class="number">0</span>; (begin + width) &lt; len; begin++)     <span class="comment">// 掃描每個元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[begin] &gt; arr[begin + width])                <span class="comment">// 比較兩個元素大小</span></span><br><span class="line">                <span class="built_in">swap</span>(&amp;arr[begin], &amp;arr[begin + width]);         <span class="comment">// 交換元素</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>交換函數 (swap) 於前面段落有提及，有需要請參考 <a href="#Bubble-Sort">氣泡排序</a></p>          </div><h1 id="Gnome-Sort"><a href="#Gnome-Sort" class="headerlink" title="Gnome Sort"></a>Gnome Sort</h1><p>中文為「地精排序」<br>這個排序特別的地方在於，實作出來往往只有一層迴圈結構，<br>大量交換元素使的整體類似氣泡排序，不是實用的算法。</p><p>具體來說，它透過進入未排序的範圍，<br>透過相鄰的兩兩交換，把元素換到正確的位置上。</p><h2 id="實作-5"><a href="#實作-5" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 地精排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gnome_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;                              <span class="comment">// 初始化註標</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; (len - <span class="number">1</span>))                   <span class="comment">// 設定註標範圍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[i + <span class="number">1</span>])           <span class="comment">// 如果目前這裡已經排好</span></span><br><span class="line">            i++;                            <span class="comment">// 移動到未排序的範圍</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(&amp;arr[i], &amp;arr[i + <span class="number">1</span>]);     <span class="comment">// 把未排序的元素往前換</span></span><br><span class="line">            i--;                            <span class="comment">// 註標跟著這個未換好的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)                          <span class="comment">// 處理邊界問題</span></span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>交換函數 (swap) 於前面段落有提及，有需要請參考 <a href="#Bubble-Sort">氣泡排序</a></p>          </div><h1 id="Odd-Even-Sort"><a href="#Odd-Even-Sort" class="headerlink" title="Odd-Even Sort"></a>Odd-Even Sort</h1><p>中文為「奇偶排序」，跟氣泡排序類似的排序算法。</p><p>排序的特性會透過排序奇數位的元素及偶數位的元素，來達成整體的排序，<br>實際上是氣泡排序的平行化版本，在 SIMD (Single-Instruction Multiple-Data) 的假設下，可以壓到 O(n)。</p><h2 id="實作-6"><a href="#實作-6" class="headerlink" title="實作"></a>實作</h2><p>這裡僅實做序列版：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 奇偶排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ood_even_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;                                <span class="comment">// 宣告排序完成旗標</span></span><br><span class="line">    <span class="keyword">while</span> (sorted == <span class="literal">false</span>)                             <span class="comment">// 如果排序未完成則排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        sorted = <span class="literal">true</span>;                                  <span class="comment">// 假設已經排序完畢</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> base = <span class="number">0</span>; base &lt; <span class="number">2</span>; base++)            <span class="comment">// 依序操作奇數位元素、偶數位元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = base; i &lt; (len - <span class="number">1</span>); i += <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])                <span class="comment">// 比較相鄰奇、偶數的元素</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(&amp;arr[i], &amp;arr[i + <span class="number">1</span>]);         <span class="comment">// 如果位置不對則交換</span></span><br><span class="line">                    sorted = <span class="literal">false</span>;                     <span class="comment">// 假設錯誤目前未排完</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Shell-Sort"><a href="#Shell-Sort" class="headerlink" title="Shell Sort"></a>Shell Sort</h1><p>中文為「希爾排序」<br>可以看成是插入排序的加強版。</p><p>實作上，將固定間距的數字先做插入排序，<br>然後使間距逐漸遞減。</p><h2 id="實作-7"><a href="#實作-7" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 希爾排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = len; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)                                      <span class="comment">// 間距逐次減半</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> shift = <span class="number">0</span>; shift &lt; gap; shift++)                               <span class="comment">// 找到間距中的所有元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i, j;                                                           <span class="comment">// 註標 i, j</span></span><br><span class="line">            <span class="keyword">for</span> (i = shift; i &lt; len; i += gap)                                  <span class="comment">// 對特定間距的插入排序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tmp = arr[i];                                               <span class="comment">// 取出要排序的元素</span></span><br><span class="line">                <span class="keyword">for</span> (j = i; tmp &lt; arr[j - gap] &amp;&amp; j &gt; shift; j -= gap)          <span class="comment">// 往前尋找插入點</span></span><br><span class="line">                    arr[j] = arr[j - gap];                                      <span class="comment">// 挪動元素的位置</span></span><br><span class="line">                arr[j] = tmp;                                                   <span class="comment">// 插入元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h1><p>中文為「桶子排序」<br>這是一個混合式的方法，必須先將元素分配到不同的桶子，<br>然後再將每個桶子內排序完成，最後再組合起來。對於平行系統似乎是個好選擇。</p><div class="note info">            <p>每個桶子內的排序，這裡使用了 <a href="#Insertion-Sort">插入排序</a></p>          </div><p>如果還記得複雜度分析的方法：<br>當 $c$ 為一常數，且 $n &gt; n_{0}$ 時，<br>存在 $f(n) &lt; cg(n)$ 這樣的關係，<br>可以表示為 $f(n) &#x3D; O(g(n))$</p><p>也就是說，桶子排序的排序算法，<br>可以選擇一些 $n$ 在 $n_{0}$ 之下，速度很快的方法。</p><div class="note warning">            <p>有些中文書的桶子排序是指 <a href="#Counting-Sort">Counting Sort</a></p>          </div><h2 id="實作-8"><a href="#實作-8" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 桶子排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucket_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> **bucket = <span class="keyword">new</span> <span class="type">int</span>*[<span class="number">10</span>];                                <span class="comment">// 建立一些桶子（這裡是 10 個）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)                                <span class="comment">// 初始化每個桶子</span></span><br><span class="line">    &#123;</span><br><span class="line">        bucket[i] = <span class="keyword">new</span> <span class="type">int</span>[len];                               <span class="comment">// 設定桶子大小</span></span><br><span class="line">        bucket[i][<span class="number">0</span>] = <span class="number">0</span>;                                       <span class="comment">// 桶子第 0 個位置存放元素個數   </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)                               <span class="comment">// 分配每個元素到 10 個桶子中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= j * <span class="number">10</span> &amp;&amp; arr[i] &lt; (j + <span class="number">1</span>) * <span class="number">10</span>)      <span class="comment">// [10*j, 10*(j+1)] 分配到 j</span></span><br><span class="line">                bucket[j][<span class="number">1</span> + bucket[j][<span class="number">0</span>]++] = arr[i];         <span class="comment">// 每個從 1 號位置開始放元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)                                <span class="comment">// 對每個桶子執行插入排序</span></span><br><span class="line">        <span class="built_in">insertion_sort</span>(&amp;bucket[i][<span class="number">1</span>], bucket[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;                                              <span class="comment">// 拼回原本的陣列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket[i][<span class="number">0</span>]; j++)</span><br><span class="line">            arr[index++] = bucket[i][j + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] bucket;                                            <span class="comment">// 清理空間</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>注意桶子的大小跟數量，分配需要涵蓋到所有元素。事先知道資料分布情況是很有幫助的。</p>          </div><div class="note danger">            <p>不要忘記使用 delete 與 delete[] 來清理記憶體空間。</p>          </div><h1 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h1><p>中文為「計數排序」<br>非比較排序，所以不受上限 $\Omega(nlg(n))$ 的限制。  </p><p>大致上的概念是說，數數看有哪些元素，<br>比方說有 5 則在 5 號箱子加一，最後再整合蒐集來的資訊。</p><p>通常情況下很浪費空間，但速度相當快，<br>對於位數相當敏感，而非個數，所以也可將 $n$ 視為元素位數。</p><h2 id="實作-9"><a href="#實作-9" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 計數排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">99</span>];               <span class="comment">// 宣告計數空間</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">99</span>; i++)            <span class="comment">// 範圍是 [0, 100)</span></span><br><span class="line">        count[i] = <span class="number">0</span>;                       <span class="comment">// 初始化數量為 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)           <span class="comment">// 紀錄每個元素的數量</span></span><br><span class="line">        count[arr[i]]++;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;                          <span class="comment">// 拼回原本的陣列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">99</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; count[i]; j++)</span><br><span class="line">            arr[index++] = i;</span><br><span class="line">    <span class="keyword">delete</span> count;                            <span class="comment">// 清理空間</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h1><p>中文為「基數排序」<br>基數排序是很特別的排序算法，<br>依照元素的每個位數排好，最終結果就會是排好的元素。</p><h2 id="實作-10"><a href="#實作-10" class="headerlink" title="實作"></a>實作</h2><p>縱使算法看起來要將元素顛三倒四，<br>但實作上有非常精巧的方法，<br>透過記錄元素位數的偏移量來將元素放置到正確的位置上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 取得數字的某位數 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_digit</span><span class="params">(<span class="type">int</span> number, <span class="type">int</span> digit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = (<span class="type">int</span>) <span class="built_in">pow</span>(<span class="number">10</span>, digit);                           <span class="comment">// 取得目標位數 10 的冪次</span></span><br><span class="line">    <span class="type">int</span> b = (<span class="type">int</span>) <span class="built_in">pow</span>(<span class="number">10</span>, digit - <span class="number">1</span>);                       <span class="comment">// 取的低一位數 10 的冪次</span></span><br><span class="line">    number = number % a / b;                                <span class="comment">// 取的目標位數</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) <span class="built_in">floor</span>(number);                             <span class="comment">// 取整返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 取得目前最大的元素 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_max_number</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">-1</span>;                                        <span class="comment">// 如果沒有元素則回傳 -1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)                           <span class="comment">// 遍歷所有元素</span></span><br><span class="line">        <span class="keyword">if</span> (number &lt; arr[i])                                <span class="comment">// 比對最大的元素</span></span><br><span class="line">            number = arr[i];                                <span class="comment">// 紀錄最大值</span></span><br><span class="line">    <span class="keyword">return</span> number;                                          <span class="comment">// 回傳最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基數排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radix_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max_number = <span class="built_in">get_max_number</span>(arr, len);              <span class="comment">// 取得最大的數字</span></span><br><span class="line">    <span class="type">int</span> max_digit = (<span class="type">int</span>) <span class="built_in">ceil</span>(<span class="built_in">log10</span>(max_number));          <span class="comment">// 取的最大數字的位數</span></span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[len];                                <span class="comment">// 暫存的陣列</span></span><br><span class="line">    <span class="type">int</span> index[<span class="number">11</span>];                                          <span class="comment">// 記錄某位數的偏移量</span></span><br><span class="line">    <span class="type">int</span> count[<span class="number">11</span>];                                          <span class="comment">// 記錄某位數的數量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= max_digit; i++)                    <span class="comment">// 遍歷位數</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)                        <span class="comment">// 清空紀錄位數數量</span></span><br><span class="line">            count[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)                       <span class="comment">// 紀錄位數的數量</span></span><br><span class="line">            count[<span class="built_in">get_digit</span>(arr[j], i)]++;</span><br><span class="line">        index[<span class="number">0</span>] = <span class="number">0</span>;                                       <span class="comment">// 位數 0 的偏移量為 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)                        <span class="comment">// 依序記錄每一位的偏移量</span></span><br><span class="line">            index[j + <span class="number">1</span>] = index[j] + count[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)                       <span class="comment">// 利用偏移量將元素放置到正確的位置</span></span><br><span class="line">            tmp[index[<span class="built_in">get_digit</span>(arr[j], i)]++] = arr[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)                       <span class="comment">// 把暫存的陣列回寫</span></span><br><span class="line">            arr[j] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> tmp;                                             <span class="comment">// 清理空間</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>為使程式易讀，建議非關鍵功能獨立成副函式。</p>          </div><div class="note warning">            <p>注意引入 cmath 或 math.h 標頭檔，以便使用 ceil、log 與 pow 函數。</p>          </div><div class="note warning">            <p>小心隱式型別轉換可能導致的問題。</p>          </div><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><p>中文為「合併排序」<br>重要的排序算法，同時也是排序問題最佳算法之一，<br>因為很容易解釋 $O(nlg(n))$ 的關係，似乎常被拿來當教材。</p><p>跟快速排序是相對的存在，且被大量函式庫實作：</p><table><thead><tr><th align="left">使用案例</th><th align="left">排序演算法</th></tr></thead><tbody><tr><td align="left">Perl 5.8 Default</td><td align="left">合併排序</td></tr><tr><td align="left">Linux Kernel(linked list)</td><td align="left">合併排序</td></tr><tr><td align="left">Java Arrays.sort()</td><td align="left">Tim Sort（源於合併與插入排序）</td></tr><tr><td align="left">Python Default</td><td align="left">Tim Sort（源於合併與插入排序）</td></tr><tr><td align="left">GNU Octave</td><td align="left">Tim Sort（源於合併與插入排序）</td></tr></tbody></table><h2 id="實作-11"><a href="#實作-11" class="headerlink" title="實作"></a>實作</h2><p>下面是遞迴的實作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 合併函數 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> *arr1, <span class="type">int</span> *arr2, <span class="type">int</span> len, <span class="type">int</span> len1, <span class="type">int</span> len2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index1 = <span class="number">0</span>;                                         <span class="comment">// 從第一個子陣列的第 0 個元素開始合併</span></span><br><span class="line">    <span class="type">int</span> index2 = <span class="number">0</span>;                                         <span class="comment">// 從第二個子陣列的第 0 個元素開始合併</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)                           <span class="comment">// 依序將元素填入合併陣列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 == len1)                                 <span class="comment">// 如果第一個子陣列已經填完</span></span><br><span class="line">            arr[i] = arr2[index2++];                        <span class="comment">// 把第二個子陣列的元素全部塞給合併陣列</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index2 == len2)                            <span class="comment">// 如果第二個子陣列已經填完</span></span><br><span class="line">            arr[i] = arr1[index1++];                        <span class="comment">// 把第一個子陣列的元素全部塞給合併陣列</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr1[index1] &lt; arr2[index2])               <span class="comment">// 第一個子陣列的元素較小</span></span><br><span class="line">            arr[i] = arr1[index1++];                        <span class="comment">// 把第一個子陣列的元素塞給合併陣列</span></span><br><span class="line">        <span class="keyword">else</span>                                                <span class="comment">// 第二個子陣列的元素較小（或相等）</span></span><br><span class="line">            arr[i] = arr2[index2++];                        <span class="comment">// 把第二個子陣列的元素塞給合併陣列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 合併排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1</span>)                                            <span class="comment">// 如果元素有多個</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> left_len = len / <span class="number">2</span>;                             <span class="comment">// 計算分割後，第一個子陣列的長度</span></span><br><span class="line">        <span class="type">int</span> right_len = len - left_len;                     <span class="comment">// 計算分割後，第二個子陣列的長度</span></span><br><span class="line">        <span class="type">int</span> *left = <span class="keyword">new</span> <span class="type">int</span>[left_len];                      <span class="comment">// 建立第一個子陣列</span></span><br><span class="line">        <span class="type">int</span> *right = <span class="keyword">new</span> <span class="type">int</span>[right_len];                    <span class="comment">// 建立第二個子陣列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left_len; i++)                  <span class="comment">// 將元素分配到第一個子陣列</span></span><br><span class="line">            left[i] = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = left_len; i &lt; len; i++)                <span class="comment">// 將元素分配到第二個子陣列</span></span><br><span class="line">            right[i - left_len] = arr[i];</span><br><span class="line">        <span class="built_in">merge_sort</span>(left, left_len);                         <span class="comment">// 對第一個子陣列遞迴</span></span><br><span class="line">        <span class="built_in">merge_sort</span>(right, right_len);                       <span class="comment">// 對第二個子陣列遞迴</span></span><br><span class="line">        <span class="built_in">merge</span>(arr, left, right, len, left_len, right_len);  <span class="comment">// 將兩個子陣列合併回傳</span></span><br><span class="line">        <span class="keyword">delete</span> left;                                        <span class="comment">// 清理空間</span></span><br><span class="line">        <span class="keyword">delete</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note warning">            <p>如果合併函數不使用原始陣列的位置操作，而是另外建立空間，則需要回傳指標。</p>          </div><p>從觀察遞迴的版本可以發現，每次都是由 2 個元素（或 1 個）開始組合，<br>然後逐漸變成 4 個、8 個慢慢增加，正因為排序的關鍵在於合併，<br>也許可以透過迴圈模擬遞迴的過程。</p><p>下面是非遞迴的實作，使用了同樣的合併函數（參考上面）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 整數箝制函數 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clamp</span><span class="params">(<span class="type">int</span> number, <span class="type">int</span> lower_bound, <span class="type">int</span> upper_bound)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; upper_bound)                                           <span class="comment">// 如果數字大過上界</span></span><br><span class="line">        <span class="keyword">return</span> upper_bound;                                             <span class="comment">// 讓數字等於上界回傳</span></span><br><span class="line">    <span class="keyword">if</span> (number &lt; lower_bound)                                           <span class="comment">// 如果數字小於下界</span></span><br><span class="line">        <span class="keyword">return</span> lower_bound;                                             <span class="comment">// 讓數字等於下界回傳</span></span><br><span class="line">    <span class="keyword">return</span> number;                                                      <span class="comment">// 數字在範圍內直接回傳</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 合併排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sub_len = <span class="number">2</span>;                                                    <span class="comment">// 由兩兩合併開始</span></span><br><span class="line">    <span class="keyword">while</span> (sub_len &lt;= len * <span class="number">2</span>)                                          <span class="comment">// 直到下個 2^n 停止</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += sub_len)                          <span class="comment">// 對每個區段進行處理</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left_len = sub_len / <span class="number">2</span>;                                 <span class="comment">// 取得每區段左半邊的長度</span></span><br><span class="line">            <span class="type">int</span> right_len = sub_len - left_len;                         <span class="comment">// 取得每區段右半邊的長度</span></span><br><span class="line">            <span class="type">int</span> *left = arr + i;                                        <span class="comment">// 取得每區段左半邊的開頭</span></span><br><span class="line">            <span class="type">int</span> *right = left + left_len;                               <span class="comment">// 取得每區段右半邊的開頭</span></span><br><span class="line">            left_len = <span class="built_in">clamp</span>(left_len, <span class="number">0</span>, (arr + len) - left);          <span class="comment">// 處理區段左半邊界問題</span></span><br><span class="line">            right_len = <span class="built_in">clamp</span>(right_len, <span class="number">0</span>, (arr + len) - right);       <span class="comment">// 處理區段右半邊界問題</span></span><br><span class="line">            <span class="type">int</span> *sub_arr = <span class="keyword">new</span> <span class="type">int</span>[sub_len];                            <span class="comment">// 暫時的合併陣列</span></span><br><span class="line">            <span class="built_in">merge</span>(sub_arr, left, right, sub_len, left_len, right_len);  <span class="comment">// 合併左右半邊到暫時的合併陣列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sub_len; j++)                           <span class="comment">// 將暫時的合併陣列複製到原陣列</span></span><br><span class="line">                arr[i + j] = sub_arr[j];</span><br><span class="line">            <span class="keyword">delete</span> sub_arr;                                             <span class="comment">// 清理空間</span></span><br><span class="line">        &#125;</span><br><span class="line">        sub_len *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note warning">            <p>箝制函數 (clamp) 在 C++17 中有預先定義，請參考 <a href="http://en.cppreference.com/w/cpp/algorithm/clamp">cppreference std::clamp</a></p>          </div><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><p>中文為「快速排序」<br>快速排序可以說是最重要的排序算法，<br>有著 $O(nlg(n))$ 的複雜度，但平均情況下又勝過其他排序。</p><h2 id="實作-12"><a href="#實作-12" class="headerlink" title="實作"></a>實作</h2><p>以下是遞迴版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 快速排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1</span>)                                        <span class="comment">// 如果還有元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> *pivot = arr;                               <span class="comment">// 選擇一個參考值（這裡選擇陣列開頭）</span></span><br><span class="line">        <span class="type">int</span> *left = arr + <span class="number">1</span>;                            <span class="comment">// 左註標從陣列開頭的右邊一個開始</span></span><br><span class="line">        <span class="type">int</span> *right = arr + len - <span class="number">1</span>;                     <span class="comment">// 右註標從陣列結尾開始</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)                            <span class="comment">// 如果左、右註標還沒重合</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (*left &lt; *pivot &amp;&amp; left &lt; right)      <span class="comment">// 左註標尋找大於參考值的元素</span></span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">while</span> (*right &gt;= *pivot &amp;&amp; left &lt; right)    <span class="comment">// 右註標尋找小於參考值的元素</span></span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right)                           <span class="comment">// 如果註標還沒重合就交換元素</span></span><br><span class="line">                <span class="built_in">swap</span>(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*left &lt; *pivot)                             <span class="comment">// 檢查左註標的值跟參考值的關係</span></span><br><span class="line">            <span class="built_in">swap</span>(pivot, left);                          <span class="comment">// 如果不符順序把參考值換到左邊</span></span><br><span class="line">        <span class="type">int</span> *start = arr;                               <span class="comment">// 設定序列開頭</span></span><br><span class="line">        <span class="type">int</span> *end = arr + len;                           <span class="comment">// 設定序列結尾</span></span><br><span class="line">        <span class="type">int</span> *center = left;                             <span class="comment">// 中間的註標（左、右註標因重合都可以選）</span></span><br><span class="line">        <span class="built_in">quick_sort</span>(start, center - start);              <span class="comment">// 遞迴左半部分</span></span><br><span class="line">        <span class="built_in">quick_sort</span>(center, end - center);               <span class="comment">// 遞迴右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>也可以使用堆疊模擬這個過程，下面是非遞迴版本的快速排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 快速排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; index;                                 <span class="comment">// 宣告一個暫存區間的註標</span></span><br><span class="line">    stack&lt;pair&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt;&gt; stack;                          <span class="comment">// 宣告一個存放區間的堆疊</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)                                           <span class="comment">// 根本沒東西可以排</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    stack.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(arr, arr + len - <span class="number">1</span>));              <span class="comment">// 將整段陣列區間放入堆疊</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>())                                  <span class="comment">// 如果還沒處理完</span></span><br><span class="line">    &#123;</span><br><span class="line">        index = stack.<span class="built_in">top</span>();                                <span class="comment">// 從堆疊中取出待處理的區間</span></span><br><span class="line">        stack.<span class="built_in">pop</span>();                                        <span class="comment">// 從堆疊中刪除待處理的區間</span></span><br><span class="line">        <span class="type">int</span> *pivot = index.first;                           <span class="comment">// 選擇一個參考值（這裡選擇陣列開頭）</span></span><br><span class="line">        <span class="type">int</span> *left = index.first + <span class="number">1</span>;                        <span class="comment">// 左註標從待處理處開頭的右邊一個開始</span></span><br><span class="line">        <span class="type">int</span> *right = index.second;                          <span class="comment">// 右註標從待處理處結尾開始</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)                                <span class="comment">// 如果左、右註標還沒重合</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (*left &lt; *pivot &amp;&amp; left &lt; right)          <span class="comment">// 左註標尋找大於參考值的元素</span></span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">while</span> (*right &gt;= *pivot &amp;&amp; left &lt; right)        <span class="comment">// 右註標尋找小於參考值的元素</span></span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right)                               <span class="comment">// 如果註標還沒重合就交換元素</span></span><br><span class="line">                <span class="built_in">swap</span>(left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*left &lt; *pivot)                                 <span class="comment">// 檢查左註標的值跟參考值的關係</span></span><br><span class="line">            <span class="built_in">swap</span>(pivot, left);                              <span class="comment">// 如果不符順序把參考值換到左邊</span></span><br><span class="line">        <span class="type">int</span> *center = left;                                 <span class="comment">// 中間的註標（左、右註標因重合都可以選）</span></span><br><span class="line">        <span class="keyword">if</span> (index.first &lt; center - <span class="number">1</span>)                       <span class="comment">// 如果左半段未完成</span></span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(index.first, center - <span class="number">1</span>)); <span class="comment">// 將左半段待處理的區間放入堆疊</span></span><br><span class="line">        <span class="keyword">if</span> (center &lt; index.second)                          <span class="comment">// 如果右半段未完成</span></span><br><span class="line">            stack.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(center, index.second));    <span class="comment">// 將右半段待處理的區間放入堆疊</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>非遞迴版的區間註標可以透過 Struct 實作。</p>          </div><div class="note warning">            <p>注意引入 stack 或 utility 標頭檔，以便使用 stack 及 pair 物件。</p>          </div><div class="note warning">            <p>快速排序的實作有很多細節，可以先在紙上模擬這些步驟以利實作。</p>          </div><h1 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h1><p>中文為「二元搜尋樹」<br>利用二元樹資料結構的排序方法。</p><p>事實上，只要建立一個二元搜尋樹後，<br>使用中序走訪便可以得到排序完成的結果。</p><h2 id="實作-13"><a href="#實作-13" class="headerlink" title="實作"></a>實作</h2><p>實作時，可以建立先「二元搜尋樹」的類別並實作方法。<br>下面是二元搜尋樹節點的類別：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 二元樹的節點類別 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinaryTreeNode</span>(<span class="type">int</span> data);                <span class="comment">// 建構函數</span></span><br><span class="line">    <span class="type">int</span> data;                                <span class="comment">// 儲存的值</span></span><br><span class="line">    BinaryTreeNode *left;                    <span class="comment">// 左子節點</span></span><br><span class="line">    BinaryTreeNode *right;                   <span class="comment">// 右子節點</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建構函數 */</span></span><br><span class="line">BinaryTreeNode::<span class="built_in">BinaryTreeNode</span>(<span class="type">int</span> data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = data;                       <span class="comment">// 儲存值</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;                    <span class="comment">// 初始化左子節點</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;                   <span class="comment">// 初始化右子節點</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>節點也可以透過 Struct 實做。</p>          </div><p>雖然有實作過完整的二元樹，<br>但其實排序功能其實不需要太多的方法。</p><p>由於實際上外部調用不需要知道樹根的指標，<br>實作上可以透過重載函數的方法隱藏起來，<br>另外取回排序過的值時，傳入陣列的開頭利用註標及中序走訪依序取回。</p><p>下面是二元樹的類別：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二元搜尋樹的類別 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BinaryTree</span>();                                           <span class="comment">// 建構函數</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> data)</span></span>;                                    <span class="comment">// 新增節點（外部調用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gain</span><span class="params">(<span class="type">int</span> *arr)</span></span>;                                    <span class="comment">// 把值依序取回的函數</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BinaryTreeNode *root;                                   <span class="comment">// 樹根</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(BinaryTreeNode *root, <span class="type">int</span> data)</span></span>;              <span class="comment">// 新增節點（內部調用）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(BinaryTreeNode *root, <span class="type">int</span> *arr)</span></span>;         <span class="comment">// 中序走訪（內部調用）</span></span><br><span class="line">    <span class="type">int</span> index;                                              <span class="comment">// 用於把值回存的註標</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 建構函數 */</span></span><br><span class="line">BinaryTree::<span class="built_in">BinaryTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;root = <span class="literal">nullptr</span>;                                   <span class="comment">// 初始化樹根</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新增節點（外部調用） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::push</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">push</span>(<span class="keyword">this</span>-&gt;root, data);                           <span class="comment">// 調用內部新增節點</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 把值依序取回的函數 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::gain</span><span class="params">(<span class="type">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;index = <span class="number">0</span>;                                        <span class="comment">// 初始化註標</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">traversal</span>(<span class="keyword">this</span>-&gt;root, arr);                       <span class="comment">// 調用內部中序走訪</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 新增節點（內部調用） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::push</span><span class="params">(BinaryTreeNode *root, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;root == <span class="literal">nullptr</span>)                              <span class="comment">// 如果樹為空</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">BinaryTreeNode</span>(data);              <span class="comment">// 新增節點成為根</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;data &gt; data)                             <span class="comment">// 樹不為空，且值比根的值小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>)                          <span class="comment">// 如果左子樹為空</span></span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> <span class="built_in">BinaryTreeNode</span>(data);          <span class="comment">// 新增節點成為左子樹</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">push</span>(root-&gt;left, data);                   <span class="comment">// 新增節點到左子樹的某處</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                                                    <span class="comment">// 樹不為空，且值比根的值大</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>)                         <span class="comment">// 如果右子樹為空</span></span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> <span class="built_in">BinaryTreeNode</span>(data);         <span class="comment">// 新增節點成為右子樹</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">this</span>-&gt;<span class="built_in">push</span>(root-&gt;right, data);                  <span class="comment">// 新增節點到右子樹的某處</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中序走訪（內部調用） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::traversal</span><span class="params">(BinaryTreeNode *root, <span class="type">int</span> *arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)                                    <span class="comment">// 樹根有東西才繼續</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>)                          <span class="comment">// 如果左子樹還有東西</span></span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;left, arr);                     <span class="comment">// 去左子樹找節點</span></span><br><span class="line">        arr[<span class="keyword">this</span>-&gt;index] = root-&gt;data;                      <span class="comment">// 把值存回去</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;index++;                                      <span class="comment">// 增加註標</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>)                         <span class="comment">// 如果右子樹還有東西</span></span><br><span class="line">            <span class="built_in">traversal</span>(root-&gt;right, arr);                    <span class="comment">// 去右子樹找節點</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>調用的時候就相當簡單了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 二元搜尋樹排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binary_tree_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinaryTree tree;                <span class="comment">// 宣告二元搜尋樹</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)   <span class="comment">// 將陣列的值儲存至二元樹</span></span><br><span class="line">        tree.<span class="built_in">push</span>(arr[i]);</span><br><span class="line">    tree.<span class="built_in">gain</span>(arr);                 <span class="comment">// 取回排序過的值</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note warning">            <p>存在許多封裝資料結構的設計方法；<br>然而這裡的這個方法存在一個瑕疵，當儲存的節點數目跟陣列大小不符時會出錯，<br>但待排序的內容為串列結構時，可能很適合這樣的二元樹排序技巧。</p>          </div><h1 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h1><p>中文為「堆積排序」<br>堆積是完全二元樹，雖然是二元樹但性質與二元搜尋樹不同。<br>作為排序算法使用時，是借助本身的特性來使用，<br>是速度非常快的排序算法。</p><div class="note info">            <p>堆積通常使用陣列模擬，而且第 0 個位置通常不用。</p>          </div><h2 id="實作-14"><a href="#實作-14" class="headerlink" title="實作"></a>實作</h2><p>傳統的做法，主要圍繞在建立堆積與取出堆積資料兩個步驟。<br>在建立堆積時，先將資料放在樹葉節點上，然後向上調整；<br>取出資料時，將樹根與樹葉節點交換，然後裁取樹葉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 堆積排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *heap = <span class="keyword">new</span> <span class="type">int</span>[len + <span class="number">1</span>];                   <span class="comment">// 宣告堆積</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span>; i++)               <span class="comment">// 初始化堆積</span></span><br><span class="line">        heap[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> leaf = <span class="number">1</span>;                                   <span class="comment">// 堆積樹葉的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)                   <span class="comment">// 插入所有的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        heap[leaf] = arr[i];                        <span class="comment">// 先放在樹葉的位置</span></span><br><span class="line">        <span class="type">int</span> tmp = leaf;                             <span class="comment">// 調整堆積</span></span><br><span class="line">        <span class="keyword">while</span> (heap[tmp / <span class="number">2</span>] &gt; heap[tmp])           <span class="comment">// 如果父節點大於子節點</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(&amp;heap[tmp / <span class="number">2</span>], &amp;heap[tmp]);       <span class="comment">// 交換父節點與子節點</span></span><br><span class="line">            tmp /= <span class="number">2</span>;                               <span class="comment">// 繼續看祖父節點</span></span><br><span class="line">        &#125;</span><br><span class="line">        leaf++;                                     <span class="comment">// 插入完成後樹葉的位置遞增</span></span><br><span class="line">    &#125;</span><br><span class="line">    leaf -= <span class="number">1</span>;                                      <span class="comment">// 調整樹葉的位置到有元素的空間</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)                   <span class="comment">// 取得所有元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;heap[<span class="number">1</span>], &amp;heap[leaf]);                <span class="comment">// 交換樹根到樹葉的位置</span></span><br><span class="line">        arr[i] = heap[leaf];                        <span class="comment">// 取得樹葉的值</span></span><br><span class="line">        leaf--;                                     <span class="comment">// 裁掉樹葉</span></span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">1</span>;                                <span class="comment">// 調整堆積（從樹根開始）</span></span><br><span class="line">        <span class="keyword">while</span> ((tmp * <span class="number">2</span>) &lt;= leaf)                   <span class="comment">// 如果還有子節點</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left = tmp * <span class="number">2</span>;                     <span class="comment">// 左子節點的註標</span></span><br><span class="line">            <span class="type">int</span> right = tmp * <span class="number">2</span> + <span class="number">1</span>;                <span class="comment">// 右子節點的註標</span></span><br><span class="line">            <span class="keyword">if</span> (right &gt; leaf)                       <span class="comment">// 右子節點超過範圍</span></span><br><span class="line">                right = left;                       <span class="comment">// 假裝左子節點為右子節點</span></span><br><span class="line">            <span class="type">int</span> target;                             <span class="comment">// 取得較小的節點</span></span><br><span class="line">            <span class="keyword">if</span> (heap[left] &lt; heap[right])           <span class="comment">// 左子節點比較小</span></span><br><span class="line">                target = left;                      <span class="comment">// 往左子節點的方向調整</span></span><br><span class="line">            <span class="keyword">else</span>                                    <span class="comment">// 右子節點比較小</span></span><br><span class="line">                target = right;                     <span class="comment">// 往右子節點的方向調整</span></span><br><span class="line">            <span class="keyword">if</span> (heap[tmp] &gt; heap[target])           <span class="comment">// 子節點比較小</span></span><br><span class="line">                <span class="built_in">swap</span>(&amp;heap[tmp], &amp;heap[target]);    <span class="comment">// 交換子節點到樹根的位置</span></span><br><span class="line">            tmp = target;                           <span class="comment">// 往下一層調整</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> heap;                                    <span class="comment">// 清理空間</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>自從上了演算法課後，課程中學到了更精闢的堆積處理技巧：</p><ul><li>獨立出「從指定節點調整堆積」的函數</li><li>直接塞入所有資料到堆積，然後從倒數第二層調整堆積至樹根</li><li>取出資料直接採用覆蓋的方式，而非資料交換</li></ul><p>這個做法大幅度降低了資料在堆積中搬移與交換的時間。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 從指定節點調整堆積 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">restore</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> *heap, <span class="type">int</span> leaf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((node * <span class="number">2</span>) &lt;= leaf)                  <span class="comment">// 如果還有子節點</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span> * node;                    <span class="comment">// 左子節點的註標</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">2</span> * node + <span class="number">1</span>;               <span class="comment">// 右子節點的註標</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; leaf)                       <span class="comment">// 右子節點超過範圍</span></span><br><span class="line">            right = left;                       <span class="comment">// 假裝左子節點為右子節點</span></span><br><span class="line">        <span class="type">int</span> target;                             <span class="comment">// 取得較小的節點</span></span><br><span class="line">        <span class="keyword">if</span> (heap[left] &lt; heap[right])           <span class="comment">// 左子節點比較小</span></span><br><span class="line">            target = left;                      <span class="comment">// 往左子節點的方向調整</span></span><br><span class="line">        <span class="keyword">else</span>                                    <span class="comment">// 右子節點比較小</span></span><br><span class="line">            target = right;                     <span class="comment">// 往右子節點的方向調整</span></span><br><span class="line">        <span class="keyword">if</span> (heap[node] &lt; heap[target])          <span class="comment">// 如果子節點比較大</span></span><br><span class="line">            <span class="keyword">break</span>;                              <span class="comment">// 直接結束</span></span><br><span class="line">        <span class="built_in">swap</span>(&amp;heap[node], &amp;heap[target]);       <span class="comment">// 交換子節點到根的位置</span></span><br><span class="line">        node = target;                          <span class="comment">// 往下一層調整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 推積排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *heap = <span class="keyword">new</span> <span class="type">int</span>[len + <span class="number">1</span>];               <span class="comment">// 宣告堆積</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)               <span class="comment">// 先把所有資料塞入堆積</span></span><br><span class="line">        heap[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (<span class="type">int</span>)(len / <span class="number">2</span>); i &gt;= <span class="number">1</span>; i--)   <span class="comment">// 從倒數第二層開始調整堆積</span></span><br><span class="line">        <span class="built_in">restore</span>(i, heap, len);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;                              <span class="comment">// 從堆積回存資料</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len; i &gt;= <span class="number">1</span>; i--)              <span class="comment">// 對每筆資料</span></span><br><span class="line">    &#123;</span><br><span class="line">        arr[index++] = heap[<span class="number">1</span>];                 <span class="comment">// 從樹根取回資料</span></span><br><span class="line">        heap[<span class="number">1</span>] = heap[i];                      <span class="comment">// 把樹葉移到樹根</span></span><br><span class="line">        <span class="built_in">restore</span>(<span class="number">1</span>, heap, i);                    <span class="comment">// 重新調整堆積</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> heap;                                <span class="comment">// 清理空間</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Stooge-Sort"><a href="#Stooge-Sort" class="headerlink" title="Stooge Sort"></a>Stooge Sort</h1><p>中文為「臭皮匠排序」<br>《算法導論》思考題中的低效排序算法，<br>雖然算法本身不實用，但是很好的練習題材。</p><p>概念很簡單，從最大的序列開始，如果第一個跟最後一個順序不對則交換，<br>如果序列大於三，則依序對「前2&#x2F;3個元素」、「後2&#x2F;3個元素」、「前2&#x2F;3個元素」，<br>重複使用臭皮匠排序，最後就會排完。</p><div class="note info">            <p>wikipedia 的說明簡單明瞭，可參閱 <a href="https://en.wikipedia.org/wiki/Stooge_sort">wikipedia: Stooge sort</a></p>          </div><h2 id="實作-15"><a href="#實作-15" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/* 臭皮匠排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stooge_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; arr[len - <span class="number">1</span>])              <span class="comment">// 如果順序不對則交換</span></span><br><span class="line">        <span class="built_in">swap</span>(&amp;arr[<span class="number">0</span>], &amp;arr[len - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (len &gt;= <span class="number">3</span>)                           <span class="comment">// 序列長度大於 3</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = (<span class="type">int</span>)(len / <span class="number">3</span>);           <span class="comment">// 分成 3 等份</span></span><br><span class="line">        <span class="built_in">stooge_sort</span>(arr, len - tmp);        <span class="comment">// 前 2/3 個元素排序</span></span><br><span class="line">        <span class="built_in">stooge_sort</span>(arr + tmp, len - tmp);  <span class="comment">// 後 2/3 個元素排序</span></span><br><span class="line">        <span class="built_in">stooge_sort</span>(arr, len - tmp);        <span class="comment">// 前 2/3 個元素排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Sleep-Sort"><a href="#Sleep-Sort" class="headerlink" title="Sleep Sort"></a>Sleep Sort</h1><p>中文為「睡眠排序」<br>充滿魔性的排序方法，根據數值的大小設定延遲進入陣列的時間。</p><div class="note warning">            <p>等待時間的單位越小，越容易給出錯誤的答案。</p>          </div><h2 id="實作-16"><a href="#實作-16" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* 執行序的函數 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> *arr, <span class="type">int</span> *index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(value));    <span class="comment">// 設定延遲時間</span></span><br><span class="line">    arr[*index] = value;                                    <span class="comment">// 讓數值進入陣列</span></span><br><span class="line">    (*index)++;                                             <span class="comment">// 累計註標</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    thread *tasks = <span class="keyword">new</span> thread[len];                        <span class="comment">// 宣告執行緒</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;                                          <span class="comment">// 設定註標</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)                           <span class="comment">// 為每個元素設定執行緒函數</span></span><br><span class="line">        tasks[i] = <span class="built_in">thread</span>(wait, arr[i], arr, &amp;index);       <span class="comment">// 傳入數值、陣列的位置、註標的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)                           <span class="comment">// 開始讓每個元素的執行緒函數執行</span></span><br><span class="line">        tasks[i].<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">delete</span> tasks;                                           <span class="comment">// 清理空間</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="Bogo-Sort"><a href="#Bogo-Sort" class="headerlink" title="Bogo Sort"></a>Bogo Sort</h1><p>中文為「猴子排序」<br>簡單的說，就是隨機洗牌，然後檢查是否排好的排序算法。<br>雖然不實用，但是具有特別的教育意義。</p><h2 id="實作-17"><a href="#實作-17" class="headerlink" title="實作"></a>實作</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bogo_sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time_t</span>(<span class="literal">NULL</span>));                        <span class="comment">// 設定亂數種子</span></span><br><span class="line">    <span class="type">bool</span> sorted = <span class="literal">false</span>;                        <span class="comment">// 排序未完成</span></span><br><span class="line">    <span class="keyword">while</span> (sorted == <span class="literal">false</span>)                     <span class="comment">// 如果排序未完成</span></span><br><span class="line">    &#123;</span><br><span class="line">        sorted = <span class="literal">true</span>;                          <span class="comment">// 假設排序完成</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)           <span class="comment">// 隨機把位置上的元素跟其他元素交換</span></span><br><span class="line">            <span class="built_in">swap</span>(&amp;arr[i], &amp;arr[<span class="built_in">rand</span>() % len]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)           <span class="comment">// 檢查排序是否完成</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>])            <span class="comment">// 如果排序沒有完成</span></span><br><span class="line">                sorted = <span class="literal">false</span>;                 <span class="comment">// 假設錯誤</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note danger">            <p>注意不要輸入過大的測資，以免當機。</p>          </div><h1 id="綜合評估"><a href="#綜合評估" class="headerlink" title="綜合評估"></a>綜合評估</h1><table><tr><th>中文名稱</th><th>英文名稱</th><th>最糟複雜度</th><th>最優複雜度</th><th colspan="3">簡介</th></tr><tr><td>氣泡排序</td><td>Bubble Sort</td><td>$O(n^{2})$</td><td>$O(n)$</td><td colspan="3">依序選擇相鄰的元素比較、交換的排序方法</td></tr><tr><td>選擇排序</td><td>Selection Sort</td><td>$O(n^{2})$</td><td>$O(n)$</td><td colspan="3">重複在未排序的區間選擇最小的放到正確的位置</td></tr><tr><td>插入排序</td><td>Insertion Sort</td><td>$O(n^{2})$</td><td>$O(n)$</td><td colspan="3">移動其他元素，並在找到插入點時插入正確的元素</td></tr><tr><td>雞尾酒排序</td><td>Cocktail Sort</td><td>$O(n^{2})$</td><td>$O(n)$</td><td colspan="3">左右來回的氣泡排序</td></tr><tr><td>梳排序</td><td>Comb Sort</td><td>$O(n^{2})$</td><td>$O(nlg(n))$</td><td colspan="3">間距上的元素順序不符則交換，間距逐次遞減</td></tr><tr><td>地精排序</td><td>Gnome Sort</td><td>$O(n^{2})$</td><td>$O(n)$</td><td colspan="3">到未排序的區間透過相鄰交換，將元素換到正確的位置上</td></tr><tr><td>奇偶排序</td><td>Odd-even Sort</td><td>$O(n^{2})$</td><td>$O(n)$ *平行</td><td colspan="3">分奇數位置、偶數位置，分別做氣泡排序</td></tr><tr><td>希爾排序</td><td>Shell Sort</td><td>$O(n^{2})$</td><td>$O(nlg(n))$</td><td colspan="3">對固定間距的元素做插入排序，間距逐次遞減</td></tr><tr><td>桶子排序</td><td>Bucket Sort</td><td>$O(n^{2})$</td><td>-</td><td colspan="3">將元素分群，對不同群做好排序再合併</td></tr><tr><td>計數排序</td><td>Counting Sort</td><td>$O(n+k)$</td><td>-</td><td colspan="3">紀錄每種元素的出現次數，利用出現次數重新排列數字</td></tr><tr><td>基數排序</td><td>Radix Sort</td><td>$O(wn)$</td><td>-</td><td colspan="3">依序對每一位做排序，位數逐次遞增（或遞減）</td></tr><tr><td>合併排序</td><td>Merge Sort</td><td>$O(nlg(n))$</td><td>$O(n)$</td><td colspan="3">將元素分成兩半，直至無法分開後，依照順序合併</td></tr><tr><td>快速排序</td><td>Quick Sort</td><td>$O(n^{2})$</td><td>$O(nlg(n))$</td><td colspan="3">選擇參考元素，將其他元素與其比較並放到其中一邊</td></tr><tr><td>二元搜尋樹</td><td>Binary Search Tree</td><td>$O(n^{2})$</td><td>$O(nlg(n))$</td><td colspan="3">利用資料建立一顆二元搜尋樹後透過中序走訪取得元素</td></tr><tr><td>堆積排序</td><td>Heap Sort</td><td>$O(nlg(n))$</td><td>$O(nlg(n))$</td><td colspan="3">利用資料建立堆積，依序取出堆積的樹根，再調整堆積</td></tr><tr><td>臭皮匠排序</td><td>Stooge Sort</td><td>$O(n^{lg(3)/lg(1.5)})$</td><td>$O(n^{lg(3)/lg(1.5)})$</td><td colspan="3">起始結束位置不對則交換，遞迴調用前、後、前2/3個元素</td></tr><tr><td>睡眠排序</td><td>Sleep Sort</td><td>$O(max(n))$</td><td>$O(max(n))$</td><td colspan="3">利用數值本身的大小讓系統等待，結束等待同時取回元素</td></tr><tr><td>猴子排序</td><td>Bogo Sort</td><td>$O(\infty)$</td><td>$O(n)$</td><td colspan="3">亂數洗牌，直到順序正確為止</td></tr></table><h1 id="排序動畫演示"><a href="#排序動畫演示" class="headerlink" title="排序動畫演示"></a>排序動畫演示</h1><iframe scrolling="no" width="100%" height="420px" src="https://jsfiddle.net/L1by5kpt/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="效能評估演示"><a href="#效能評估演示" class="headerlink" title="效能評估演示"></a>效能評估演示</h1><iframe scrolling="no" width="100%" height="600px" src="https://jsfiddle.net/u0pnrwqu/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p>參考資料沒有先後關係。</p><ul><li><a href="https://en.wikipedia.org/wiki/Sorting_algorithm">wikipedia: Sorting algorithm</a></li><li><a href="https://en.wikipedia.org/wiki/Bubble_sort">wikipedia: Bubble sort</a></li><li><a href="https://en.wikipedia.org/wiki/Selection_sort">wikipedia: Selection sort</a></li><li><a href="https://en.wikipedia.org/wiki/Insertion_sort">wikipedia: Insertion sort</a></li><li><a href="https://en.wikipedia.org/wiki/Cocktail_shaker_sort">wikipedia: Cocktail shaker sort</a></li><li><a href="https://en.wikipedia.org/wiki/Comb_sort">wikipedia: Comb sort</a></li><li><a href="https://en.wikipedia.org/wiki/Gnome_sort">wikipedia: Gnome sort</a></li><li><a href="https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort">wikipedia: Odd-even sort</a></li><li><a href="https://en.wikipedia.org/wiki/Shellsort">wikipedia: Shell sort</a></li><li><a href="https://en.wikipedia.org/wiki/Bucket_sort">wikipedia: Bucket sort</a></li><li><a href="https://en.wikipedia.org/wiki/Counting_sort">wikipedia: Counting sort</a></li><li><a href="https://en.wikipedia.org/wiki/Radix_sort">wikipedia: Radix sort</a></li><li><a href="https://en.wikipedia.org/wiki/Merge_sort">wikipedia: Merge sort</a></li><li><a href="https://en.wikipedia.org/wiki/Quicksort">wikipedia: Quicksort</a></li><li><a href="https://en.wikipedia.org/wiki/Tree_sort">wikipedia: Tree sort</a></li><li><a href="https://en.wikipedia.org/wiki/Binary_search_tree">wikipedia: Binary search tree</a></li><li><a href="https://en.wikipedia.org/wiki/Heapsort">wikipedia: Heapsort</a></li><li><a href="https://en.wikipedia.org/wiki/Stooge_sort">wikipedia: Stooge sort</a></li><li><a href="https://it.wikipedia.org/wiki/Sleep_sort">wikipedia: Sleep sort</a></li><li><a href="https://en.wikipedia.org/wiki/Bogosort">wikipedia: Bogosort</a></li><li><a href="http://marklin-blog.logdown.com/posts/1910182">排序之桶子排序法(Bucket Sort)</a></li><li><a href="https://kheresy.wordpress.com/2012/07/06/multi-thread-programming-in-c-thread-p1/">C++ 的多執行序程式開發 Thread：基本使用</a></li><li><a href="https://liam0205.me/2017/05/16/first-step-on-multithread-programming-of-cxx/">程序员的自我修养（五）：C++ 多线程编程初步</a></li><li><a href="http://www.cnblogs.com/kkun/archive/2011/11/23/gnome_sort.html">经典排序算法 - 地精排序Gnome Sort</a></li><li><a href="https://stackoverflow.com/questions/2034712/is-there-any-overhead-for-using-variable-length-arrays">stackoverflow: Is there any overhead for using variable-length arrays?</a></li><li><a href="https://stackoverflow.com/questions/5928699/codejam-2011-solution-for-gorosort">stackoverflow: CodeJam 2011: Solution for Gorosort?</a></li><li><a href="https://stackoverflow.com/questions/9323903/most-efficient-elegant-way-to-clip-a-number">stackoverflow: Most efficient&#x2F;elegant way to clip a number?</a></li><li><a href="https://news.ycombinator.com/item?id=8798202">Hacker News: Sleep sort</a></li><li><a href="http://www.cplusplus.com/reference/thread/this_thread/sleep_for/">cplusplus: sleep_for</a></li><li><a href="http://www.cplusplus.com/reference/cmath/ceil/">cplusplus: ceil</a></li><li><a href="http://www.cplusplus.com/reference/cmath/pow/">cplusplus: pow</a></li><li><a href="http://www.cplusplus.com/reference/cmath/log/">cplusplus: log</a></li><li><a href="http://www.cplusplus.com/reference/algorithm/swap/">cplusplus: swap</a></li><li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">ISO&#x2F;IEC 9899 - Programming languages - open-std</a></li><li><a href="http://www.cplusplus.com/forum/beginner/51496/">cplusplus: A little doubt about delete</a></li><li><a href="http://en.cppreference.com/w/cpp/thread/sleep_for">cppreference: sleep_for</a></li><li><a href="http://en.cppreference.com/w/cpp/algorithm/clamp">cppreference: clamp</a></li><li><a href="https://www.geeksforgeeks.org/merge-sort/">Geeks for Geeks: Merge Sort</a></li><li><a href="https://www.geeksforgeeks.org/iterative-merge-sort/">Geeks for Geeks: Iterative Merge Sort</a></li><li><a href="https://sites.google.com/site/sjdsalg/home">徐熊健@資料結構與演算法 Data Structures and Algorithms</a></li><li><a href="https://baike.baidu.com/item/TimSort/10279720?fr=aladdin">百度百科: TimSort</a></li><li><a href="http://www.blogjava.net/xiaomage234/archive/2015/02/26/423059.html">[译]理解TIMSORT, 第一部分：适应性归并排序(ADAPTIVE MERGESORT)</a></li><li><a href="https://docs.oracle.com/javase/9/docs/api/java/util/Arrays.html#sort-java.lang.Object:A-">Oracle Java: Class Arrays</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>串列 Linked List</title>
      <link href="//linked-list/"/>
      <url>//linked-list/</url>
      
        <content type="html"><![CDATA[<p>串列是資料結構中，一種重要的資料表達方式，<br>這樣的表達方式可以透過指標來完成。</p><span id="more"></span><p>通常，從這個部分開始，<br>可以看出一個人對指標的熟練程度。</p><h1 id="串列結構"><a href="#串列結構" class="headerlink" title="串列結構"></a>串列結構</h1><p>串列的典型做法是使用 struct 實作：</p><div class="note info">            <p>為方便撰寫範例，這裡假設資料為整數。</p>          </div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">// 資料</span></span><br><span class="line">    Node *next; <span class="comment">// 下個節點</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Node *node_1 = new Node; <span class="comment">// 第 1 個節點</span></span><br><span class="line">Node *node_2 = new Node; <span class="comment">// 第 2 個節點</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 把第 2 個節點接在第 1 個後面</span></span><br><span class="line">node_1-&gt;next = node_2;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note info">            <p>串列結構經過良好的封裝更便於使用。</p>          </div><h1 id="創建節點"><a href="#創建節點" class="headerlink" title="創建節點"></a>創建節點</h1><p>可以透過一個函數取得節點，<br>動態建立節點後，記得回傳給主程式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 給定資料建立一個節點</span></span><br><span class="line">Node* <span class="title function_">create</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = new Node; <span class="comment">// 建立新節點</span></span><br><span class="line">    node-&gt;data = value;    <span class="comment">// 設定節點值</span></span><br><span class="line">    node-&gt;next = nullptr;  <span class="comment">// 初始化指標</span></span><br><span class="line">    <span class="keyword">return</span> node;           <span class="comment">// 回傳給主程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下來的插入節點就可以使用這個函數了。</p><h1 id="搜索節點"><a href="#搜索節點" class="headerlink" title="搜索節點"></a>搜索節點</h1><p>我個人認為，搜索節點這件事情，<br>搜索當前節點的效益並不大，通常我們更需要「目標節點的前一個節點」。</p><div class="note info">            <p>「搜索目標節點的前一個節點函數」下面簡稱為「搜前函數」。</p>          </div><p>個人實作時，會先實作搜前函數，<br>搜索節點的函數則透過這個函數間接完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">sreachPrevious</span><span class="params">(Node *root, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = root;</span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != nullptr      <span class="comment">// 不是最後一個節點</span></span><br><span class="line">        &amp;&amp; node-&gt;next-&gt;data != value) <span class="comment">// 而且下個節點的值不是目標</span></span><br><span class="line">        node = node-&gt;next;            <span class="comment">// 繼續搜索</span></span><br><span class="line">    <span class="keyword">return</span> node;                      <span class="comment">// 回傳目標的上一節點或最後一個節點</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>這裡的「root」是樹狀結構的名詞，但串列也可以視作一棵樹。</p>          </div><p>透過搜前函數，可以實做出的搜索功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">sreach</span><span class="params">(Node *root, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;data == value)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    Node *node = sreachPrevious(root, value);</span><br><span class="line">    <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入節點"><a href="#插入節點" class="headerlink" title="插入節點"></a>插入節點</h1><p>插入節點不困難，這裡以插入到末端為例，<br>如果存在一個值不會出現在串列中的話，可以透過搜前函數實作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一個節點到串列的結尾</span></span><br><span class="line">Node* <span class="title function_">insert</span><span class="params">(Node *root, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = create(value);       <span class="comment">// 新建節點</span></span><br><span class="line">    <span class="keyword">if</span> (root == nullptr)              <span class="comment">// 如果串列尚不存在</span></span><br><span class="line">        <span class="keyword">return</span> node;                  <span class="comment">// 回傳給主程序</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node* tail = root;            <span class="comment">// 找尾巴節點</span></span><br><span class="line">        <span class="keyword">while</span> (tail-&gt;next != nullptr)</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">        tail-&gt;next = node;            <span class="comment">// 新增在尾巴</span></span><br><span class="line">        <span class="keyword">return</span> root;                  <span class="comment">// 回傳給主程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info">            <p>插入到特定位置的功能，也可以利用搜前函數的實作。</p>          </div><div class="note warning">            <p>如果不回傳指標給主程序，則建立串列時會出錯。</p>          </div><h1 id="刪除節點"><a href="#刪除節點" class="headerlink" title="刪除節點"></a>刪除節點</h1><p>刪除節點可以直接透過搜前函數實作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">remove</span><span class="params">(Node *root, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *previous = sreachPrevious(root, value);</span><br><span class="line">    Node *target = previous-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (target != nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        previous-&gt;next = target-&gt;next;</span><br><span class="line">        delete target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍歷節點"><a href="#遍歷節點" class="headerlink" title="遍歷節點"></a>遍歷節點</h1><p>對串列進行一堆操作後，檢查串列的正確性，<br>或是有時我們需要對整個串列做特定運算，都需要遍歷功能：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">traversal</span><span class="params">(Node *root, <span class="type">void</span> (*callback)(Node *node))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node *node = root; node != nullptr; node = node-&gt;next)</span><br><span class="line">        callback(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍歷功能的第二個參數是函數的指標，<br>串列的每個節點，會被當成這個函數的傳入值操作。</p><p>以印出節點來說，可以這樣調用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">void</span> <span class="title function_">show</span><span class="params">(Node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; node-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">traversal(root, show);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>演示包含插入與刪除節點，<br>其中插入功能隱含創建節點功能，而刪除功能隱含著搜尋功能。</p><iframe scrolling="no" width="100%" height="130px" src="https://jsfiddle.net/ngkx992u/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 程式設計 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 螢幕解析度問題</title>
      <link href="//linux-screen-display-problem/"/>
      <url>//linux-screen-display-problem/</url>
      
        <content type="html"><![CDATA[<p>我當初剛裝 Linux 時，被雙螢幕的問題搞了許久，<br>這篇主要是做個解決方案的筆記，以免之後又碰到相同的問題。</p><p>本解決方案來自網路上的資料，我將把參考資料陳列於下方。</p><span id="more"></span><div class="note info">            <p>本篇的 Linux 版本為 <a href="https://linuxmint.com/">Linux Mint</a><br>如果你的不是 Linux Mint 的話，解決方案可能大同小異，請參考其他資料處理。</p>          </div><h1 id="解析度問題"><a href="#解析度問題" class="headerlink" title="解析度問題"></a>解析度問題</h1><p>有時候安裝好 Linux 螢幕並不會自動抓到適當的解析度，<br>筆者的雙螢幕中，發生問題的螢幕是電視螢幕，具體參考圖 1。</p><p>我的猜測是，螢幕本身不是電腦螢幕的話，可能發生機會會大得多。</p><p><img src="https://i.imgur.com/w7Kga59.png" alt="圖 1、Linux Mint 螢幕設定畫面"></p><p>如上圖所示，問題螢幕為 DVI-I 輸出，正常情況應為 1920x1080 解析度；<br>但由於某種原因，最高只到 1024x768 解析度。</p><h1 id="解決方案"><a href="#解決方案" class="headerlink" title="解決方案"></a>解決方案</h1><p>我們會利用 cvt 及 xrandr 指令解決這個問題：</p><ul><li>利用 xrandr 找出問題螢幕的代號</li><li>透過 cvt 生成 modeline</li><li>透過 xrandr 以及 modeline 建立解析度</li><li>透過 xrandr 增加解析度到螢幕代號</li><li>設定螢幕為新解析度</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tinytsunami@Tinytsunami-PC ~ $ xrandr</span><br><span class="line">Screen 0: minimum 320 x 200, current 2944 x 1080, maximum 16384 x 16384</span><br><span class="line">DVI-I-1 connected 1024x768+0+0 (normal left inverted right x axis y axis) 0mm x 0mm</span><br><span class="line">   1024x768      60.00* </span><br><span class="line">   800x600       60.32    56.25  </span><br><span class="line">   848x480       60.00  </span><br><span class="line">   640x480       59.94  </span><br><span class="line">HDMI-1 disconnected (normal left inverted right x axis y axis)</span><br><span class="line">VGA-1 connected primary 1920x1080+1024+0 (normal left inverted right x axis y axis) 477mm x 268mm</span><br><span class="line">   1920x1080     60.00*+</span><br><span class="line">   1680x1050     59.95  </span><br><span class="line">   1600x900      60.00  </span><br><span class="line">   1280x1024     60.02  </span><br><span class="line">   1280x800      59.81  </span><br><span class="line">   1280x720      60.00  </span><br><span class="line">   1024x768      60.00  </span><br><span class="line">   800x600       60.32  </span><br><span class="line">   640x480       59.94  </span><br><span class="line">tinytsunami@Tinytsunami-PC ~ $ cvt 1920 1080 60</span><br><span class="line"><span class="comment"># 1920x1080 59.96 Hz (CVT 2.07M9) hsync: 67.16 kHz; pclk: 173.00 MHz</span></span><br><span class="line">Modeline <span class="string">&quot;1920x1080_60.00&quot;</span>  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</span><br><span class="line">tinytsunami@Tinytsunami-PC ~ $ xrandr --newmode <span class="string">&quot;1920x1080_60.00&quot;</span>  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</span><br><span class="line">tinytsunami@Tinytsunami-PC ~ $ xrandr --addmode DVI-I-1 <span class="string">&quot;1920x1080_60.00&quot;</span></span><br><span class="line">tinytsunami@Tinytsunami-PC ~ $ xrandr --output DVI-I-1 --mode 1920x1080_60.00</span><br></pre></td></tr></table></figure><p>這個方法是暫時的，完成這些步驟後，要做一些設定來保存這個配置，<br>我的方案是使用開機執行程式（.sh）開機時自動完成上面那些操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xrandr --newmode <span class="string">&quot;1920x1080_60.00&quot;</span>  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</span><br><span class="line">xrandr --addmode DVI-I-1 1920x1080_60.00</span><br><span class="line">xrandr --output DVI-I-1 --mode 1920x1080_60.00</span><br></pre></td></tr></table></figure><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><p><a href="https://www.ubuntu-tw.org/modules/newbb/viewtopic.php?post_id=161574">https://www.ubuntu-tw.org/modules/newbb/viewtopic.php?post_id=161574</a><br><a href="https://askubuntu.com/questions/377937/how-to-set-a-custom-resolution">https://askubuntu.com/questions/377937/how-to-set-a-custom-resolution</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>羊羽手札更新歷程 01</title>
      <link href="//tinytsunami-update-01/"/>
      <url>//tinytsunami-update-01/</url>
      
        <content type="html"><![CDATA[<p>將網站更新成 Hexo 框架。<br>最主要的原因是舊的 Blog 系統當初寫得太急促，而且往往為了嘗試新東西而直接邊學邊做，導致系統問題有點多。<br>在重複考慮之下，決定改成目前的模式。這篇文章接下來寫的，是「羊羽手札」建立到目前為止的雜事以及更新狀況。</p><span id="more"></span><h1 id="更新歷程"><a href="#更新歷程" class="headerlink" title="更新歷程"></a>更新歷程</h1><ul><li>2016.10.24 羊羽手札v1（PHP）</li><li>2017.12.18 羊羽手札v2（Vue.js+Express）</li><li>2017.02.25 羊羽手札v3（Hexo）</li></ul><h1 id="雜記"><a href="#雜記" class="headerlink" title="雜記"></a>雜記</h1><p>到目前為止，羊羽手札的特徵是文章頁面中有 JS 演示的部分，先談談之前的做法。<br>最早的 PHP 頁面想要時做這個部份時，想到的做法是將 HTML 直接寫到資料庫，然後 CSS 採用行內樣式，比方說：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;demo_01&quot;</span> <span class="attr">style</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">...</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">...</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因為透過編輯器寫入，需要跳脫過濾一些 HTML（像是 script 標籤）以及 JS 語法。<br>所以 JS 是另外上傳單個檔案，採用外鏈式加載：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo_01&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>這個的主要問題在於，每次更新系統時，<br>需要檢查 JS 檔案是否還在（有時會改動檔案上傳的部分、或遷移主機商平台等等）<br>也因為這件事，我有遺失幾個文章內的 JS 演示腳本。</p><p>經過考慮後，第 3 版的羊羽手札，屆時將會改成 HTML、CSS、JS 遊樂場（JSbin、JSfiddle 或 Codepen）來嵌入演示。</p>]]></content>
      
      
      <categories>
          
          <category> 羊羽手札 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 檔案處理</title>
      <link href="//javascript-file-process/"/>
      <url>//javascript-file-process/</url>
      
        <content type="html"><![CDATA[<p>這篇文章的起因是想到過去寫的 JS Demo 多數沒有保留，<br>好不容易，上次在學校弄人工智慧有保留一份帶有檔案處理的。</p><p>所以這篇文章整理了過去做過、<br>未來也可能用在本網誌的演示部份而寫。</p><span id="more"></span><h1 id="歷史"><a href="#歷史" class="headerlink" title="歷史"></a>歷史</h1><p>沒記錯的話，早期的瀏覽器是不太允許讀取本機資料的。</p><p>理由是，如果瀏覽器的 JavaScript 可以隨意讀取本機資料，<br>那可能看一看網站，所有東西都偷偷被上傳了。</p><p>然而，這造成了一個問題：<br>「每次要檔案處理，都要透過檔案上傳到伺服器，然後再下載回來」</p><p>這個模式的問題在於網路頻寬的浪費，<br>也有可能網路的傳輸時間遠大於檔案處理的時間。</p><p>HTML5 標準中出現了 File API 處理了這個問題。</p><div class="note warning">            <p>注意：File API 在部分瀏覽器尚未普及。請參閱 <a href="https://developer.mozilla.org/zh-TW/docs/Web/API/FileReader">MDN FileReader</a>。</p>          </div><div class="note info">            <p>部份瀏覽器不允許第三方存取檔案，本文以 Google Chrome 瀏覽器為主。</p>          </div><h1 id="讀取檔案"><a href="#讀取檔案" class="headerlink" title="讀取檔案"></a>讀取檔案</h1><p>下面是直接從本機拿資料給 JavaScript 的做法：</p><p>HTML 必須的有 input 標籤，<br>至於按鈕只是為了給使用者按的（不然設定在 input.onchange 也是可以）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>基本的上傳檔案<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">button</span>&gt;</span>上傳<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>JavaScript 的部份，最主要就是那個 FileReader 的物件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">buttonNode.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> file = inputNode.<span class="property">files</span>[<span class="number">0</span>];        <span class="comment">// 取得輸入標籤的檔案</span></span><br><span class="line">  <span class="keyword">let</span> fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();    <span class="comment">// 建立 FileReader 物件</span></span><br><span class="line"></span><br><span class="line">  fileReader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;      <span class="comment">// 設定讀檔後的函數</span></span><br><span class="line">    <span class="keyword">let</span> contents = event.<span class="property">target</span>.<span class="property">result</span>; <span class="comment">// 取得資料</span></span><br><span class="line">    ...                                 <span class="comment">// 處理資料</span></span><br><span class="line">  &#125;;</span><br><span class="line">  fileReader.<span class="title function_">readAsDataURL</span>(file);       <span class="comment">// 載入檔案</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>這個演示從本機端直接讀取檔案，然後顯示出檔案內容（文字）：</p><div class="note info">            <p>本演示的 input(file) 標籤做了樣式處理，可供參考。</p>          </div><iframe scrolling="no" width="100%" height="310px" src="https://jsfiddle.net/yaamhnmw/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="讀取進度"><a href="#讀取進度" class="headerlink" title="讀取進度"></a>讀取進度</h1><p>雖然從本機端直接讀取不用透過網路已經很快了，<br>但有時候檔案還是大的多，這個時候我們可能會想知道讀取的進度。</p><p>這時，我們的進度可以從 FileReader 的 onprogress 取得（可以搭配 progress 標籤使用）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>JavaScript 的部份：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 過程進行的函數</span></span><br><span class="line">fileReader.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> rate = event.<span class="property">loaded</span> / event.<span class="property">total</span>; <span class="comment">// 得到讀取的比例</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p>這個演示製作了進度條（需要大一點的檔案才能看到）</p><div class="note info">            <p>本演示的 progress 標籤做了樣式處理，可供參考。</p>          </div><iframe scrolling="no" width="100%" height="310px" src="https://jsfiddle.net/xmee4x4j/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="讀取圖像"><a href="#讀取圖像" class="headerlink" title="讀取圖像"></a>讀取圖像</h1><p>畫布（Canvas）是 HTML5 幾乎最核心的功能之一，<br>當然讀取圖像繪畫到畫布上，也是很常見的。</p><h2 id="使用-Image-物件"><a href="#使用-Image-物件" class="headerlink" title="使用 Image 物件"></a>使用 Image 物件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 從 input 標籤取得檔案</span></span><br><span class="line"><span class="keyword">let</span> file = inputNode.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 Image 物件 </span></span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圖片載入後的事件函數</span></span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 畫到畫布上</span></span><br><span class="line">  context.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立 URL 掛到 Image 物件上</span></span><br><span class="line">img.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(file);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h3><p>這個演示示範了基本從 Image 到 Canvas 的過程：</p><iframe scrolling="no" width="100%" height="410px" src="https://jsfiddle.net/cjpbjrxL/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h2 id="使用-FileReader-物件"><a href="#使用-FileReader-物件" class="headerlink" title="使用 FileReader 物件"></a>使用 FileReader 物件</h2><p>通常而言會推薦使用 Image 物件，不過透過 FileReader 也可實作。</p><div class="note info">            <p>如果是圖像處理建議使用 Image 物件；<br>這是因為 FileReader 的瀏覽器支援度不如 Image 物件普及。</p>          </div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 取得檔案、建立 FileReader 物件</span></span><br><span class="line"><span class="keyword">let</span> file = inputNode.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 載入完成的事件函數</span></span><br><span class="line">fileReader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> content = event.<span class="property">target</span>.<span class="property">result</span>;    </span><br><span class="line">  <span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        context.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  img.<span class="property">src</span> = contents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 載入檔案</span></span><br><span class="line">fileReader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h3><p>如果透過 FileReader 一樣可以畫在畫布上：</p><iframe scrolling="no" width="100%" height="440px" src="https://jsfiddle.net/rtjd137s/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="二進位檔案處理"><a href="#二進位檔案處理" class="headerlink" title="二進位檔案處理"></a>二進位檔案處理</h1><p>取得了檔案通常需要做處理（透過 JavaScript）尤其是二進位的檔案，<br>轉檔、壓縮之類的往往需要二進位的控制，然而這個已經被 JavaScript 支援了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 這個只是方便取得檔案中的文字塊</span></span><br><span class="line"><span class="comment">// 然後把函數掛到了 DataView 底下</span></span><br><span class="line"><span class="title class_">DataView</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getString</span> = <span class="keyword">function</span>(<span class="params">offset, len</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="title function_">getUint8</span>(offset + i);</span><br><span class="line">    result += <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 取得檔案、建立 FileReader 物件</span></span><br><span class="line"><span class="keyword">let</span> file = inputNode.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line">fileReader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 建立 DataView 做控制</span></span><br><span class="line">  <span class="keyword">let</span> contents = <span class="keyword">new</span> <span class="title class_">DataView</span>(event.<span class="property">target</span>.<span class="property">result</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意這邊 readAsDataURL 改成 readAsArrayBuffer 函數</span></span><br><span class="line">fileReader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="演示-4"><a href="#演示-4" class="headerlink" title="演示"></a>演示</h2><div class="note primary">            <p>這個演示需要 WAV 檔案，可跳至 <a href="#%E6%BC%94%E7%A4%BA-5">下載檔案演示</a> 的部分；<br>該演示將由二進制組合一個 WAV 檔案下載。</p>          </div><p>它解析檔案內容，讀取資料（首個聲道的內容）繪畫到畫布上：</p><iframe scrolling="no" width="100%" height="250px" src="https://jsfiddle.net/0qs13nyk/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="下載檔案"><a href="#下載檔案" class="headerlink" title="下載檔案"></a>下載檔案</h1><p>我們討論了很多的讀取、操作檔案的方法，<br>同樣的，我們也要讓使用者能把檔案從瀏覽器上拿回來才行。</p><p>具體的作法是，透過一個連結標籤。<br>然後設定相關參數，並執行自身（讓瀏覽器自動處理）下載：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(...);              <span class="comment">// 設定空間</span></span><br><span class="line"><span class="keyword">let</span> contents = <span class="keyword">new</span> <span class="title class_">DataView</span>(buffer);            <span class="comment">// 建立 DataView 控制</span></span><br><span class="line"></span><br><span class="line">... <span class="comment">/* 在這邊使用 DataView 物件操作檔案 */</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透過 ArrayBuffer 建立 Blob 物件</span></span><br><span class="line"><span class="comment">// 後面的 type 屬性是二進位的流，請參考 Content-type 資訊</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([buffer], &#123;<span class="attr">type</span>: <span class="string">&quot;application/octet-stream&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(blob);     <span class="comment">// 建立 URL</span></span><br><span class="line"><span class="keyword">let</span> downloadNode = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 創造 a 標籤</span></span><br><span class="line"></span><br><span class="line">downloadNode.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;            <span class="comment">// 設定標籤不可見</span></span><br><span class="line">downloadNode.<span class="property">href</span> = url;                        <span class="comment">// 設定標籤位置（URL）</span></span><br><span class="line">downloadNode.<span class="property">download</span> = <span class="string">&quot;...&quot;</span>;                  <span class="comment">// 設定下載檔案檔名</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(downloadNode);        <span class="comment">// 加入標籤到網頁</span></span><br><span class="line">downloadNode.<span class="title function_">click</span>();                           <span class="comment">// 自動點擊執行</span></span><br><span class="line"></span><br><span class="line"><span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(url);                       <span class="comment">// 將創造的 URL 釋放掉</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="演示-5"><a href="#演示-5" class="headerlink" title="演示"></a>演示</h2><p>這個演示會根據你的函數內容生成、下載 WAV 檔案：</p><div class="note info">            <p>對於 16-bit 的 WAV 文件，範圍在 [-32768, 32767] 的區間內。</p>          </div><iframe scrolling="no" width="100%" height="200px" src="https://jsfiddle.net/fcgbq61a/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/HTMLImageElement/Image">MDN Web Docs : Image</a></li><li><a href="https://developer.mozilla.org/zh-TW/docs/Web/API/FileReader">MDN Web Docs : FileReader</a></li><li><a href="https://zh.wikipedia.org/wiki/WAV">Wikipedia: WAV</a></li><li><a href="http://soundfile.sapp.org/doc/WaveFormat/">WAVE PCM Soundfile Format</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 網頁設計 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迴文處理 Palindrome Process</title>
      <link href="//palindrome-process/"/>
      <url>//palindrome-process/</url>
      
        <content type="html"><![CDATA[<p>之前在弄演算法題目的時候，曾經遇過迴文類的問題，<br>當時並沒有很了解問題的本質跟相關算法，所以都是窮舉。然而有些超時、有些則否。</p><p>後來的某一天又碰到這類的問題，誘發我去把相關的算法看了幾遍。這篇文章算是從中衍伸的筆記。</p><span id="more"></span><h1 id="子字串與子序列"><a href="#子字串與子序列" class="headerlink" title="子字串與子序列"></a>子字串與子序列</h1><p>迴文問題通常不會以簡單的形式出現，<br>通常來說，大致上會類似「最長迴文子字串」、「最長迴文子序列」的形式出現，<br>正因如此，先理解兩者的差異是重要的。</p><p>子字串跟子序列大致上有這樣的關係：</p><ul><li>子字串、子序列都是依照閱讀的順序擷取（以英文來說，橫書是由左至右）</li><li>子字串要求資料連續、子序列不要求</li></ul><p>從這個角度來看，可以發現子字串的限制較子序列嚴格。</p><p>更進一步說，只要是子字串，就一定會是子序列，<br>而某筆資料所有的子字串集合，會是其資料子序列集合的子集合。</p><p>我們來看個例子：「TheQuickBrownFoxJumpsOverTheLazyDog」</p><table><thead><tr><th align="left">字串</th><th align="left">位置</th><th align="center">類型</th></tr></thead><tbody><tr><td align="left">QuickBrown</td><td align="left">The<code>QuickBrown</code>FoxJumpsOverTheLazyDog</td><td align="center">子字串、也是子序列</td></tr><tr><td align="left">LazyDog</td><td align="left">TheQuickBrownFoxJumpsOverThe<code>LazyDog</code></td><td align="center">子字串、也是子序列</td></tr><tr><td align="left">QuickFox</td><td align="left">The<code>Quick</code>Brown<code>Fox</code>JumpsOverTheLazyDog</td><td align="center">子序列</td></tr><tr><td align="left">BrownDog</td><td align="left">TheQuick<code>Brown</code>FoxJumpsOverTheLazy<code>Dog</code></td><td align="center">子序列</td></tr><tr><td align="left">LazyFox</td><td align="left">TheQuickBrownFoxJumpsOverTheLazyDog</td><td align="center">不是子字串或子序列</td></tr></tbody></table><div class="note info">            <p>範例中的「TheQuickBrownFoxJumpsOverTheLazyDog」是全字母句（Pangram）使用了所有英文字母。</p>          </div><div class="note warning">            <p>演示或本文撰寫完畢時，筆者發現有一處容易混淆：<br>「LPS」代表是「Longest Palindrome Substrings&#x2F;Subsequences」；<br>其中「S」並無指定為字串或序列，亦即最長子字串或子序列都有可能使用「LPS」做縮寫。<br>請根據段落判斷「LPS」的意義。</p>          </div><h1 id="迴文子字串：窮舉"><a href="#迴文子字串：窮舉" class="headerlink" title="迴文子字串：窮舉"></a>迴文子字串：窮舉</h1><p>因為子字串的限制較為嚴格，我們先從子字串下手。<br>對於迴文子字串的窮舉法邏輯很簡單：「找到所有的子字串，然後檢驗是否迴文。」</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 檢驗是否迴文</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> half = text.<span class="built_in">length</span>() / <span class="number">2</span>;            <span class="comment">// 取長度的一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>; i &lt; half; i++)            <span class="comment">// 註標 i 對應字串前半</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = text.<span class="built_in">length</span>() - i <span class="number">-1</span>;        <span class="comment">// 註標 j 對應字串後半</span></span><br><span class="line">        <span class="keyword">if</span>(text[i] != text[j]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果不對則直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;                             <span class="comment">// 確實屬於迴文</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>迴文檢測的邏輯不難，不過還是解釋一下。</p><p>字串能夠分成兩種：偶數字串、奇數字串。<br>如果是偶數時，長度除以二，會剛好是一半；然而是奇數的話，除以二會是一半捨去小數。</p><p>簡單的例子：</p><p>當字串為 <code>abcd</code> 時，長度為 $4$ 則一半為 $\lfloor 4 \rfloor &#x3D; 2$ 這樣的話，<br/><br>註標 <code>i = 0, 1</code> 而同時註標 <code>j = 3, 2</code> 形成依序比對字串前後兩邊的字元是否相等。</p><p>如果字串為 <code>abcba</code> 時，長度為 $5$ 則  $\lfloor 5 \rfloor &#x3D; 2$ 這樣的話，<br/><br>註標 <code>i = 0, 1</code> 而同時 註標 <code>j = 4, 3</code> 可以發現剛好奇數中間的字元並不需要比對。</p><p>接著，我們需要得到所有的子字串，在 <code>std::string</code> 中有 <code>substr</code> 函數可以使用。<br>那要取得所有的子字串，則需要註標 $a$ 表示子字串開頭的位置，而註標 $b$ 表示結束的位置，<br>對於所有的 $a$ 及 $b$ 有 $a \leq b$ 的關係：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">0</span>; a &lt; str.<span class="built_in">length</span>(); a++)        <span class="comment">// 子字串開始位置的註標</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = a; b &lt; str.<span class="built_in">length</span>(); b++)    <span class="comment">// 子字串結束位置的註標</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp = str.<span class="built_in">substr</span>(a, (b - a + <span class="number">1</span>));     <span class="comment">// 從開始位置，取對應長度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">checkPalindrome</span>(tmp)) ...;         <span class="comment">// 檢查迴文，並處理</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這樣我們問題就解決了。</p><p>不過仔細想想，我們其實並不需要另外合成字串，<br>直接在原字串比對就好，我們修正檢測：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 迴文檢測（使用參考）</span></span><br><span class="line"><span class="comment">// 傳入字串的參考、開始位置、結束位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">checkPalindrome</span><span class="params">(string &amp;text, <span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = b - a + <span class="number">1</span>;                     <span class="comment">// 取得子字串長度</span></span><br><span class="line">    <span class="type">int</span> half = len / <span class="number">2</span>;                      <span class="comment">// 取的一半的長度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; half; i++)           <span class="comment">// 註標 i 表示取前後多少字元</span></span><br><span class="line">        <span class="keyword">if</span>(text[a + i] != text[b - i])       <span class="comment">// 從前面取 i 個及從後面取 i 個比對</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                    <span class="comment">// 如果不符則傳回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;                             <span class="comment">// 確實為迴文</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>直接傳入參考以避免生成一堆子字串，<br>利用母字串的註標 $a$ 與 $b$ 取得子字串的長度運算即可。</p><h2 id="複雜度"><a href="#複雜度" class="headerlink" title="複雜度"></a>複雜度</h2><p>在分析之前，我們從例子著手。<br>比方說，當原字串為 <code>abc</code> 其長度為 $3$ 則存在子字串：</p><p>substr(<code>abc</code>) &#x3D; {<code>空字串</code>, <code>a</code>, <code>ab</code>, <code>abc</code>, <code>b</code>, <code>bc</code>, <code>c</code>}</p><div class="note warning">            <p>其實包含空字串在內也是子字串；只是我們不需要，所以沒有實做出來。</p>          </div><p>可以發現，子字串的數量為 $3 + 2 + 1 + 1 &#x3D; 7$ 個，如果不含空字串則是 $3 + 2 + 1 &#x3D; 6$ 個，<br>於是我們大概可以假設如下：</p><p>長度為 $n$ 的原字串，不含空字串的話，有 $\sum\limits_{x&#x3D;1}^n x &#x3D; \frac{1}{2}(1+n)n$ 個子字串。</p><p>假設只是從觀察中發現，實際推算看看是否正確：</p><p>設原字串的長度為 $n$ 的話，<br>註標 $a$ 的範圍在 $[0, n-1]$ 而註標 $b$ 的範圍在 $[a, n-1]$</p><p>因為子字串的數量就是所有註標匹配的數量：</p><p>$\sum\limits_{a &#x3D; 0}^{n - 1} \sum\limits_{b &#x3D; a}^{n - 1} 1$</p><p>後面的取和直接算有幾個，得到：</p><p>$&#x3D; \sum\limits_{a &#x3D; 0}^{n - 1} [(n - 1) - a + 1] &#x3D; \sum\limits_{a &#x3D; 0}^{n - 1} (n - a) &#x3D; \sum\limits_{a &#x3D; 0}^{n - 1} n - \sum\limits_{a &#x3D; 0}^{n - 1} a$</p>$= n \sum\limits_{a = 0}^{n - 1} 1 - \frac{1}{2}[(n - 1) + 0][(n - 1) - 0 + 1]$<p>$&#x3D; n^{2} - \frac{1}{2} (n - 1)n &#x3D; n^{2} - \frac{1}{2} (n^2 - n)$</p><p>$&#x3D; n^{2} - \frac{1}{2} n^2 + \frac{1}{2} n &#x3D; \frac{1}{2} n^2 + \frac{1}{2} n$</p><p>$&#x3D; \frac{1}{2} (n^2 + n) &#x3D; \frac{1}{2} (n + 1)n$</p><p>看來我們的推測試是正確的。</p><p>試想檢測一個字串是否為迴文，需要掃描一半的字串，<br>把原本取和裡面的 $1$ 改成子字串長度的一半也就是 $\frac{1}{2} (b - a + 1)$ 的話：</p><p>$\sum\limits_{a &#x3D; 0}^{n - 1} \sum\limits_{b &#x3D; a}^{n - 1} \frac{1}{2} (b - a + 1) &#x3D; \frac{1}{2} \sum\limits_{a &#x3D; 0}^{n - 1} \sum\limits_{b &#x3D; a}^{n - 1} (b - a + 1)$</p><p>$&#x3D; \frac{1}{2} \sum\limits_{a &#x3D; 0}^{n - 1} ( \sum\limits_{b &#x3D; a}^{n - 1} b - \sum\limits_{b &#x3D; a}^{n - 1} a + \sum\limits_{b &#x3D; a}^{n - 1} 1 )$</p>$= \frac{1}{2} \sum\limits_{a = 0}^{n - 1} \{ \frac{1}{2}[(n - 1) + a](n - a) - a(n - a) + (n - a) \}$<p>$&#x3D; \frac{1}{2} \sum\limits_{a &#x3D; 0}^{n - 1} [ \frac{1}{2}(n + a -1)(n - a) - an + a^{2} + n - a ]$</p><p>$&#x3D; \frac{1}{2} \sum\limits_{a &#x3D; 0}^{n - 1} [ \frac{1}{2}(n^{2} - an + an - a^{2} - n + a) - an + a^{2} + n - a ]$</p><p>$&#x3D; \frac{1}{2} \sum\limits_{a &#x3D; 0}^{n - 1} [ \frac{1}{2} n^{2} + \frac{1}{2} a^{2} + \frac{1}{2} n - \frac{1}{2} a - an ]$</p><p>$&#x3D; \frac{1}{4} \sum\limits_{a &#x3D; 0}^{n - 1} ( n^{2} + a^{2} + n - a ) - \frac{1}{2} n\sum\limits_{a &#x3D; 0}^{n - 1} a$</p><p>$&#x3D; \frac{1}{4} [ \sum\limits_{a &#x3D; 0}^{n - 1} n^{2} + \sum\limits_{a &#x3D; 0}^{n - 1} a^{2} +  \sum\limits_{a &#x3D; 0}^{n - 1} n - \sum\limits_{a &#x3D; 0}^{n - 1} a ] - \frac{1}{4} n^{2}(n - 1) $</p><p>$&#x3D; \frac{1}{4} [ n^{2} \sum\limits_{a &#x3D; 0}^{n - 1} 1 + \sum\limits_{a &#x3D; 0}^{n - 1} a^{2} +  n \sum\limits_{a &#x3D; 0}^{n - 1} 1 - \frac{1}{2} n (n - 1) ] - \frac{1}{4} n^{2}(n - 1) $</p><p>$&#x3D; \frac{1}{4} [ n^{3} + \sum\limits_{a &#x3D; 0}^{n - 1} a^{2} +  n^{2} - \frac{1}{2} n (n - 1) ] - \frac{1}{4} n^{2}(n - 1) $</p><p>把中間 $\sum\limits_{a &#x3D; 0}^{n - 1} a^{2}$ 項拿一個 $0^{2}$ 出來，<br>然後多加 $n^{2}$ 進去取和，後面再扣掉：</p><p>$\sum\limits_{a &#x3D; 0}^{n - 1} a^{2} &#x3D; 0^{2} + \sum\limits_{a &#x3D; 1}^{n} a^{2} - n^{2} &#x3D; \sum\limits_{a &#x3D; 1}^{n} a^{2} - n^{2}$</p><p>利用公式：$\sum\limits_{k &#x3D; 1}^{n} k^{2} &#x3D; \frac{1}{6} n(n+1)(2n+1)$</p><p>$&#x3D; \frac{1}{4} [ n^{3} + \frac{1}{6}n(n + 1)(2n + 1) - n^{2} +  n^{2} - \frac{1}{2} n (n - 1) ] - \frac{1}{4} n^{2}(n - 1) $</p><p>$&#x3D; \frac{1}{4} [ n^{3} + \frac{1}{6}n(n + 1)(2n + 1) - \frac{1}{2} n(n - 1) ] - \frac{1}{4} n^{2}(n - 1) $</p><p>$&#x3D; \frac{1}{4} n^{3} + \frac{1}{24}(n^{2} + n)(2n + 1) - \frac{1}{8} n(n - 1)  - \frac{1}{4} n^{2}(n - 1) $</p><p>$&#x3D; \frac{1}{4} n^{3} + \frac{1}{24}(2n^{3} + n^{2} + 2n^{2} + n) - \frac{1}{8} n^{2} + \frac{1}{8} n  - \frac{1}{4} n^{3} + \frac{1}{4} n^{2}$</p><p>$&#x3D; \frac{1}{4} n^{3} + \frac{1}{12} n^{3} + \frac{1}{24} n^{2} + \frac{1}{12} n^{2} + \frac{1}{24}n - \frac{1}{8} n^{2} + \frac{1}{8} n  - \frac{1}{4} n^{3} + \frac{1}{4} n^{2}$</p><p>$&#x3D; \frac{2}{24} n^{3} + \frac{6}{24} n^{2} + \frac{4}{24} n$</p><p>$&#x3D; \frac{1}{12} n^{3} + \frac{1}{4} n^{2} + \frac{1}{6} n$</p><p>對於搜索全部的子字串、並且暴力檢測迴文的複雜度是：</p><p>$\frac{1}{2} \sum\limits_{a &#x3D; 0}^{n - 1} \sum\limits_{b &#x3D; a}^{n - 1} (b - a + 1) &#x3D; \frac{1}{12} n^{3} + \frac{1}{4} n^{2} + \frac{1}{6} n &#x3D; O(n^{3})$</p><div class="note warning">            <p>注意：本式中存在一個瑕疵，由於子字串長度 $\frac{1}{2} (b - a + 1)$ 有可能為奇數，<br>精確的應寫為 $\lfloor \frac{1}{2} (b - a + 1) \rfloor$ 並將奇、偶數分開討論。</p>          </div><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><div class="note info">            <p>本演示的最糟測資是所有子字串都是迴文的情況，也就是單個字元構成的字串。</p>          </div><iframe scrolling="no" width="100%" height="230px" src="https://jsfiddle.net/3d7z04uh/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="迴文子字串：策略"><a href="#迴文子字串：策略" class="headerlink" title="迴文子字串：策略"></a>迴文子字串：策略</h1><p>對於這樣的問題 Manacher algorithm 提供了思考的策略：「大的迴文包含了小的迴文」<br>Manacher algorithm 的步驟：  </p><ul><li>字元間插入字符，使原字串都變成奇數長度</li><li>依序掃描字元、長度，找到最長的迴文</li></ul><p>關於步驟 1 的部份，實際上是這樣的：<br>假設有 <code>abcdcpa</code> 改變成 <code>#a#b#c#d#c#p#a#</code> （其中的 <code>#</code> 是任意字符）</p><p>數數看，我們插入了多少字元呢？如果把尾巴的 <code>#</code> 拿走的話：</p><ul><li><code>abcdcpa</code></li><li><code>#a#b#c#d#c#p#a</code> + <code>#</code></li><li><code>#a #b #c #d #c #p #a</code> + <code>#</code></li></ul><p>在長度為 $n$ 的字串中，我們插入了 $n$ 個 <code>#</code> 並在尾巴多加了一個 <code>#</code> 使得長度變成 $2n + 1$<br/><br>考慮長度為 $n$ 的字串，其中 $n$ 可能為偶數、或著奇數：</p><ul><li>如果 $n$ 為偶數，則 $2n$ 也是偶數，那 $2n + 1$ 為奇數</li><li>如果 $n$ 為奇數，則 $2n$ 變成偶數，那 $2n + 1$ 為奇數</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 插入符號到字元間</span></span><br><span class="line"><span class="function">string <span class="title">insertSign</span><span class="params">(string str, <span class="type">char</span> sign)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string nstr;                          <span class="comment">// 建立新字串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++) <span class="comment">// 遍歷原字串</span></span><br><span class="line">    &#123;</span><br><span class="line">        nstr += sign;                     <span class="comment">// 加上符號</span></span><br><span class="line">        nstr += str[i];                   <span class="comment">// 插入字元到新字串</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nstr + sign;                   <span class="comment">// 新字串尾巴補上符號</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">insertSign</span>(<span class="string">&quot;ABC&quot;</span>, \<span class="string">&#x27;#\&#x27;</span>);                   <span class="comment">// 調用時：&quot;#A#B#C#&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>能理解這個部份的話，我們進入算法核心：<br>如果我們字串比對由左至右來處理的話，一直到圖 1 的問號處：</p><p><img src="https://i.imgur.com/nHa3cFa.png" alt="圖 1、用已知資料推測問號處的值"></p><p>問號處應該填入多少呢？我們利用已知的資料做推測，<br>圖 2 橘色的部份就是已知區域最大的迴文：</p><p><img src="https://i.imgur.com/tfCrpQK.png" alt="圖 2、已經有的資料值（橘色）"></p><p>我們可以合理推測，正因為左右淡橘色以深橘色（Index &#x3D; $7$）對稱，<br>在 <code>a</code> 處（Index &#x3D; $9$）的 Palindrome 會與左邊的綠色 <code>a</code> 處（Index &#x3D; $5$）相等，如圖 3。</p><p><img src="https://i.imgur.com/7SZausI.png" alt="圖 3、透過已知值（綠色）推測問號處的值"></p><p>換句話說，我們會認為它等於 $1$（因為左邊的 Palindrome &#x3D; $1$）如圖 4：</p><p><img src="https://i.imgur.com/FNDjVzx.png" alt="圖 4、推測出問號處的值（綠色框為該位置的迴文範圍）"></p><p>我們接下來看第二種情況：</p><p><img src="https://i.imgur.com/w0qvUvc.png" alt="圖 5、不能直接推測的情況"></p><div class="note danger">            <p>錯誤的推測：這邊的 <code>b</code> 處（Index &#x3D; $11$）會跟左邊的 <code>b</code> 處（Index &#x3D; $3$）相等。</p>          </div><p>因為左邊的 <code>b</code> 處（Index &#x3D; $3$）紀錄的迴文長度，<br>向左延伸超出了 <code>c</code> 處（Index &#x3D; $7$）所紀錄的保證範圍，如圖 6：</p><p><img src="https://i.imgur.com/lqoxeMM.png" alt="圖 6、錯誤的推測值（紅色框為 $b$ 的迴文範圍）"></p><p>既然一直到 <code>#</code> 處（Index &#x3D; $12$）都跟左邊對稱的話，<br>右邊的 <code>b</code> 處（Index &#x3D; $11$）、搭配左邊的 <code>b</code> 處（Index &#x3D; $3$）紀錄的數字，<br>可以得到 $12 - 11 &#x3D; 1 &lt; 3$</p><p>也就是說，雖然左邊提供資訊為 3 的迴文長度，<br>但 <code>c</code> 處（Index &#x3D; $7$）只保證至少有 1 的迴文長度。</p><p>可以觀察出一個結論：  </p><ul><li>我們必須紀錄目前保護範圍到哪裡</li><li>如果延伸沒有超過保護範圍，則直接填入左邊對稱的數字</li><li>如果延伸超過了保護範圍，則利用左邊對稱的數字做保守估計</li></ul><p>我們用變數表示可以理解的更清楚，如圖 7 所示：</p><p><img src="https://i.imgur.com/DWPcioH.png" alt="圖 7、變數表示"></p><p>觀察之後的結論：</p><ul><li>若以 $k$ 為對稱，則對應於 $i$ 的 $j &#x3D; k - (i - k) &#x3D; 2k - i$</li><li>僅考慮右邊的保護範圍只到 $k + P_{k}$</li><li>如果 $i + P_{j} &lt; k + P_{k}$ 則 $P_{i} &#x3D; P_{j}$</li><li>如果 $i + P_{j} \geq k + P_{k}$ 則至少保證 $P_{i} \geq (k + P_{k}) - i$</li></ul><p>更簡潔地表示：</p><ul><li>令 $j &#x3D; k - (i - k) &#x3D; 2k - i$</li><li>令 $m &#x3D; k + P_{k}$</li><li>$P_{i} = \left\{\begin{array}{l} P_{j} && \text{if } (i + P_{j}) < m \\ m - i + c && \text{if } (i + P_{j}) \geq m \end{array}\right .$</li><li>上式 $c \in \mathbb{N}^{0}$ 須另外估計（延伸是否迴文）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LPS</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();                             <span class="comment">// 字串長度</span></span><br><span class="line">    <span class="type">int</span> i, j;                                         <span class="comment">// 兩個以 k 為對稱的註標</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;                                        <span class="comment">// 保護範圍的註標</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;                                        <span class="comment">// 對稱中心的註標</span></span><br><span class="line">    <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[len];                            <span class="comment">// 紀錄迴文長度的表</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)                          <span class="comment">// 遍歷所有字元</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = <span class="number">2</span>*k - i;                                  <span class="comment">// 找到另一對稱的註標</span></span><br><span class="line">        <span class="keyword">if</span>(i + p[j] &lt; m)                              <span class="comment">// 在保護範圍內</span></span><br><span class="line">            p[i] = p[j];                              <span class="comment">// 此迴文長度與對稱的迴文長度相等</span></span><br><span class="line">        <span class="keyword">else</span>                                          <span class="comment">// 超出保護範圍內</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = m - i;                             <span class="comment">// 至少有保護範圍到該註標的長度</span></span><br><span class="line">            <span class="keyword">while</span>(s[i + p[i]] == s[i - p[i]])         <span class="comment">// 拓展新長度</span></span><br><span class="line">            &#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">                <span class="keyword">if</span>(i + p[i] &gt;= len || i - p[i] &lt; <span class="number">0</span>)   <span class="comment">// 超出邊界就要停止</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k = i; m = k + p[k];                      <span class="comment">// 以目前為新對稱中，拓寬保護範圍</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findMax</span>(p, len);                           <span class="comment">// 尋找最大值</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="複雜度-1"><a href="#複雜度-1" class="headerlink" title="複雜度"></a>複雜度</h2><p>Manacher algorithm 的最差情況，即是「毫無資訊可利用」的情形（不存在迴文），<br>即便無資訊可用，使 $i$ 必須逐步配對，也會使得 $m$ 逐漸遞增。<br>（此一情況下，會有 $m &#x3D; i$ 的關係）</p><p>由於僅需要掃描一次原字串，Manacher algorithm 複雜度為 $O(n)$</p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><div class="note info">            <p>建議利用相同的測資，比較窮舉與策略的速度差異。</p>          </div><iframe scrolling="no" width="100%" height="230px" src="https://jsfiddle.net/uc3vyr6f/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="迴文子序列：窮舉"><a href="#迴文子序列：窮舉" class="headerlink" title="迴文子序列：窮舉"></a>迴文子序列：窮舉</h1><div class="note info">            <p>字串可以看作是字元的序列。</p>          </div><p>迴文子序列的暴力破解比子字串更糟糕，<br>原因在於，子序列的條件比子字串更寬鬆， 以至於任意長度字串的子序列數量極多。</p><p>窮舉的邏輯跟子字串是一樣的：找到所有的子序列，並且檢測迴文。<br>跟子字串不一樣的地方是：沒辦法利用傳入字串參考及兩個註標來解決生成一堆子序列。</p><p>以 <code>ABCD</code> 三個字元為例：</p><ul><li>長度為 $0$ 時，存在 $1$ 個子序列：<code>ø</code></li><li>長度為 $1$ 時，存在 $4$ 個子序列：<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code></li><li>長度為 $2$ 時，存在 $6$ 個子序列：<code>AB</code>, <code>AC</code>, <code>AD</code>, <code>BC</code>, <code>BD</code>, <code>CD</code></li><li>長度為 $3$ 時，存在 $4$ 個子序列：<code>ABC</code>, <code>ABD</code>, <code>ACD</code>, <code>BCD</code></li><li>長度為 $4$ 時，存在 $1$ 個子序列：<code>ABCD</code></li></ul><p>不難發現，其實存在的關係跟排列組合中的組合有關，<br>當原字串長度為 $n$ 時，子序列的數量是：</p><p>$\sum\limits_{k &#x3D; 0}^{n}\binom{n}{k}$</p><p>以剛剛的例子來說：</p><p>$\because n &#x3D; 4$</p><p>$\therefore \sum\limits_{k &#x3D; 0}^{4}\binom{4}{k}$</p><p>$\sum\limits_{k &#x3D; 0}^{4}\binom{4}{k} &#x3D; \binom{4}{0} + \binom{4}{1} + \binom{4}{2} + \binom{4}{3} + \binom{4}{4}$</p><p>$&#x3D; 1+4+6+4+1 &#x3D; 16$</p><p>從另一角度看，子序列的問題其實就是這堆字取任意個有多少種取法，<br>以 <code>ABCD</code> 來說，以 $0$ 表示不取、以 $1$ 表示有取到的話：</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">Subsequence</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><code>ø</code></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center"><code>D</code></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center"><code>C</code></td></tr><tr><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center"><code>CD</code></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><code>B</code></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center"><code>BD</code></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center"><code>BC</code></td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center"><code>BCD</code></td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center"><code>A</code></td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center"><code>AD</code></td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center"><code>AC</code></td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center"><code>ACD</code></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center"><code>AB</code></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center"><code>ABD</code></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">0</td><td align="center"><code>ABC</code></td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center"><code>ABCD</code></td></tr></tbody></table><p>同時它也長的像二進位的真值表，<br>更進一步的解釋了：$\sum\limits_{k &#x3D; 0}^{n}\binom{k}{n} &#x3D; 2^{n}$</p><p>要證明這件事情，我們得從二項式定理開始：<br>$(x + y)^{n} &#x3D; \sum\limits_{k &#x3D; 0}^{n} x^{k}y^{(n - k)}\binom{k}{n}$</p><p>只要令 $x &#x3D; 1, y &#x3D; 1$ 則：<br>$(1 + 1)^{n} &#x3D; \sum\limits_{k &#x3D; 0}^{n} 1^{k}1^{(n - k)}\binom{k}{n} &#x3D; 2^{n}$</p><p>換言之，對於長度為 $n$ 的原字串來說，存在 $2^{n}$ 種子序列。<br>利用遞迴關係，可以很簡單的找到所有的子序列：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 利用遞迴關係取得子序列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSubseq</span><span class="params">(string subseq, string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 若子序列不為空集合，則處理</span></span><br><span class="line">    <span class="keyword">if</span>(subseq != <span class="string">&quot;&quot;</span>) <span class="built_in">process</span>(subseq);</span><br><span class="line">    <span class="comment">// 將子序列增加一個字元，其字元後的子字串傳到下一層</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">        <span class="built_in">getSubseq</span>(subseq + str[i], str.<span class="built_in">substr</span>(i, str.<span class="built_in">length</span>()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">getSubseq</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;ABC&quot;</span>); <span class="comment">// 調用時</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>對於檢查迴文，使用子字串中提供的第一種檢查方法（也是一般的檢查法）較簡單。</p><h2 id="複雜度-2"><a href="#複雜度-2" class="headerlink" title="複雜度"></a>複雜度</h2><p>我們在上面已經曉得，<br>長度為 $n$ 的序列，子序列的數量為：$\sum\limits_{k &#x3D; 0}^{n}\binom{k}{n} &#x3D; 2^{n}$</p><p>在組合構成的多項式每一項 $\binom{k}{n}$ 都是子字串的數量，<br>透過變數 $k$ 可以抓到子序列的長度（檢測迴文需要一半長度），<br>於是複雜度是：$\sum\limits_{k &#x3D; 0}^{n} \frac{1}{2}k\binom{k}{n}$</p><p>由於已知光是子序列數量 $\sum\limits_{k &#x3D; 0}^{n}\binom{k}{n} &#x3D; 2^{n} &#x3D; O(2^{n})$</p><p>$\sum\limits_{k &#x3D; 0}^{n} \frac{1}{2}k\binom{k}{n}$ 複雜度必超過 $O(2^{n})$</p><p>因此算法並不堪用，得另尋出路！</p><div class="note warning">            <p>注意！與子字串相同，長度 $\frac{1}{2} k$ 不一定為偶數，應討論其奇偶性。</p>          </div><h2 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h2><div class="note warning">            <p>由於時間複雜度高，輸入太長的測資容易當機。</p>          </div><iframe scrolling="no" width="100%" height="230px" src="https://jsfiddle.net/qu8j1nda/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="迴文子序列：策略"><a href="#迴文子序列：策略" class="headerlink" title="迴文子序列：策略"></a>迴文子序列：策略</h1><p>由於子序列數量實在增長的很快，有沒有其他方法呢？<br>使用動態規劃可以有效解決這個問題：</p><p><img src="https://i.imgur.com/oFrlWBu.png" alt="圖 8、長度為 $5$ 的字串"></p><p>考慮圖 8，也就是一個長度為 $5$ 的字串。</p><p>透過註標 $0$ 及註標 $4$ 的字元不相等這件事情，<br>我們可以肯定的說，最長迴文子序列的長度不會是 $5$</p><p>那麼，有沒有可能長度為 $4$ 呢？<br>如果已知註標 $0$ 及註標 $4$ 的字元不相等，且長度為 $4$ 此事為真，<br>則註標 $3$ 可能為 <code>A</code>，即圖 9 的情況：</p><p><img src="https://i.imgur.com/HxHNCdO.png" alt="圖 9、註標 $3$ 可能為 A 的情況"></p><p>或註標 $1$ 為 <code>C</code>，即圖 10 的情況：</p><p><img src="https://i.imgur.com/XBMucHa.png" alt="圖 10、註標 $1$ 可能為 C 的情況"></p><p>因為我們還不知道註標 $3$ 及註標 $1$ 的字元，我們可以肯定的是：<br>最長迴文子序列應該是「註標 $0$ 到註標 $3$」或「註標 $1$ 到註標 $4$」其中一個較長的。</p><p><img src="https://i.imgur.com/nQpuNnT.png" alt="圖 11、「最長的」迴文子序列一定是「長度較長的」那一個"></p><p>圖 11 顯示出一個肯定的答案：</p><ul><li>「註標 $0$ 到註標 $3$」的最長迴文子序列長度為 $3$  </li><li>「註標 $1$ 到註標 $4$」的最長迴文子序列長度為 $4$  </li><li>則「註標 $0$ 到註標 $4$」的最長迴文子序列長度就會是 $4$</li></ul><p>我們觀察了第一種字元不相等的情況，那如果相等呢？參考圖 12：</p><p><img src="https://i.imgur.com/PV6Rhy6.png" alt="圖 12、最長迴文子序列至少為 $2$"></p><p>此時我們可以肯定，至少最長迴文子序列為 $2$<br>記得子字串、子序列的差異，這邊暗示如果註標 $1$ 到註標 $3$ 的字元通通不取，<br>則子序列為 <code>AA</code> 就是長度為 $2$ 的迴文。</p><p>一旦字元相等，我們就保證長度至少為 $2$ 還要在加上「註標 $1$ 到註標 $3$」最長的長度。  </p><p>考慮圖 13 的情況，由於註標 $0$ 及註標 $4$ 字元相等，<br>則保證長度為 $2$ + 「註標 $1$ 到註標 $3$ 最長迴文子序列的長度」<br>這個情況下，長度就是 $2 + 3 &#x3D; 5$</p><p><img src="https://i.imgur.com/vWWUxuQ.png" alt="圖 13、最長迴文子序列長度為 $2 + 3 = 5$"></p><p>如果實際下去比對，還有兩種情況：  </p><p>其一是「註標 $2$ 到註標 $2$ 最長迴文子序列的長度」<br>由於只有一個字元，當註標相同時，必為 $1$，參考圖 14：</p><p><img src="https://i.imgur.com/oxOiQd8.png" alt="圖 14、只有一個字元的情況"></p><p>最後一種情形是「註標 $1$ 到註標 $2$ 最長迴文子序列的長度」在碰到兩個字元相等時<br>很顯然地，這種情況只能給出長度 $2$ 當作答案，參考圖 15：</p><p><img src="https://i.imgur.com/7WElE0N.png" alt="圖 15、只有一個字元的情況"></p><p>根據上述一些推理，可以得到一些結論。</p><p>假設：</p><ul><li>原字串長度為 $n$</li><li>註標 $i$ 及註標 $j$ 存在 $i \leq j$</li><li>原字串第 $i$ 個字元為 $S_{i}$ </li><li>從註標 $i$ 到註標 $j$ 的最長迴文子序列長度為 $P_{i, j}$</li></ul><p>則：</p><ul><li>當 $S_{i} \neq S_{j}$ 且 $i \neq j$ 則 $P_{i, j} &#x3D; max(P_{i + 1, j}, P_{i, j - 1})$</li><li>當 $S_{i} &#x3D; S_{j}$ 且 $|i - j| &gt; 1$ 則 $P_{i, j} &#x3D; P_{i + 1, j - 1}$</li><li>當 $S_{i} &#x3D; S_{j}$ 且 $|i - j| &#x3D; 1$ 則 $P_{i, j} &#x3D; 2$</li><li>當 $i &#x3D; j$ 則 $P_{i, j} &#x3D; 1$</li></ul><div class="note info">            <p>條件 $|i - j| &gt; 1$ 或 $|i - j| &#x3D; 1$ 都隱含著 $i \neq j$ 這個關係</p>          </div><p>簡潔地表示：</p><ul><li>$P_{i, j} = \left\{\begin{array}{l}max(P_{i + 1, j}, P_{i, j - 1}) && \text{if } S_{i} \neq S_{j}, i \neq j \\P_{i, j} = P_{i + 1, j - 1} && \text{if } S_{i} = S_{j}, |i - j| > 1 \\2 && \text{if } S_{i} = S_{j}, |i - j| = 1 \\1 && \text{if } i = j\end{array}\right .$</li></ul><p>看一個簡單的例子，參考下圖 16（例子已將可能的四種情況納入）：  </p><p><img src="https://i.imgur.com/HorUIoW.png" alt="圖 16、簡單的例子"></p><p>我們的目標是找到 $P_{0, 4}$<br>由於 $S_{0} \neq S_{4}$ 且 $i \neq j$ 所以：</p><ul><li>$P_{0, 4} &#x3D; max(P_{1, 4}, P_{0, 3})$（規則一）</li></ul><p>對於 $P_{1, 4}$ 的部份：</p><ul><li>$P_{1, 4} &#x3D; max(P_{2, 4}, P_{1, 3})$（規則一）</li><li>$P_{2, 4} &#x3D; max(P_{3, 4}, P_{2, 3})$（規則一）</li><li>$P_{1, 3} &#x3D; max(P_{2, 3}, P_{1, 2})$（規則一）</li><li>$P_{3, 4} &#x3D; 2$（規則四 $\because S_{3} &#x3D; S_{4}, |3 - 4| &#x3D; 1$）</li><li>$P_{2, 3} &#x3D; max(P_{3, 3}, P_{2, 2}) &#x3D; 1$（規則一）</li><li>$P_{1, 2} &#x3D; max(P_{2, 2}, P_{1, 1}) &#x3D; 1$（規則一）</li><li>$P_{1, 1} &#x3D; P_{2, 2} &#x3D; P_{3, 3} &#x3D; 1$（規則三）</li></ul><p>對於 $P_{0, 3}$ 的部份：</p><ul><li>$P_{0, 3} &#x3D; max(P_{1, 3}, P_{0, 2})$（規則一）</li><li>$P_{1, 3} &#x3D; max(P_{2, 3}, P_{1, 2})$（規則一）</li><li>$P_{2, 3} &#x3D; max(P_{3, 3}, P_{2, 2}) &#x3D; 1$（規則一）</li><li>$P_{1, 2} &#x3D; max(P_{2, 2}, P_{1, 1}) &#x3D; 1$（規則一）</li><li>$P_{1, 1} &#x3D; P_{2, 2} &#x3D; P_{3, 3} &#x3D; 1$（規則三）</li><li>$P_{0, 2} &#x3D; 2 + P_{1, 1} &#x3D; 3$（規則二）</li></ul><p>所以 $P_{0, 4} &#x3D; 3$</p><p>程式碼的部份，利用遞迴可以輕易達成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...                                                  <span class="comment">// 初始化或輸入</span></span><br><span class="line"><span class="type">int</span> **p = <span class="keyword">new</span> <span class="type">int</span>* [str.<span class="built_in">length</span>()];                   <span class="comment">// 建立儲存表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = <span class="keyword">new</span> <span class="type">int</span> [str.<span class="built_in">length</span>()];</span><br><span class="line">    <span class="built_in">memset</span>(p[i], <span class="number">-1</span>, <span class="built_in">sizeof</span>(p[i]));                  <span class="comment">// 初始化儲存表為 -1</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 動態規劃找最長迴文子序列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LPS</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[i][j] &gt; <span class="number">0</span>) <span class="keyword">return</span> p[i][j];                  <span class="comment">// 若有儲存則直接使用</span></span><br><span class="line">    <span class="keyword">if</span>(i == j)                                       <span class="comment">// 若只有一字元</span></span><br><span class="line">        p[i][j] = <span class="number">1</span>;                                 <span class="comment">// 長度為 1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i + <span class="number">1</span> == j &amp;&amp; str[i] == str[j])          <span class="comment">// 只有兩字元，且兩字元一樣</span></span><br><span class="line">        p[i][j] = <span class="number">2</span>;                                 <span class="comment">// 長度為 2</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(i != j &amp;&amp; str[i] == str[j])              <span class="comment">// 首、尾字元相等</span></span><br><span class="line">        p[i][j] = <span class="built_in">LPS</span>(s, i + <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">2</span>;          <span class="comment">// 長度至少為 2 還要加上內部的最大長度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//(i != j &amp;&amp; str[i] != str[j])              // 首、尾字元相異</span></span><br><span class="line">        p[i][j] = <span class="built_in">max</span>(<span class="built_in">LPS</span>(i + <span class="number">1</span>, j), <span class="built_in">LPS</span>(i, j - <span class="number">1</span>)); <span class="comment">// 長度為刪除首、尾字元其一後的最大長度</span></span><br><span class="line">    <span class="keyword">return</span> p[i][j];                                  <span class="comment">// 回傳長度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">LPS</span>(<span class="number">0</span>, str.<span class="built_in">length</span>() - <span class="number">1</span>);                            <span class="comment">// 調用時</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><div class="note warning">            <p>調用時，因為傳入值為註標，第二個參數應為 <code>str.length() - 1</code> 而非 <code>str.length()</code></p>          </div><h2 id="複雜度-3"><a href="#複雜度-3" class="headerlink" title="複雜度"></a>複雜度</h2><p>如果採用遞迴的方法處理（即沒紀錄重複計算的部份），<br>這個算法的複雜度也相當高：</p><p>僅考慮最糟情況，也就是不斷計算 $P_{i, j} &#x3D; max(P_{i + 1, j}, P_{i, j - 1})$ 的狀況。</p><p>令長度 $n &#x3D; j - i + 1$ 則有遞迴式：</p><p>$$T(n) &#x3D; 2T(n - 1), \forall n \in N^{0}$$ </p><p>透過猜測複雜度來解遞迴式的方法，我們先猜測複雜度為 $O(n^{2})$，假設：</p><p>$$\forall c &gt; 0,\quad T(n) &#x3D; 2T(n - 1),\quad T(n - 1) \leq c(n - 1)^{2}$$</p><p>結合兩個條件：</p><p>$$T(n) &#x3D; 2T(n - 1) \leq 2c(n - 1)^{2} \leq cn^{2}$$</p><p>經過整理後有：</p><p>$$2cn^{2} - 4cn + 1 \leq cn^{2}$$</p><p>假設不成立，顯然 $T(n) &gt; O(n^{2})$</p><hr><p>這次改假設為 $T(n) &#x3D; O(2^{n})$</p><p>假設 </p><p>$$\forall c &gt; 0,\quad T(n) &#x3D; 2T(n - 1),\quad T(n - 1) \leq c2^{(n - 1)}$$</p><p>結合兩個條件：</p><p>$$T(n) &#x3D; 2T(n - 1) \leq 2c(2)^{n - 1} \leq c2^{n}$$</p><p>滿足：</p><p>$$c2^{n} \leq c2^{n}$$</p><p>假設成立，且可知道對於 $c &#x3D; 1$ 只要 $n_{0} &#x3D; 1$ 就有 $T(n) &#x3D; O(2^{n})$</p><div class="note warning">            <p>完整的遞迴式原先應標記在 $n \leq k$ 的情況下 $T(n) &#x3D; O(1)$<br/><br>故此處隱含了當 $n$ 足夠小，則複雜度為 $O(1)$ 的概念，<br/><br>此外從式中可知 $n_{0} &#x3D; 0$ 時 $T(n_{0} - 1) &#x3D; T(-1)$ 是未定義的。</p>          </div><p>做最後一步確認，透過遞迴樹如圖 1：  </p><p><img src="https://i.imgur.com/jNptBcw.png" alt="圖 1、遞迴樹"></p><p>已知深度為 $k$ 且根節點層為 $1$ 的二元樹有 $2^{k-1}$ 個葉節點，<br>則由於 $T(n) &#x3D; 2T(n - 1)$ 每次讓 $n$ 遞減，二元樹層數為 $n$ 則葉節點數目為 $2^{n-1}$<br>經累計則可確認，若以不紀錄的方式遞歸，複雜度會達到 $O(2^{n})$</p><p>若經紀錄，則會避開重複計算的節點（如上例中的 $P_{1, 1}, P_{2, 2}, P_{3, 3}$）<br>相當於在二維陣列中填表，且只需要填入 $i \leq j$ 的部份即可。</p><p>此時，最糟情況下，每次填入都須依賴 $P_{i, j}, i &#x3D; j$ 的值（對角線）<br>但，至多也只需要填入 $\frac{1}{2} n^{2}$ 個位置，則複雜度為 $O(n^{2})$</p><h2 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h2><div class="note info">            <p>取得最長序列的方法，可以改變 <code>p[i][j]</code> 同時記錄長度及序列；本演示即是如此。</p>          </div><iframe scrolling="no" width="100%" height="230px" src="https://jsfiddle.net/o28vt6cc/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h1><ul><li><a href="https://en.wikipedia.org/wiki/Substring">Wikipedia: Substring</a></li><li><a href="https://en.wikipedia.org/wiki/Subsequence">Wikipedia: Subsequence</a></li><li><a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring">Wikipedia: Longest Palindromic Substring</a></li><li><a href="http://www.csie.ntnu.edu.tw/~u91029/Palindrome.html">演算法筆記：迴文</a></li><li><a href="http://algorithms.tutorialhorizon.com/longest-palindromic-subsequence/">Algorithms @tutorialhorizo​​n</a></li><li><a href="https://wcipeg.com/wiki/Longest_palindromic_subsequence">PEGWiki: Longest Palindromic Subsequence</a></li><li><a href="https://www.felix021.com/blog/read.php?2040">Felix021：Manacher’s ALGORITHM: O(n)时间求字符串的最长回文子串</a></li><li>《算法導論》（第 2 章到第 4 章，主要用於參考「分析遞迴關係式」）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>邏輯回歸與感知器 Logistic Regression and Perceptron</title>
      <link href="//logistic-regression-and-perceptron/"/>
      <url>//logistic-regression-and-perceptron/</url>
      
        <content type="html"><![CDATA[<p>上一篇介紹的是線性回歸與梯度下降，這一篇將會討論「邏輯回歸與感知器」。</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在這邊先約定一件事情，就是對數函數的表示法：</p><ul><li>$log(x)$ 表示以 10 為底</li><li>$lg(x)$ 表示以 2 為底</li><li>$ln(x)$ 表示以 $e$ 為底</li></ul><p>因為第一種表示法很容易造成混淆，<br>所以這邊就事前說明，不要造成大家的困擾。</p><div class="note info">            <p>這是 Chrome 瀏覽器搜尋的表示法；你可以在網址列輸入 log(10)、lg(2) 及 ln(e) 來觀察。</p>          </div><div class="note success">            <p>這是 ANN 的系列文章<br>上一篇是 <a href="#">Post not found: 線性回歸與梯度下降-Linear Regression-and-Gradient-Descent</a><br>下一篇是 <a href="/fully-connected-neural-network/" title="全連接神經網路 Fully-Connected Neural Network">全連接神經網路 Fully-Connected Neural Network</a></p>          </div><div class="note success">            <p>筆者於大學專題時，曾向組員介紹過相關內容，如有需要可以參考 <a href="https://docs.google.com/presentation/d/1IfcViNOgnE3g2yj6tdWGsNnm2D1cb0nkB87crTMTFno/edit?usp=sharing">Logistic Regression 簡報</a></p>          </div><h1 id="邏輯回歸"><a href="#邏輯回歸" class="headerlink" title="邏輯回歸"></a>邏輯回歸</h1><p>邏輯回歸公式看起來還蠻複雜的，不過依舊有跡可循。<br>首先，我們回憶線性回歸的一些式子：</p><p>$h_{\theta}(x) &#x3D; \theta_{0} + \theta_{1}x$</p><p>還記得這個做什麼的話就好辦了，首先我們有一堆 $x$ 跟 $y$ 的資料（訓練資料），<br>然後我們透過找 $\theta$ 來確定之後新資料的 $y$ 值，換言之 $h_{\theta}(x)$ 其實就是新資料要代入的函數。</p><p>現在問題在於，如果我希望這個 $h_{\theta}(x)$ 介於 $[0, 1]$ 這個區間的話，<br>為什麼要做落在這個區間呢？因為這樣才能對應這樣的關係：</p><ul><li>$h_{\theta}(x) &#x3D; 1 &#x3D; True$</li><li>$h_{\theta}(x) &#x3D; 0 &#x3D; False$</li></ul><p>這也是叫做邏輯回歸的原因了，也就是說我們要修該這個 $h_{\theta}(x)$ 函數。</p><h1 id="預測函數"><a href="#預測函數" class="headerlink" title="預測函數"></a>預測函數</h1><p>修改函數其實有很多種方法，比方說：</p><ul><li>$ f(x) &#x3D; \frac{1}{1 + e ^{-x}}$</li><li>$ f(x) &#x3D; \frac{1 + tanh(x)}{2}$</li></ul><p>其中第一個 $ f(x) &#x3D; \frac{1}{1 + e ^{-x}}$<br>叫做 Sigmoid Function、或叫 Logistic Function（邏輯函數）</p><p>這邊就以這個函數為準。<br>然後我們令 $h_{\theta}(x) ＝\frac{1}{1 + e ^{-(\theta_{0} + \theta_{1}x)}}$<br>也就是把函數套在原函數上面。</p><p>可能會造成困惑的一點是，我們其實不知道 $\theta_{0} + \theta_{1}x$ 確切的值域，<br>用淺白一點的例子來說：如果我在線性回歸中預測的是房價，那麼這個函數的值應該會很大。</p><p>但是這樣的猜測是不正確的，因為我們並沒有確定 $\theta$ 的值，<br>所以在A.I.學習的過程中，這個 $\theta$ 的值就會讓 $h_{\theta}(x)$ 貼近真實的情況。</p><h1 id="成本函數"><a href="#成本函數" class="headerlink" title="成本函數"></a>成本函數</h1><p>接下來就是定義成本代價了。</p><p>因為 $h_{\theta}(x)$ 這次只會在 $[0, 1]$ 中，<br>所以說，我們的成本函數也是差不多要這樣定義：  </p>$Cost(\theta) = \left\{\begin{array}{l} -ln(h_{\theta}(x)) && \text{if }y = 1 \\ -ln(1-h_{\theta}(x)) && \text{if }y = 0 \end{array}\right .$<ul><li>如果 $h_{\theta}(x) &#x3D; 0$ 且 $y &#x3D; 0$ 則 $Cost(\theta) &#x3D; 0$（預測正確，成本為零）</li><li>如果 $h_{\theta}(x) &#x3D; 0$ 且 $y &#x3D; 1$ 則 $Cost(\theta) &#x3D; \infty$（預測錯誤，成本無限大）</li><li>如果 $h_{\theta}(x) &#x3D; 1$ 且 $y &#x3D; 0$ 則 $Cost(\theta) &#x3D; \infty$（預測錯誤，成本無限大）</li><li>如果 $h_{\theta}(x) &#x3D; 1$ 且 $y &#x3D; 1$ 則 $Cost(\theta) &#x3D; 0$（預測正確，成本為零）</li></ul><p>而 $log(x)$ 有這這樣的性質：</p><ul><li>任何數的零次方等於一，也就是 $ln(1) &#x3D; 0$</li><li>有條貼近 $y$ 軸的漸近線，也就是 $\displaystyle{\lim_{x \to 0} ln(x) &#x3D; -\infty}$</li></ul><p>也就是說，只要取 $-ln(x)$ 就能找到 $0$ 跟 $\infty$ 兩個重要的值，剩下的就只是調整。<br>從這裡也可以發現一件事，就是其他的對數函數也差不多（其實是可以用的意思）</p><p>接下來整理成一條公式：</p><p>$Cost(\theta) &#x3D; \left[-yln(h_{\theta}(x))\right] + \left[-(1-y)ln(1-h_{\theta}(x))\right]$</p><p>因為假設有 $m$ 筆資料的話：</p><p>$Cost(\theta) &#x3D; \frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ -y_{i}ln(h_{\theta}(x_{i})) \right] + \left[ -(1-y_{i})ln(1-h_{\theta}(x_{i})) \right]$ </p><h2 id="成本的梯度"><a href="#成本的梯度" class="headerlink" title="成本的梯度"></a>成本的梯度</h2><p>因為梯度下降要用到，接下來是微分成本函數：</p><p>$Cost(\theta) &#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ y_{i}ln(h_{\theta}(x_{i})) \right] + \left[ (1-y_{i})ln(1-h_{\theta}(x_{i})) \right]$ </p><p>在微分之前，對兩個 $ln(x)$ 函數做變化：</p><p>$ln(h_{\theta}(x_{i})) &#x3D; ln(\frac{1}{1 + e^{-\theta^{T}X}}) &#x3D; ln(1) - ln(1 + e^{-\theta^{T}X}) &#x3D; - ln(1 + e^{-\theta^{T}X})$</p><p>$ln(1-h_{\theta}(x_{i})) &#x3D; ln(1-\frac{1}{1 + e^{-\theta^{T}X}}) &#x3D; ln(\frac{1 + e^{-\theta^{T}X}}{1 + e^{-\theta^{T}X}}-\frac{1}{1 + e^{-\theta^{T}X}})$</p><p>$&#x3D; ln(\frac{e^{-\theta^{T}X}}{1 + e^{-\theta^{T}X}}) &#x3D; ln(e^{-\theta^{T}X}) - ln(1 + e^{-\theta^{T}X}) &#x3D; -\theta^{T}X - ln(1 + e^{-\theta^{T}X})$</p><p>然後代換，化簡。</p><p>$Cost(\theta) &#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ y_{i}(- ln(1 + e^{-\theta^{T}X})) \right] + \left[ (1-y_{i})(-\theta^{T}X - ln(1 + e^{-\theta^{T}X})) \right] $</p><p>$&#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ -y_{i}ln(1 + e^{-\theta^{T}X}) + (1-y_{i})(-\theta^{T}X - ln(1 + e^{-\theta^{T}X})) \right]$</p><p>$&#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ -y_{i}ln(1 + e^{-\theta^{T}X}) + (-\theta^{T}X - ln(1 + e^{-\theta^{T}X})+y_{i}\theta^{T}X + y_{i}ln(1 + e^{-\theta^{T}X}) \right]$ </p><p>$&#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ -\theta^{T}X - ln(1 + e^{-\theta^{T}X})+y_{i}\theta^{T}X \right]$ </p><p>$&#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ -(ln(e^{\theta^{T}X}) + ln(1 + e^{-\theta^{T}X}))+y_{i}\theta^{T}X \right]$ </p><p>$&#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ -ln(e^{\theta^{T}X}(1 + e^{-\theta^{T}X}))+y_{i}\theta^{T}X \right]$ </p><p>$&#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ -ln(e^{\theta^{T}X} + 1)+y_{i}\theta^{T}X \right]$ </p><p>$&#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ y_{i}\theta^{T}X - ln(e^{\theta^{T}X} + 1) \right]$ </p><p>接著在處理微分。</p><p>$\frac{\partial}{\partial\theta_{j}}Cost(\theta) &#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ \frac{\partial}{\partial\theta_{j}}y_{i}\theta^{T}X - \frac{\partial}{\partial\theta_{j}}ln(e^{\theta^{T}X} + 1) \right]$ </p><p>第一項的部份：</p><p>$\frac{\partial}{\partial\theta_{j}}y_{i}\theta^{T}X &#x3D; y_{i}x_{j}$</p><p>第二項的部份：</p><p>$\frac{\partial}{\partial\theta_{j}}ln(e^{\theta^{T}X} + 1) &#x3D; \frac{\partial}{\partial(e^{\theta^{T}X} + 1)}ln(e^{\theta^{T}X} + 1)\frac{\partial}{\partial\theta_{j}}(e^{\theta^{T}X} + 1)$</p><p>$&#x3D; \frac{1}{e^{\theta^{T}X} + 1}(x_{j}e^{\theta^{T}X}) &#x3D; \frac{x_{j}e^{\theta^{T}X}}{e^{\theta^{T}X} + 1} &#x3D; \frac{x_{j}}{(e^{-\theta^{T}X})(e^{\theta^{T}X} + 1)}$</p><p>$&#x3D; \frac{x_{j}}{1 + e^{-\theta^{T}X}} &#x3D; x_{j}h_{\theta}(x_{i})$</p><p>所以：</p><p>$\frac{\partial}{\partial\theta_{j}}Cost(\theta) &#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ \frac{\partial}{\partial\theta_{j}}y_{i}\theta^{T}X - \frac{\partial}{\partial\theta_{j}}ln(e^{\theta^{T}X} + 1) \right]$</p><p>$&#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ y_{i}x_{j} - x_{j}h_{\theta}(x_{i}) \right] &#x3D; -\frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ y_{i} - h_{\theta}(x_{i}) \right] x_{j}$ </p><p>$&#x3D; \frac{1}{m} \sum\limits_{i&#x3D;1}^m \left[ h_{\theta}(x_{i}) - y_{i} \right] x_{j}$ </p><p>實際的使用上我們會：</p><p>$\theta_{j} :&#x3D; \theta_{j} - \alpha\frac{1}{m}\sum\limits_{i&#x3D;1}^m \left[ h_{\theta}(x_{i}) - y_{i} \right] x_{j}$ </p><p>其中 $\alpha$ 學習率，太高的學習率跟線性回歸一樣會震盪，<br>換言之，容易導致結果發散，無法收斂至最佳解。</p><div class="note warning">            <p>學習率 $\alpha$ 太高會造成發散，導致無法收斂到最佳解。</p>          </div><h1 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h1><p><img src="https://i.imgur.com/TGmNZoX.png" alt="圖 1、感知器"></p><div class="note info">            <p>用於人工神經網路時，單個感知器（perceptron）又稱為神經元（neuron）。</p>          </div><p>圖 1 應該算是蠻常見的吧？如果常在接觸這個領域的話。<br>這篇文章把這個放在這裡，是為了跟邏輯回歸做比較。</p><p>圖中顯示的 $\sum$ 是指 $X$ 乘上 $\theta$ 權重取和；而 $\phi(x)$ 是指某種函數，可能是 sigmoid 或是其他函數。</p><p>有沒有跟邏輯回歸很類似或者說接近呢？</p><h2 id="線性不可分問題"><a href="#線性不可分問題" class="headerlink" title="線性不可分問題"></a>線性不可分問題</h2><p>下面這個段落引用自 Wikipedia 的文章，讓我們回顧一下歷史。</p><blockquote><p>雖然最初被認為有著良好的發展潛能，但感知機最終被證明不能處理諸多的模式識別問題。1969年，Marvin Minsky和Seymour Papert在《Perceptrons》書中，仔細分析了以感知機為代表的單層神經網絡系統的功能及局限，證明感知機不能解決簡單的異或（XOR）等線性不可分問題，但Rosenblatt和Minsky及Papert等人在當時已經了解到多層神經網絡能夠解決線性不可分的問題。</p><p>由於Rosenblatt等人沒能夠及時推廣感知機學習算法到多層神經網絡上，又由於《Perceptrons》在研究領域中的巨大影響，及人們對書中論點的誤解，造成了人工神經領域發展的長年停滯及低潮…  </p><footer><strong>Wikipedia</strong><cite><a href="https://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8">zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8</a></cite></footer></blockquote><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>這個演示是邏輯回歸（單個神經元）學習邏輯運算的規則，<br>可以發現除了 XOR 外，其他邏輯都可以使紅、藍兩色分明。</p><iframe scrolling="no" width="100%" height="550px" src="https://jsfiddle.net/ht98xhej/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 人工智慧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>線性回歸與梯度下降 Linear Regression and Gradient Descent</title>
      <link href="//linear-regression-and-gradient-descent/"/>
      <url>//linear-regression-and-gradient-descent/</url>
      
        <content type="html"><![CDATA[<p>這篇是 Coursera 中 Machine Learning 的筆記。</p><span id="more"></span><div class="note info">            <p>課程在：<a href="https://www.coursera.org/learn/machine-learning/home/welcome/">Coursera Machine Learning</a>，這是機器學習入門的推薦課程。</p>          </div><h1 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h1><p>梯度下降是理解演算法的人，應該不會太陌生的東西，<br>因為類似的還有爬山算法、模擬退火等等。</p><p>有些人會分不清楚爬山算法跟梯度下降的差別，<br>根據 Wikipedia 的說明，二維函數上的爬山演算法大致上是：  </p><ul><li>找一點 $p$ 當起點</li><li>代入函數 $f(x)$ 並紀錄 $f(p)$ 以及 $p$ 的值</li><li>調整 $p$ 成為 $p+k$</li><li>檢查 $f(p+k) &gt; f(p)$ （大、小於，根據找最大、小值而定）</li><li>如果為真，則 $p :&#x3D; p+k$</li><li>重複 2 ～ 5 步驟，直到 $f(p)$ 到達滿意為止</li></ul><p>而梯度下降法，是這樣操作的：  </p><ul><li>找一點 $p$ 當起點</li><li>微分 $f(x)$ 成為 $\frac{d}{dx}f(x)$</li><li>使 $p :&#x3D; p - \frac{d}{dx}f(p)$（正負號，根據尋找最大、小值而定）</li><li>重複 2～3 步驟，直到 $f(p)$ 到達滿意為止</li></ul><p>換而言之，兩者最大的差別是：<br>對於爬山算法是代函數找新值，如果新值更好則替換，<br>而梯度下降則利用了微分的性質，直接往正確的方向前進。</p><div class="note info">            <p>梯度下降比爬山算法更有效嗎？為什麼？<br>函數難以微分（或不可微分、越微分越複雜）時，梯度下降、爬山算法哪個更有效？<br>當函數屬於多變數函數時，梯度下降、爬山算法哪個更有效？</p>          </div><div class="note success">            <p>這是 ANN 的系列文章<br>下一篇是 <a href="#">Post not found: 邏輯回歸與感知器-Logistic Regression-and-Perceptron</a></p>          </div><div class="note success">            <p>筆者於大學專題時，曾向組員介紹過相關內容，如有需要可以參考 <a href="https://docs.google.com/presentation/d/1WMTRxJnfNmJozAB6M-CQkB4zPzCLj4aw0ip1D8sStbs/edit?usp=sharing">Multiple Linear Regression 簡報</a></p>          </div><h1 id="回歸問題"><a href="#回歸問題" class="headerlink" title="回歸問題"></a>回歸問題</h1><p>在 Machine Learning 中，算是最容易的東西。同時也是跟統計學重複的內容。  </p><p>這邊簡單描述問題，大意是這樣：  </p>給一組 $S = \{(x^{(1)}_{1}, x^{(1)}_{2}, ..., x^{(1)}_{n}, y^{(1)}), (x^{(2)}_{1}, x^{(2)}_{2}, ..., x^{(2)}_{n}, y^{(2)}), ..., (x^{(m)}_{1}, x^{(m)}_{2}, ..., x^{(m)}_{n}, y^{(m)})\}$ <p>你要找到一個函數 $h_{\theta}(x_{1}, x_{2}, …, x_{n})$ 使的每一筆資料代入後： $Cost(h_{\theta}(x_{1}, x_{2}, …, x_{n}), y)$ 為最小。<br>在二維平面上的情況（單個 $x$ 對應一個 $y$ 的狀況）</p><p>大概就是：找一條線盡可能的擬合資料的趨勢，但是也不可以過度的擬合，<br>這裡的 $Cost(…)$ 是指成本函數，稍後會介紹。</p><div class="note info">            <p>試想想插值（interpolation）與過擬合回歸（overfitting regression）間的差異。</p>          </div><h2 id="特徵與標籤"><a href="#特徵與標籤" class="headerlink" title="特徵與標籤"></a>特徵與標籤</h2><p>我們剛剛提到了集合，我們現在單獨把裡面的元素搬出來看：</p>$(x^{(1)}_{1}, x^{(1)}_{2}, ..., x^{(1)}_{n}, y^{(1)})$<p>這樣的資料組成，我們理解成兩個部份：特徵以及標籤。<br>其中 $x$ 的部份稱作特徵，而 $y$ 的部份叫做標籤，比方說我們的問題是：</p><p>以資工系學生某些科目的期中考分數（程式設計、線性代數），預測所有科目的平均。<br>那我們的元素會變成類似這樣：  </p><ul><li>$x_{1} &#x3D; 程式設計分數$</li><li>$x_{2} &#x3D; 線性代數分數$</li><li>$y &#x3D; 科目平均$</li></ul><p>元素為 $(x_{1}, x_{2}, y)$ 這樣，當然 Machine Learning 領域跟統計學一樣，<br>資料量得到達一定的大小，預測才會較為準確。<br>為了方便之後的解釋，我們就繼續採用這個預測科目平均的例子，<br>不過我們把兩個科目換成一個科目（方便我們之後的演示，畢竟雙變數要畫三維圖形）<br>元素變成：$(程式設計分數, 學期平均)$ 這樣。</p><h1 id="預測函數"><a href="#預測函數" class="headerlink" title="預測函數"></a>預測函數</h1><p>我們在討論接下來的操作以前，得先處理上面提到的 $h_{\theta}(x)$ 函數才行，<br>基本上 $h_{\theta}(x)$ 是由設計模型的人提出的，跟資料的分佈有相應的關係。<br>由於我們是預測科目的平均，且特徵只取一個，</p><p>那麼對應的 $h_{\theta}(x)$ 函數應該只是一個簡單的函數：</p><p>$h_{\theta}(x) &#x3D; \theta_{0} + \theta_{1}x$</p><p>其中的 $\theta$ 在 Machine Learning 中叫做權重，同時也是我們搜尋的目標。<br>有時為了方便計算會變成向量的形式：</p><p>$h_{\theta}(x) &#x3D; \theta^{T}x$</p><p>在這樣的情況下，應該多增加 $x_{0} &#x3D; 1$ 使的大小相等。<br>為了理解，還是在說明一次，預測函數跟系統的設計有關，</p><p>當然也可以設計成更為複雜的函數。</p><h1 id="成本函數"><a href="#成本函數" class="headerlink" title="成本函數"></a>成本函數</h1><p>成本函數（Cost Function，又名做代價函數）<br>成本函數的意義，是用於評估回歸線在擬合資料集的時候，</p><p>到底擬合的好不好（換言之，也就是 $h_{\theta}(x)$ 函數好不好）<br>以剛才的預測學期平均的例子來說，</p><p>一個很簡單的概念是，代入函數值跟理想值的差為成本：</p><p>$Cost(\theta) &#x3D; h_{\theta}(x) - y$</p><p>不過應該很容易發現問題點，如果出來的值是負的，<br>難道我的成本變成獲利？函數非常好嗎？<br>並不是，事實上這兩者的在數線上的距離差越大越糟糕，<br>於是我們習慣上加上平方來消除負號：</p><p>$Cost(\theta) &#x3D; (h_{\theta}(x) - y)^{2}$</p><div class="note info">            <p>為什麼這裡不使用絕對值函數？<br>請參閱：<a href="https://www.zhihu.com/question/24095027/">在进行线性回归时，为什么最小二乘法是最优方法？</a></p>          </div><p>不過，我們的特徵有很多筆，<br>假設有 $m$ 筆資料好了，於是乎成本函數又有了變化：</p><p>$Cost(\theta) &#x3D; \frac{1}{2m}\sum\limits_{i&#x3D;1}^{m} (h_{\theta}(x) - y)^{2}$</p><p>乘 $\frac{1}{m}$ 的原因是我們想算誤差的平均數，</p><p>而乘 $\frac{1}{2}$ 是因為等等微分可以消掉常數倍。<br>我們的目標已經很明確了找到一組 $\theta$ 使得 $Cost(\theta)$ 最小化，<br>你可能注意到了，成本函數 $Cost(\theta)$ 的變數是 $\theta$ 而非 $x$<br>第一次看到可能不習慣，不過如果你把 $h_{\theta}(x)$ 整個內容寫出來應該就不難理解。</p><h2 id="成本的梯度"><a href="#成本的梯度" class="headerlink" title="成本的梯度"></a>成本的梯度</h2><p>由於我們想要找成本函數的最小值（全域最大值）的關係，<br>理所當然有一些方法能夠處理這個問題，比方說直接解方程式之類的，<br>而這個叫做正規方程，也是類似公式解的東西，不過我們沒有打算在這裡說明。</p><p>我們採用的是梯度下降找區域極值的方法。</p><p>微分成本函數（把 $\theta$ 當成向量同時微分）：  </p><p>$\frac{d}{d\theta}Cost(\theta) &#x3D; \frac{d}{d\theta} \frac{1}{2m}\sum\limits_{i&#x3D;1}^{m} (h_{\theta}(x^{(i)}) - y^{(i)})^{2}$</p><p>套用鏈鎖法則：  </p><p>$\frac{d}{d\theta}Cost(\theta) &#x3D; \frac{1}{2m}\sum\limits_{i&#x3D;1}^{m} (\frac{d}{d(h_{\theta}(x^{(i)}) - y^{(i)})} (h_{\theta}(x^{(i)}) - y^{(i)})^{2} \frac{d}{d\theta} h_{\theta}(x^{(i)}) - y^{(i)})$</p><p>$\frac{d}{d\theta}Cost(\theta) &#x3D; \frac{1}{m}\sum\limits_{i&#x3D;1}^{m} ((h_{\theta}(x^{(i)}) - y^{(i)})x^{(i)})$</p><p>因為我們將 $\theta$ 當成向量，梯度下降法則會：  </p><p>$\theta_{j} :&#x3D; \theta_{j} - \alpha\frac{1}{m}\sum\limits_{i&#x3D;1}^{m} ((h_{\theta}(x^{(i)}) - y)x^{(i)}_{j})$</p>如果你有注意到 $x^{(i)}_{j}$ 的話，我們剛才只有出現 $x_{1} = x$ 對應著 $\theta_{1}$<p>那這邊的 $\theta_{0}$ 只要令 $x_{0} &#x3D; 1$ 使得 $h_{\theta}(x) &#x3D; \theta_{0}x_{0} + \theta_{1}x_{1}$ 成立就好。<br>不必擔心這邊 $x$ 上下標一堆的問題，上標 $(i)$ 代表每個資料要輪流代入，下標 $j$ 可以看成是 $\theta_{j}$ 的係數。其中 $\alpha$ 被稱為學習率，是自行設定的常數。</p><div class="note warning">            <p>學習率 $\alpha$ 太高會造成發散，導致無法收斂到最佳解。</p>          </div><div class="note warning">            <p>更新 $\theta$ 時，應同時改變 $\theta_{0}$ 及 $\theta_{1}$ 才是正確的。</p>          </div><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><p>這是一個簡單線性回歸（Simple Linear Regression）的演示。</p><div class="note warning">            <p>本演示為了使回歸更快，把在 $\theta_{0}$ 處的梯度加大了。</p>          </div><iframe scrolling="no" width="100%" height="550px" src="https://jsfiddle.net/2nga2mnm/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 人工智慧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三角函數的微分</title>
      <link href="//differential-trigonometric-functions/"/>
      <url>//differential-trigonometric-functions/</url>
      
        <content type="html"><![CDATA[<p>總之一個因緣際會複習微積分，所以寫下這篇文章。<br>本篇文章部分要仰賴一些先備知識：</p><span id="more"></span><p>$\displaystyle{ \lim_{\theta \to 0} \frac{sin(\theta)}{\theta} &#x3D; 1 }$</p><p>（證明可以參考：<a href="http://mathtrain.jp/sinc/">sinx&#x2F;xについて覚えておくべき２つのこと</a>）</p><p>題外話，在 tutor 板上出現過為什麼不可以用羅必達法則（l’H&amp;ocirc;pital’s Rule）證明的問題。<br>有興趣可以自己前去觀看：<a href="https://www.ptt.cc/man/tutor/DFC5/D338/D20E/M.1174228073.A.6B3.html">[討論] limsinx&#x2F;x＝1 when x&amp;rarr;0</a></p><p>另一個部分是：</p><p>$\displaystyle{ \lim_{\theta \to 0} \frac{cos(\theta) - 1}{\theta} &#x3D; 0 }$</p><p>推倒如下。</p><p>$\displaystyle{ \lim_{\theta \to 0} \frac{cos(\theta) - 1}{\theta} &#x3D; \lim_{\theta \to 0} \frac{cos(\theta) - 1}{\theta} \cdot \frac{cos(\theta) + 1}{cos(\theta) + 1}}$</p><p>$\displaystyle{ &#x3D; \lim_{\theta \to 0} \frac{cos^{2}(\theta) - 1^{2}}{\theta [cos(\theta) + 1]} &#x3D; \lim_{\theta \to 0} \frac{-sin^{2}(\theta)}{\theta [cos(\theta) + 1]}}$</p><p>$\displaystyle{ &#x3D; - \lim_{\theta \to 0} \frac{sin(\theta)}{\theta}\frac{sin(\theta)}{cos(\theta) + 1} &#x3D; - { \lim_{\theta \to 0} \frac{sin(\theta)}{\theta} \cdot \lim_{\theta \to 0} \frac{sin(\theta)}{cos(\theta) + 1} }}$</p><p>$\displaystyle{ &#x3D; - { 1 \cdot \frac{0}{1 + 1} } &#x3D; 0 }$ </p><h1 id="sin-x-正弦"><a href="#sin-x-正弦" class="headerlink" title="sin(x) 正弦"></a>sin(x) 正弦</h1><p>利用微分定義推導：</p><p>$\displaystyle{ \frac{d}{dx} sin(x) &#x3D; \lim_{h \to 0} \frac{sin(x + h) - sin(x)}{h} }$</p><p>$\displaystyle{ &#x3D; \lim_{h \to 0} \frac{sin(x)cos(h) + cos(x)sin(h) - sin(x)}{h} \text{（※ 正弦和角公式）} }$</p><p>$\displaystyle{ &#x3D; \lim_{h \to 0} \frac{sin(x)cos(h) - sin(x) + cos(x)sin(h)}{h} }$</p><p>$\displaystyle{ &#x3D; \lim_{h \to 0} \frac{sin(x) [cos(h) - 1]}{h} + \lim_{h \to 0} \frac{cos(x)sin(h)}{h} }$</p><p>$\displaystyle{ &#x3D; sin(x) \cdot \lim_{h \to 0} \frac{cos(h) - 1}{h} + cos(x) \cdot \lim_{h \to 0} \frac{sin(h)}{h} }$</p><p>$\displaystyle{ &#x3D; sin(x) \cdot 0 + cos(x) \cdot 1 &#x3D; cos(x) }$</p><h1 id="cos-x-餘弦"><a href="#cos-x-餘弦" class="headerlink" title="cos(x) 餘弦"></a>cos(x) 餘弦</h1><p>利用微分定義推導：</p><p>$\displaystyle{ \frac{d}{dx} cos(x) &#x3D; \lim_{h \to 0} \frac{cos(x + h) - cos(x)}{h} }$</p><p>$\displaystyle{ &#x3D; \lim_{h \to 0} \frac{cos(x)cos(h) - sin(x)sin(h) - cos(x)}{h} \text{（※ 餘弦和角公式）} }$</p><p>$\displaystyle{ &#x3D; \lim_{h \to 0} \frac{cos(x)cos(h) - cos(x) - sin(x)sin(h)}{h} }$</p><p>$\displaystyle{ &#x3D; \lim_{h \to 0} \frac{cos(x) [cos(h) - 1]}{h} - \lim_{h \to 0} \frac{sin(x)sin(h)}{h} }$</p><p>$\displaystyle{ &#x3D; cos(x) \cdot \lim_{h \to 0} \frac{cos(h) - 1}{h} - sin(x) \cdot \lim_{h \to 0} \frac{sin(h)}{h} }$</p><p>$\displaystyle{ &#x3D; cos(x) \cdot 0 - sin(x) \cdot 1 &#x3D; - sin(x) }$</p><h1 id="tan-x-正切"><a href="#tan-x-正切" class="headerlink" title="tan(x) 正切"></a>tan(x) 正切</h1><p>由 $tan(x) &#x3D; \frac{sin(x)}{cos(x)}$ 開始：</p><p>$\frac{d}{dx} tan(x) &#x3D; \frac{d}{dx} \frac{sin(x)}{cos(x)}$</p><p>$ &#x3D; \frac{\frac{d}{dx}sin(x) \cdot cos(x) - sin(x) \cdot \frac{d}{dx}cos(x)}{cos^{2}(x)} \text{（※ 微分除法公式）}$</p><p>$ &#x3D; \frac{cos(x) \cdot cos(x) - sin(x) \cdot [-sin(x)]}{cos^{2}(x)} &#x3D; \frac{cos^{2}(x) + sin^{2}(x)}{cos^{2}(x)}$</p><p>$ &#x3D; \frac{1}{cos^{2}(x)} &#x3D; sec^{2}(x)$</p><p>（※ 使用了 $sin^{2}(x) + cos^{2}(x) &#x3D; 1$ 這條式子，證明請參考：<a href="https://www.youtube.com/watch?v=91Jxfu4FntM">sin^2+cos^2&#x3D;1</a>）</p><h1 id="csc-x-餘割"><a href="#csc-x-餘割" class="headerlink" title="csc(x) 餘割"></a>csc(x) 餘割</h1><p>由 $csc(x) &#x3D; \frac{1}{sin(x)}$ 開始：</p><p>$\frac{d}{dx} csc(x) &#x3D; \frac{d}{dx} \frac{1}{sin(x)}$</p><p>$ &#x3D; \frac{\frac{d}{dx} 1 \cdot sin(x) - 1 \cdot \frac{d}{dx} sin(x)}{sin^{2}(x)} \text{（※ 微分除法公式）}$</p><p>$ &#x3D; \frac{0 \cdot sin(x) - 1 \cdot cos(x)}{sin^{2}(x)} &#x3D; - \frac{cos(x)}{sin^{2}(x)}$</p><p>$ &#x3D; - \frac{cos(x)}{sin(x)} \cdot \frac{1}{sin(x)} &#x3D; - cot(x) csc(x)$</p><h1 id="sec-x-正割"><a href="#sec-x-正割" class="headerlink" title="sec(x) 正割"></a>sec(x) 正割</h1><p>由 $sec(x) &#x3D; \frac{1}{cos(x)}$ 開始：</p><p>$\frac{d}{dx} sec(x) &#x3D; \frac{d}{dx} \frac{1}{cos(x)}$</p><p>$ &#x3D; \frac{\frac{d}{dx} 1 \cdot cos(x) - 1 \cdot \frac{d}{dx} cos(x)}{cos^{2}(x)} \text{（※ 微分除法公式）}$</p><p>$ &#x3D; \frac{0 \cdot cos(x) - 1 \cdot [-sin(x)] }{cos^{2}(x)} &#x3D; \frac{sin(x)}{cos^{2}(x)}$</p><p>$ &#x3D; \frac{sin(x)}{cos(x)} \cdot \frac{1}{cos(x)} &#x3D; tan(x) sec(x)$</p><h1 id="cot-x-餘切"><a href="#cot-x-餘切" class="headerlink" title="cot(x) 餘切"></a>cot(x) 餘切</h1><p>由 $cot(x) &#x3D; \frac{cos(x)}{sin(x)}$ 開始：</p><p>$\frac{d}{dx} cot(x) &#x3D; \frac{d}{dx} \frac{cos(x)}{sin(x)}$</p><p>$ &#x3D; \frac{\frac{d}{dx}cos(x) \cdot sin(x) - cos(x) \cdot \frac{d}{dx} sin(x)}{sin^{2}(x)} \text{（※ 微分除法公式）}$</p><p>$ &#x3D; \frac{[-sin(x)] \cdot sin(x) - cos(x) \cdot cos(x)}{sin^{2}(x)} &#x3D; \frac{ - sin^{2}(x) - cos^{2}(x)}{sin^{2}(x)}$</p><p>$ &#x3D; - {\frac{sin^{2}(x) + cos^{2}(x)}{sin^{2}(x)}} &#x3D; - \frac{1}{sin^{2}(x)} &#x3D; -csc^{2}(x)$</p><p>（※ 跟 $tan(x)$ 一樣使用了 $sin^{2}(x) + cos^{2}(x) &#x3D; 1$ 這條式子，證明請參考上面的資料。）</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>可以發現一些手法，除了 $sin(x)$ 以及 $cos(x)$ 要從定義來之外，<br>其他的有兩兩對應的步驟，像是 $tan(x)$ 跟 $cot(x)$ 就很類似、而 $csc(x)$ 跟 $sec(x)$ 也很相像。</p>]]></content>
      
      
      <categories>
          
          <category> 微積分 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>先驗算法 Apriori Algorithm</title>
      <link href="//apriori-algorithm/"/>
      <url>//apriori-algorithm/</url>
      
        <content type="html"><![CDATA[<p>資料探勘的文章，多半是我大學資料探勘課程的筆記之類的東西，<br>因為覺得內容有點雜，不是很難，就是很多東西。</p><p>所以想開個文章逐一紀錄。以後找資料也方便一點這樣。<br>不過課程吸收的感覺對這個領域把握不高，有錯誤還請見諒就是了。</p><span id="more"></span><h1 id="關聯規則"><a href="#關聯規則" class="headerlink" title="關聯規則"></a>關聯規則</h1><p>關聯規則是類似這樣的一個問題：  </p><div class="note info">            <p>如果我的客戶買了某個商品，那麼要再推薦什麼商品呢？</p>          </div><p>想當然的，推薦的商品一定是那個「很有可能被加購的」商品。</p><p>那麼，我要怎知道客戶有可能加購什麼呢？<br>事實上，我們大概可以猜到一些事情。  </p><ul><li>與「客戶的屬性」相關<ul><li>客戶是學生，而他剛剛買了筆，是不是折扣的話會買更多？</li><li>客戶是廚師的話呢？</li></ul></li><li>與「外在的屬性」相關<ul><li>天氣炎熱的話，買了午餐再買飲料的關聯，是不是會被加強？</li><li>天氣涼爽的話呢？</li></ul></li><li>與「先前購買的商品」相關  <ul><li>買了鐵鎚，是不是會繼續選購釘子呢？</li><li>推薦買了鐵鎚的人麵包如何？</li></ul></li></ul><p>而資料探勘當中，有一些方法，可以去得到這些關聯規則，</p><p>對於商業行為來說，資料探勘的重點就是找到這些隱含在資料中的「商機」。<br>然而這三種可能，我們通常關注第三種，也就是「先前購買的商品」相關的部份。</p><p>至於為什麼呢？看下面的例子，然後想想看：  </p><ul><li>某個男人在賣場中買了一個麵包，所以男人的職業是？</li><li>早上天氣還很熱，下午開始轉涼了。</li></ul><h1 id="支持率與可信度"><a href="#支持率與可信度" class="headerlink" title="支持率與可信度"></a>支持率與可信度</h1><p>在開始進行算法之前，得先介紹一下：</p><p>支持率（Support）以及可信度（Confidence）這兩個參數。  </p><ul><li>支持率：出現的概率。</li><li>可信度：條件機率，當商品出現時，出現另一件商品的概率。</li></ul><p>下面做一些描述：  </p><p>$Support(A) &#x3D; P(A)$<br>$Confidence(A \Rightarrow B) &#x3D; P(B \mid A)$  </p><p>參數的作用，從這裡可以發現一些指標：</p><div class="note info">            <p>支持率代表一條規則的重要程度。</p>          </div><p>$Confidence(A \Rightarrow B) &#x3D; 99%, Support({A, B}) &#x3D; 1%$</p><p>雖然買了 A 商品，幾乎也會買 B 商品，但出現這種買法相當罕見。<br>如果很少人會這樣買，是不是就沒有商機呢？</p><div class="note info">            <p>可信度代表一條規則的準確程度</p>          </div><div class="note info">            <p>想想看，有沒有可能出現可信度很高、但支持率很低的情況？</p>          </div><p>$Confidence(A \Rightarrow B) &#x3D; P(B \mid A) &#x3D; \frac{P(A \cap B)}{P(A)} &#x3D; \frac{Support({A, B})}{P(A)}$</p><h1 id="先驗算法"><a href="#先驗算法" class="headerlink" title="先驗算法"></a>先驗算法</h1><p>先驗算法（Apriori Algorithm）是資料探勘中的一種基本方法，<br>讓我們可以從資料中取得這些關聯規則。</p><p>實際操作的說明：  </p><ul><li>設定 $\text{minimum_support}$</li><li>計算每種商品的 $\text{support}$</li><li>刪去 $\text{support}$ 小於 $\text{minimum_support}$ 的商品</li><li>組合剩下的商品</li><li>重複 2 ～ 4 步，直到無法組合或滿足其他停止條件</li><li>計算所有的 $\text{confidence}$</li></ul><p>公式化：  </p><ul><li>$\alpha &#x3D; \text{Minimum Support}, X_{0} &#x3D; \text{All Objects}$</li><li>$X_{p+1} &#x3D; { x_{i} \cup x_{j} : support(x_{i}) &gt; \alpha \land support(x_{j}) &gt; \alpha , x_{i} \neq x_{j}, \forall x_{i}, x_{j} \in X_{p} }$</li><li>$\text{Repeat step.2, until } X_{n} &#x3D; \varnothing$</li></ul><p>大致上就這個樣子，直到 $X$ 無法組合為止，而這時的最長規則，長度為 $n-1$ 單位，<br>很多時候，由於要人工篩選規則，所以所有出現過的 $X$ 都要考慮。</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><iframe scrolling="no" width="100%" height="400px" src="https://jsfiddle.net/okfyq5ub/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>K均值算法 K-mean Algorithm</title>
      <link href="//k-mean-algorithm/"/>
      <url>//k-mean-algorithm/</url>
      
        <content type="html"><![CDATA[<p>K均值算法（K-mean Algorithm）應該可以說是最簡單的無監督學習算法了，<br>因為很直觀的關係，所以這篇應該蠻短的。</p><span id="more"></span><p>讓我們開始吧！</p><h1 id="物以類聚"><a href="#物以類聚" class="headerlink" title="物以類聚"></a>物以類聚</h1><p>想像一下，如果「物以類聚」這件事情為真的話，<br>那麼一筆一筆的資料是不是也有這樣的特性呢？</p><p>$X_{0} \approx X_{1}$</p><p>兩筆資料由於特徵相近，所以映射在高維空間中的距離接近。<br>所以說，這些散布在空間中的點，<br>如果這堆點，每個都有所屬的類別的話。</p><p>很顯然的，那就存在一個類別的中心，<br>而這個類別的中心，我們常稱作「聚類中心」。</p><p>$\mu &#x3D; \text{聚類中心}$</p><p>越靠近這個聚類中心，代表它越屬於這個類別。</p><h2 id="K個類別"><a href="#K個類別" class="headerlink" title="K個類別"></a>K個類別</h2><p>由於類別不只一個，<br>老實說，如果類別沒有兩個以上，那也不用去分了。<br>我們假定存在 $K$ 個類別的話，就有 $K$ 個聚類中心：</p><p>$\mu_{0}, \mu_{1}, … , \mu_{K}$</p><p>我們可以進一步去定義，<br>這些每個聚類都是集合，可以用來塞資料點：</p><p>$S_{j} &#x3D; \{ … \}$</p><p>如此一來，聚類中心就有定義了：</p><p>$\mu_{j} &#x3D; \frac{1}{|S_{j}|}\sum\limits_{x_{i} \in S_{j}} x_{i}$</p><p>聚類中心是「屬於聚類集合的點取平均」而來。</p><h1 id="演算法"><a href="#演算法" class="headerlink" title="演算法"></a>演算法</h1><p>接下來，是演算法的實際做法：</p><ul><li>隨機初始化聚類中心</li><li>計算資料點較接近哪個聚類中心 </li><li>把接近聚類中心的資料點塞進聚類集合</li><li>計算新的聚類中心，代替掉舊的</li><li>重複 2 ～ 5 步驟，直到不再更新為止</li></ul><p>公式的定義：</p><p>$S_{j} &#x3D; \{ x_{i} : \mid x_{i} - \mu_{j}\mid ^{2} \leq \mid x_{i} - \mu_{p}\mid ^{2} \forall p, 1 &lt; p &lt; K \}$</p><p>具體的作法就是迭代上式。至於這條公式的解釋：</p><p>第 j 個聚類集合，如果符合：<br>「第 i 筆資料與第 j 個聚類中心的距離」小於等於「第 i 筆資料與第 p 個聚類中心的距離」的話，<br>那麼第 i 筆資料就屬於第 j 個聚類集合（對於所有的 p 都要嘗試，至於 p 的範圍是 1 ～ K）</p><p>這是白話文翻譯。不過為了裝得很厲害的樣子，還是寫符號吧..XD<br>換言之，這筆資料是不是屬於這個聚類，就要嘗試看看他跟這個聚類中心的距離是不是小於等於其他聚類中心，<br>如果是則將它擺到這個聚類集合中；反之，則忽略這筆，繼續看下一筆資料。</p><p>值得一提的是，通常情況下一筆資料只會被分配到一個聚類集合。<br>依照這個定義的話，如果 $\mid x_{i} - \mu_{p}\mid ^{2} &#x3D; |x_{i} - \mu_{q}\mid ^{2}$ 也就是距離一樣的話，<br>那麼資料點 $x_{i}$ 就會被分配到最後一個算的聚類中心。</p><h2 id="形式化"><a href="#形式化" class="headerlink" title="形式化"></a>形式化</h2><ul><li>$\mu_{j} &#x3D; random$</li><li>$S_{j} &#x3D; \{ x_{i} : \mid x_{i} - \mu_{j}\mid ^{2} \leq \mid x_{i} - \mu_{p}\mid ^{2} \forall p, 1 &lt; p &lt; K \}$</li><li>$\mu_{j} &#x3D; \frac{1}{|S_{j}|}\sum\limits_{x_{i} \in S_{j}} x_{i}$</li><li>$\text{Repeat 2~3}$</li></ul><p>以上，就是所有的內容了。來看演示吧！</p><h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><iframe scrolling="no" width="100%" height="530px" src="https://jsfiddle.net/kLyn0kut/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平均值與有效值證明</title>
      <link href="//proof-mean-and-rms/"/>
      <url>//proof-mean-and-rms/</url>
      
        <content type="html"><![CDATA[<p>本篇原本從舊站搬過來時，因為內容比較偏門有考慮要刪掉。<br>但是後來想了想，作為私人筆記留下來了。</p><span id="more"></span><h1 id="交流電表示式"><a href="#交流電表示式" class="headerlink" title="交流電表示式"></a>交流電表示式</h1><p>在開始之前要先知道這個，<br>技職學校的話，大概是基本電學下半章的最後。</p><p>正弦波的情況：  </p><p>$$<br>v(t) &#x3D; V_{m}sin(\omega \cdot t+\theta)<br>$$</p><p>其中 $V_{m}$ 為峰值（最大值）也就是 $V_{peak}$ 的意思，<br>除此之外，在 $sin$ 函數內的 $\omega$ 是角頻率（$\omega &#x3D; \frac{2\pi}{T}$）。<br>最後 $\theta$ 是相位差。</p><div class="note info">            <p>參考圖形：<a href="https://www.desmos.com/calculator/xjy2v7yge7">https://www.desmos.com/calculator/xjy2v7yge7</a></p>          </div><h1 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h1><p>先來看比較簡易的平均值，平均值簡單的說就是取平均。<br>雖然聽起來像是廢話，畢竟正弦曲線誰沒看過？積分取個平均不就寫個 $0$ 而已嗎？<br>別忘了，正弦波在整流之後，它只剩下半波、或是全波。<br>也就是說，我們考慮的平均值，只要考量半波整流、或全波整流之後的就好。</p><h2 id="半波整流"><a href="#半波整流" class="headerlink" title="半波整流"></a>半波整流</h2><p>對於半波整流，由於截去 $sin$ 函數的負半周。<br>我們直接算它正半周（函數週期的一半）有多少面積、再除以它的週期 $T$ 就好。</p><p>$$<br>(\int_{0}^{\frac{T}{2}} v(t) \mathrm{d}t) &#x2F; T<br>$$</p><p>正弦波全部的週期 $T &#x3D; 2\pi$ </p><p>$$<br>V_{av} &#x3D; (\int_{0}^{\pi} V_{m}sin(\omega \cdot t+\theta) \mathrm{d}t) &#x2F; 2\pi<br>$$</p><p>角頻率 $\omega &#x3D; \frac{2\pi}{T} &#x3D; \frac{2\pi}{2\pi} &#x3D; 1$、相位差 $\theta &#x3D; 0$</p><p>$$<br>V_{av} &#x3D; (\int_{0}^{\pi} V_{m}sin(t) \mathrm{d}t) &#x2F; 2\pi<br>$$</p><p>積分中常數 $V_{m}$ 提到外面</p><p>$$<br>V_{av} &#x3D; (V_{m} \int_{0}^{\pi} sin(t) \mathrm{d}t) &#x2F; 2\pi<br>$$</p><p>對 $sin(t)$ 取反導數，準備結束這個積分</p><p>$$<br>\begin{align}<br>&amp; V_{av} &#x3D; (V_{m} (-cos(t))\mid_{0}^{\pi}) &#x2F; 2\pi \nonumber \\<br>&amp; V_{av} &#x3D; (V_{m} (-cos(\pi) + cos(0))) &#x2F; 2\pi \nonumber\\<br>&amp; V_{av} &#x3D; (V_{m} (-(-1) + 1)) &#x2F; 2\pi \nonumber\\<br>&amp; V_{av} &#x3D; (V_{m} (1 + 1)) &#x2F; 2\pi \nonumber\\<br>&amp; V_{av} &#x3D; 2V_{m} &#x2F; 2\pi \nonumber\\<br>&amp; V_{av} &#x3D; V_{m} &#x2F; \pi \nonumber\\<br>\end{align}<br>$$</p><p>得證半波整流的正弦波平均值為 $V_{m} &#x2F; \pi$</p><div class="note info">            <p>參考圖形：<a href="https://www.desmos.com/calculator/je1ka7naxl">https://www.desmos.com/calculator/je1ka7naxl</a></p>          </div><h2 id="全波整流"><a href="#全波整流" class="headerlink" title="全波整流"></a>全波整流</h2><p>全波整流跟半波整流很像，基本上換湯不換藥。<br>直接算它正半周（函數週期的一半）有多少面積，並予以雙倍（負半週被轉正），<br>再除以它的週期 $T$ 就好。</p><p>$$<br>2(\int_{0}^{\frac{T}{2}} v(t) \mathrm{d}t) &#x2F; T<br>$$</p><p>正弦波全部的週期 $T &#x3D; 2\pi$ </p><p>$$<br>V_{av} &#x3D; 2(\int_{0}^{\pi} V_{m}sin(\omega \cdot t+\theta) \mathrm{d}t) &#x2F; 2\pi<br>$$</p><p>角頻率 $\omega &#x3D; \frac{2\pi}{T} &#x3D; \frac{2\pi}{2\pi} &#x3D; 1$、相位差 $\theta &#x3D; 0$</p><p>$$<br>V_{av} &#x3D; 2(\int_{0}^{\pi} V_{m}sin(t) \mathrm{d}t) &#x2F; 2\pi<br>$$</p><p>常數 $V_{m}$ 提到外面，順便把 $2$ 常數約掉</p><p>$$<br>\begin{align}<br>&amp; V_{av} &#x3D; (V_{m} \int_{0}^{\pi} sin(t) \mathrm{d}t) &#x2F; \pi \nonumber \\<br>&amp; V_{av} &#x3D; (V_{m} (-cos(t))\mid_{0}^{\pi}) &#x2F; \pi \nonumber \\<br>&amp; V_{av} &#x3D; (V_{m} (-cos(\pi) + cos(0))) &#x2F; \pi \nonumber \\<br>&amp; V_{av} &#x3D; (V_{m} (-(-1) + 1)) &#x2F; \pi \nonumber \\<br>&amp; V_{av} &#x3D; (V_{m} (1 + 1)) &#x2F; \pi \nonumber \\<br>&amp; V_{av} &#x3D; 2V_{m} &#x2F; \pi \nonumber \\<br>&amp; V_{av} &#x3D; 2V_{m} &#x2F; \pi \nonumber \\<br>\end{align}<br>$$</p><p>得證全波整流的正弦波平均值為 $2V_{m} &#x2F; \pi$</p><div class="note info">            <p>參考圖形：<a href="https://www.desmos.com/calculator/fnaaqr3fom">https://www.desmos.com/calculator/fnaaqr3fom</a></p>          </div><h1 id="有效值"><a href="#有效值" class="headerlink" title="有效值"></a>有效值</h1><p>有效值比較機車，不過也沒啥困難的，<br>唯一要注意的是，它會用到三角函數的半角公式。<br>有效值又名「均方根」值，顧名思義：先開方平均、再取根號。  </p><p>對於連續函數 $f(x)$ 在區間 $[a, b]$ 來說：</p><p>$$<br>f(x) &#x3D; \sqrt{\frac{1}{b - a}\int_{a}^{b} f(x)^2  \mathrm{d}x}<br>$$</p><p>寫成我們交流電的形式（區間在 $[0, 2\pi]$）：<br>$$<br>V_{rms} &#x3D; \sqrt{\frac{1}{2\pi}\int_{0}^{2\pi} v(t)^2  \mathrm{d}t}<br>$$</p><p>我們來考慮半波、跟全波整流後的情況。</p><h2 id="半波整流-1"><a href="#半波整流-1" class="headerlink" title="半波整流"></a>半波整流</h2><p>半波整流中，負半週整個被刪去。<br>所以說，我們積分的區間要改成 $[0, \pi]$ 才正確。</p><p>$$<br>V_{rms} &#x3D; \sqrt{\frac{1}{2\pi}\int_{0}^{\pi} v(t)^2  \mathrm{d}t}<br>$$</p><p>把 $v(t)$ 代換掉，另外角頻率 $\omega &#x3D; \frac{2\pi}{T} &#x3D; \frac{2\pi}{2\pi} &#x3D; 1$、相位差 $\theta &#x3D; 0$。</p><p>$$<br>\begin{align}<br>&amp; V_{rms} &#x3D; \sqrt{\frac{1}{2\pi}\int_{0}^{\pi} (V_{m}sin(\omega \cdot t+\theta))^2  \mathrm{d}t} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{1}{2\pi}\int_{0}^{\pi} (V_{m}sin(t))^2  \mathrm{d}t} \nonumber \\<br>\end{align}<br>$$</p><p>把積分那邊的平方移進去，常數 $V_{m}^{2}$ 移出積分。</p><p>$$<br>V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{2\pi}\int_{0}^{\pi} sin(t)^2  \mathrm{d}t}<br>$$</p><p>接下來很關鍵，半角公式登場 $sin^{2}(x) &#x3D; \frac{1}{2}(1 - cos(2x))$  </p><p>$$<br>V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{2\pi}\int_{0}^{\pi} \frac{1}{2}(1 - cos(2x)) \mathrm{d}t}<br>$$</p><p>常數通通丟出去。</p><p>$$<br>V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{4\pi}\int_{0}^{\pi} 1 - cos(2x) \mathrm{d}t}<br>$$</p><p>取 $1 - cos(2x)$ 的反導數準備結束積分。</p><p>$$<br>\begin{align}<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{4\pi} (x - \frac{1}{2}sin(2x))\mid_{0}^{\pi}} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{4\pi} (\pi - \frac{1}{2}sin(2\pi)) - (0 - \frac{1}{2}sin(0))} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{4\pi} (\pi - \frac{1}{2}sin(2\pi)) - (0 - 0)} \nonumber \\<br>\end{align}<br>$$</p><p>當中 $sin(2\pi) &#x3D; 0$ 直接拿掉</p><p>$$<br>\begin{align}<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{4\pi} (\pi - 0)} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{(V_{m}^2)(\pi)}{4\pi}} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{(V_{m}^2)}{4}} \nonumber \\<br>&amp; V_{rms} &#x3D; \frac{\sqrt{V_{m}^2}}{\sqrt{4}} \nonumber \\<br>&amp; V_{rms} &#x3D; \frac{V_{m}}{2}  \nonumber \\<br>\end{align}<br>$$</p><p>半波整流的有效值，是最大值（峰值）的一半。</p><div class="note info">            <p>參考圖形：<a href="https://www.desmos.com/calculator/qfo1snucty">https://www.desmos.com/calculator/qfo1snucty</a></p>          </div><h2 id="全波整流-1"><a href="#全波整流-1" class="headerlink" title="全波整流"></a>全波整流</h2><p>在積分那邊，取個雙倍而已。</p><p>$$<br>\begin{align}<br>&amp; V_{rms} &#x3D; \sqrt{\frac{1}{2\pi} 2\int_{0}^{\pi} v(t)^2  \mathrm{d}t} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{1}{\pi}\int_{0}^{\pi} (V_{m}sin(\omega \cdot t+\theta))^2  \mathrm{d}t} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{1}{\pi}\int_{0}^{\pi} (V_{m}sin(t))^2  \mathrm{d}t} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{\pi}\int_{0}^{\pi} sin(t)^2  \mathrm{d}t} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{\pi}\int_{0}^{\pi} \frac{1}{2}(1 - cos(2x)) \mathrm{d}t} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{2\pi}\int_{0}^{\pi} 1 - cos(2x) \mathrm{d}t} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{2\pi} (x - \frac{1}{2}sin(2x))\mid_{0}^{\pi}} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{2\pi} (\pi - \frac{1}{2}sin(2\pi)) - (0 - \frac{1}{2}sin(0))} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{2\pi} (\pi - \frac{1}{2}sin(2\pi)) - (0 - 0)} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{V_{m}^2}{2\pi} (\pi - 0)} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{(V_{m}^2)(\pi)}{2\pi}} \nonumber \\<br>&amp; V_{rms} &#x3D; \sqrt{\frac{(V_{m}^2)}{2}} \nonumber \\<br>&amp; V_{rms} &#x3D; \frac{\sqrt{V_{m}^2}}{\sqrt{2}} \nonumber \\<br>&amp; V_{rms} &#x3D; \frac{V_{m}}{\sqrt{2}} \nonumber \\<br>\end{align}<br>$$</p><div class="note info">            <p>參考圖形：<a href="https://www.desmos.com/calculator/bmnutv8k7m">https://www.desmos.com/calculator/bmnutv8k7m</a></p>          </div>]]></content>
      
      
      <categories>
          
          <category> 基本電學與電子學 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>老鼠走迷宮 Mouse Maze</title>
      <link href="//mouse-maze/"/>
      <url>//mouse-maze/</url>
      
        <content type="html"><![CDATA[<p>這是資料結構第三次作業。<br>本篇老鼠走迷宮會大致上分成：「生成迷宮」與「解出迷宮」兩個部分。</p><span id="more"></span><h1 id="建立迷宮"><a href="#建立迷宮" class="headerlink" title="建立迷宮"></a>建立迷宮</h1><p>老鼠走迷宮畢竟是一個經典問題，當然對於迷宮生成也是，<br>所以已經有許多很棒的網路資源可以參考了。</p><div class="note info">            <p>我覺得很棒的 <a href="http://hctu.blogspot.tw/search?q=%E8%BF%B7%E5%AE%AE%5C">參考資料</a></p>          </div><div class="note success">            <p>本文改寫前使用碎形結構建立迷宮。<!-- ；請參閱 [L系統與碎形 L-system and Fractal](/2018/03/03/L系統與碎形%20L-system%20and%20Fractal/#more) --></p>          </div><p>那接下來，我就不重複裡面的內容，畢竟重複就沒有太大的意義。<br>我會依照我原先的想法來製作迷宮。</p><p>好的迷宮是又亂又複雜的，所以直觀的想法是：使用亂數。</p><p>參考室內結構來說，梁柱、牆板之類的部分是必要的；<br>我想迷宮也一樣，而且我們最好有一條路徑可以找到出口。</p><p>對於亂數生成的做法來講，以下提供基本操作的想法：</p><ul><li>產生入口</li><li>產生出口</li><li>格子狀佈滿柱子</li><li>柱子間隨機方向延伸 1 格成為牆板，或不延伸</li><li>輸出迷宮</li></ul><div class="note info">            <p>好的迷宮有哪些特徵呢？</p>          </div><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>演示提供三個參數可以調整。</p><p>我增加了柱子間連接的機率，也就是說，即使選取了A、B兩個柱子。<br>也要剛好機會符合才相接牆面，間接降低了圖形的密度。</p><iframe scrolling="no" width="100%" height="560px" src="https://jsfiddle.net/rzun2ogn/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="迷宮解法"><a href="#迷宮解法" class="headerlink" title="迷宮解法"></a>迷宮解法</h1><div class="note success">            <p>本段需有堆疊與佇列的先備知識；請參閱 <a href="/stack-and-queue/" title="堆疊與佇列 Stack and Queue">堆疊與佇列 Stack and Queue</a></p>          </div><p>其實在之前 ITSA 中就有這樣的題目，<br>當時是採用複製地圖副本且標記的作法來解，也順利解出來了。<br>其實是同一類的做法，只差在這邊多了一種資料結構來控制與調整。</p><p>有趣的是，如果直接在地圖上記錄哪裡走過，<br>最後輸出路徑還是需要掃描一次地圖。</p><p>下面是解法的粗略步驟：  </p><ol><li>堆疊初始化（存入第一步）</li><li>根據堆疊內的資料走出下一步</li><li>走出下一步時將資料存入堆疊</li><li>重複 2 ~ 3 步驟，直到堆疊為空或到達出口</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 給予第一步</span></span><br><span class="line"><span class="built_in">stack</span>.push((<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 尚有路徑沒試</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">stack</span>.empty())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 走回頭路</span></span><br><span class="line">    obj step = <span class="built_in">stack</span>.pop();</span><br><span class="line">    x = step.x;</span><br><span class="line">    y = step.y;</span><br><span class="line">    dir = step.dir;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 嘗試每個方向</span></span><br><span class="line">    <span class="keyword">while</span>(dir)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下一步的位置</span></span><br><span class="line">        u = x + dx;</span><br><span class="line">        v = y + dy;</span><br><span class="line">        <span class="comment">// 下一步可以通行</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[u][v].through())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 把這步塞進堆疊</span></span><br><span class="line">            <span class="built_in">stack</span>.push((x, y));</span><br><span class="line">            <span class="comment">// 移動到下一步</span></span><br><span class="line">            x = u;</span><br><span class="line">            y = v;</span><br><span class="line">            <span class="comment">// 發現這步正是終點</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[x][y].end?())</span><br><span class="line">                outputResult();</span><br><span class="line">            <span class="comment">//方向重置</span></span><br><span class="line">            dir.initialize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所有路徑都已經嘗試</span></span><br><span class="line"><span class="comment">// 但沒有走到終點，代表無解</span></span><br><span class="line">noResult();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這邊巧妙的利用方向重置來找路，並僅使用一行掉頭找其他路徑。</p><div class="note info">            <p>迷宮的布局、嘗試方向的順序，皆會影響解出迷宮的時間。</p>          </div><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><iframe scrolling="no" width="100%" height="540px" src="https://jsfiddle.net/suws2m74/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆疊與佇列 Stack and Queue</title>
      <link href="//stack-and-queue/"/>
      <url>//stack-and-queue/</url>
      
        <content type="html"><![CDATA[<p>本文僅為資料結構的筆記。</p><p>對於較高階的語言來說有許多現成的函式庫，<br>儘管如此，還是需要瞭解基本規則。</p><span id="more"></span><h1 id="堆疊"><a href="#堆疊" class="headerlink" title="堆疊"></a>堆疊</h1><p>堆疊是一種基本結構，核心的思維是「先進後出」。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//create stack</span></span><br><span class="line"><span class="type">int</span> stack[SIZE];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack push data</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack[top++] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//stack pop data</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack[--top];</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這是 C&#x2F;C++ 的作法，<br>對於更高階的語言（比方說 JavaScript）來說，<br>這些功能都已經內建了。</p><div class="note info">            <p>實際上 C++ STL 有內建；另外雖然建立很簡單，但 C 語言方面也有函示庫可以使用。</p>          </div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">//create stack</span></span><br><span class="line">stack.<span class="title function_">push</span>(..);          <span class="comment">//stack push data</span></span><br><span class="line">stack.<span class="title function_">pop</span>(..);           <span class="comment">//stack pop data</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>接下來來看看基本堆疊的資料進出方式。</p><iframe scrolling="no" width="100%" height="300px" src="https://jsfiddle.net/6xb1L6my/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="佇列"><a href="#佇列" class="headerlink" title="佇列"></a>佇列</h1><p>佇列是一種基本結構，核心的思維是「先進先出」。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//create queue</span></span><br><span class="line"><span class="type">int</span> queue[SIZE];</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//queue push data</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue[top++] = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//queue shift data</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shift</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> data = queue[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">        queue[i] = queue[i + <span class="number">1</span>];</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這是C&#x2F;C++的作法，<br>對於更高階的語言（比方說 JavaScript）來說，<br>這些功能都也已經內建了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> queue = <span class="keyword">new</span> <span class="title class_">Array</span>(); <span class="comment">//create queue</span></span><br><span class="line">queue.<span class="title function_">push</span>(..);          <span class="comment">//queue push data</span></span><br><span class="line">queue.<span class="title function_">shift</span>(..);         <span class="comment">//queue shift data</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><p>接下來來看看基本佇列的資料進出方式。</p><iframe scrolling="no" width="100%" height="300px" src="https://jsfiddle.net/zfq3ucak/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>魔方陣 Magic Square</title>
      <link href="//magic-square/"/>
      <url>//magic-square/</url>
      
        <content type="html"><![CDATA[<p>這個是我們資料結構（Data Structure）的第二次作業，<br>本文紀錄了<strong>奇數</strong>、<strong>雙偶數</strong>以及<strong>單偶數</strong>魔方陣（Magic Square）的做法。</p><span id="more"></span><p>老實說，上課不斷的聯想到太鼓達人的 ★9 曲「魔方陣-サモン・デルタ-」</p><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/UgK1_AflaME" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><h1 id="魔方陣定義"><a href="#魔方陣定義" class="headerlink" title="魔方陣定義"></a>魔方陣定義</h1><p>魔方陣定義是這樣的：</p><ul><li>每一行（Column）的總和</li><li>每一列（Row）的總和</li><li>對角線的總和</li><li>上面每一個值都相等</li></ul><div class="note info">            <p>這邊採用了<strong>直行橫列</strong>的說法。</p>          </div><p>比方說圖 1 這樣：<br><img src="https://i.imgur.com/50hRjKi.png" alt="圖 1、$3$ x $3$ 與 4x4 魔方陣例子"></p><p>接下來我會記錄如何製作魔方陣。</p><h1 id="奇數魔方陣"><a href="#奇數魔方陣" class="headerlink" title="奇數魔方陣"></a>奇數魔方陣</h1><p>奇數的魔方陣是魔方陣中比較簡單的一種，構造方式相當容易。<br>正常情況下，給定一個 $n$ 在 $O(n^2)$ 時間複雜度內就可以完成。</p><ul><li>第一列（Row）中間放「1」</li><li>不斷<strong>往左上角移動（走出方格從對面出現）</strong>、放入下一個數字</li><li>如果左上角空間<strong>已有數字，則往下放一格</strong></li></ul><p>以 $3$ x $3$ 魔方陣為例（$n &#x3D; 3$）：</p><p>第一步：如圖 2 在中間上面放「1」</p><p><img src="https://i.imgur.com/SCB43cG.png" alt="圖 2、$3$ x $3$ 魔方陣第 1 步"></p><p>第二步：如圖 3 不斷往左上走。同時累進數字。<br>（這個 1 從上方跑出方陣、於是 2 應該在下面。）</p><p><img src="https://i.imgur.com/Invvg6W.png" alt="圖 3、$3$ x $3$ 魔方陣第 2 步"></p><p>如圖 4 我們接下來不斷重複。</p><p><img src="https://i.imgur.com/YweZ4PI.png" alt="圖 4、$3$ x $3$ 魔方陣第 2 步重複"></p><p>第三步：如圖 5 這個 3 的左上方已經有數字，於是往下放一格。</p><p><img src="https://i.imgur.com/DK9XvRB.png" alt="圖 5、$3$ x $3$ 魔方陣第 3 步"></p><p>依照這個步驟繼續完成。</p><p><img src="https://i.imgur.com/7xFxDuz.png" alt="圖 6、$3$ x $3$ 魔方陣"></p><p>如圖 6 所示，我們最終就得到一個不錯的方陣。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>只要考慮跑出方陣、以及碰撞到有值的格子就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//計算下一步的座標</span></span><br><span class="line">x = (x - <span class="number">1</span> &amp;lt; <span class="number">0</span>)? width : x - <span class="number">1</span>;</span><br><span class="line">y = (y - <span class="number">1</span> &amp;lt; <span class="number">0</span>)? height : y - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果下一步有值</span></span><br><span class="line"><span class="keyword">if</span>(!empty(<span class="built_in">map</span>[x][y]))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//先回到上一步</span></span><br><span class="line">    x = tx;</span><br><span class="line">    y = ty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往下移動一格</span></span><br><span class="line">    y = (y + <span class="number">1</span> &amp;gt; height)? <span class="number">0</span> : y + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//確定位置後，填入數值</span></span><br><span class="line"><span class="built_in">map</span>[x][y] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//記錄這一步的座標</span></span><br><span class="line">tx = x;</span><br><span class="line">ty = y;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><iframe scrolling="no" width="100%" height="280px" src="https://jsfiddle.net/yq50092e/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="雙偶數魔方陣"><a href="#雙偶數魔方陣" class="headerlink" title="雙偶數魔方陣"></a>雙偶數魔方陣</h1><p>雙偶數指的是 4 的倍數。這類型的魔方陣比奇數更複雜一些。<br>雙偶數的魔方陣的做法：</p><ul><li>先<strong>按照順序填入</strong></li><li>找到<strong>主對角線</strong></li><li>找到<strong>副對角線</strong></li><li>把不在對角線上的值依序取下</li><li>把取下的值從後面<strong>反過來填上</strong></li></ul><p>重點在於，何謂主、副對角線呢？<br>這邊的解釋是，任何可以切割成方格的樣子。</p><p><img src="https://i.imgur.com/7xFxDuz.png" alt="圖 7、$4$ x $4$ 魔方陣（藍色為主對角線）"></p><p><img src="https://i.imgur.com/tq5mSR8.png" alt="圖 8、$8$ x $8$ 魔方陣（藍色為主對角線、紅色為副對角線）"></p><p>從圖 7 與圖 8 就可以看出來，藍色背景的是我所認知的「主對角線」、而紅色背景是「副對角線」。</p><ul><li>當 $n &#x3D; 4$ 時，沒有副對角線。</li><li>當 $n \geq 8$ 時，有副對角線。</li></ul><h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>最麻煩的是、你如何抓對角線呢？<br>讓我們來仔細觀察看看圖 9：</p><p><img src="https://i.imgur.com/naerzSE.png" alt="圖 9、對角線座標觀察"></p><p>不曉得有沒有發現呢？ 他縱向、橫向的規律是一致的。<br>然後他對角線上的值有這樣的特性：</p><ul><li>位置 $(x, y)$</li><li>如果 $x \mod 4 &#x3D; 0$ 或 $3$ 且 $y \mod 4 &#x3D; 0$ 或 $3$（上方紅色）</li><li>如果 $x \mod 4 &#x3D; 1$ 或 $2$ 且 $y \mod 4 &#x3D; 1$ 或 $2$（上方藍色）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//弄個陣列</span></span><br><span class="line"><span class="built_in">array</span> = []</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍歷位置</span></span><br><span class="line"><span class="keyword">for</span>(x is <span class="number">0</span> to width)</span><br><span class="line">    <span class="keyword">for</span>(y is <span class="number">0</span> to height)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//屬於非對角線的話，推入陣列</span></span><br><span class="line">        <span class="keyword">if</span>(belong(x, y))</span><br><span class="line">            <span class="built_in">array</span>.push((x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//翻轉陣列</span></span><br><span class="line"><span class="built_in">array</span>.reverse();</span><br><span class="line"></span><br><span class="line"><span class="comment">//最後填回</span></span><br><span class="line"><span class="keyword">for</span>(x is <span class="number">0</span> to width)</span><br><span class="line">    <span class="keyword">for</span>(y is <span class="number">0</span> to height)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//屬於非對角線的話，從陣列中回填</span></span><br><span class="line">        <span class="keyword">if</span>(belong(x, y))</span><br><span class="line">            (x, y) = <span class="built_in">array</span>.pop();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>這樣就可以把雙偶數魔方陣完成。</p><h2 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h2><iframe scrolling="no" width="100%" height="280px" src="https://jsfiddle.net/744xrkk1/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe><h1 id="單偶數魔方陣"><a href="#單偶數魔方陣" class="headerlink" title="單偶數魔方陣"></a>單偶數魔方陣</h1><p>這是所有方陣中最複雜的。但其也有跡可循。<br>然而我們可以觀察到，它的大小：$n &#x3D; 4k+2$<br>舉例來說：</p><ul><li>$k &#x3D; 1$、$n &#x3D; 4+2 &#x3D; 6$</li><li>$k &#x3D; 2$、$n &#x3D; 8+2 &#x3D; 10$</li><li>…</li></ul><div class="note warning">            <p>注意：當 $k &#x3D; 0$ 時，則 $n &#x3D; 2$ 的 2x2 魔方陣並不存在。</p>          </div><p>除了奇數、4 的倍數外、剩下的剛好都是 $4k+2$ 的形式。<br>這種方陣的樣貌大致上呈現，如圖 10 及圖 11 這樣：</p><p><img src="https://i.imgur.com/sXPLdE7.png" alt="圖 10、6x6 魔方陣（$n=6$、$k=1$）"></p><p><img src="https://i.imgur.com/bPsDTMt.png" alt="圖 11、10x10 魔方陣（$n=10$、$k=2$）"></p><p>這邊來敘述這種方陣的構成：</p><ul><li>先構造一個 $n &#x2F; 2$ 的魔方陣，作為子方陣</li><li>拼合 4 個子方陣（規則下面會說明）</li><li>透過 $k &#x3D; (n - 2) &#x2F; 4$ 求出 $k$</li><li>搬動方陣內的元素</li></ul><p>我們以 $n &#x3D; 6$ 為例子。<br>首先，我們得構造一個 $3$ x $3$ 的魔方陣，如圖 12：</p><p><img src="https://i.imgur.com/CZBPgzy.png" alt="圖 12、$3$ x $3$ 魔方陣"></p><p>接著我們要拚合子方陣。先看圖 13：</p><p><img src="https://i.imgur.com/totfAHj.png" alt="圖 13、拼合子方陣結構"></p><p>總共會把子方陣複製 4 份貼在 $6$ x $6$ 的方陣中。<br>不過還得加上一個常數：$m \cdot (n &#x2F; 2)^2$</p><ul><li>A 區塊 $m &#x3D; 0$、所以方陣中元素加 $0$</li><li>B 區塊 $m &#x3D; 2$、所以方陣中元素加 $2 \cdot 3^2 &#x3D; 18$</li><li>C 區塊 $m &#x3D; 3$、所以方陣中元素加 $3 \cdot 3^2 &#x3D; 27$</li><li>D 區塊 $m &#x3D; 1$、所以方陣中元素加 $1 \cdot 3^2 &#x3D; 9$</li></ul><p>將其累進拚合後：</p><p><img src="https://i.imgur.com/2yCaG9e.png" alt="圖 14、拼合方陣"></p><p>這樣就拚合了 4 個子方陣成為一個大的 6x6 方陣，如圖 14。<br>不過還沒有完成。我們得搬動一些元素才行。</p><p>接著，透過 $k &#x3D; (n - 2) &#x2F; 4$ 求出 $k$。$n &#x3D; 6$ 代表 $k &#x3D; 1$<br>然後把矩陣分成上下兩塊，如圖 15：</p><p><img src="https://i.imgur.com/yl17sjK.png" alt="圖 15、拼合方陣上下分割"></p><p>搬動元素的規則為：</p><ul><li>上面區塊的左上角 $k$ x $k$ 方陣跟下方換。</li><li>上面區塊的左下角 $k$ x $k$ 方陣跟下方換。</li><li>上面區塊的中間列（Row）從 $k$ 位置向右 $k$ 格跟下方換</li><li>上面矩陣的 $(n&#x2F;2) + \lfloor n&#x2F;4 \rfloor$（也就是右半邊的中間）處向右 $k - 1$ 格跟下方換</li></ul><p>實際標記看看，上面區塊的左上角 $k$ x $k$ 方陣跟下方換（$k &#x3D; 1$），如圖 16：</p><p><img src="https://i.imgur.com/k0w6LsS.png" alt="圖 16、交換左上角區塊"></p><p>上面區塊的左下角 $k$ x $k$ 方陣跟下方換（$k &#x3D; 1$），如圖 17：</p><p><img src="https://i.imgur.com/pyDJ8bL.png" alt="圖 17、交換左下角區塊"></p><p>上面區塊的中間列（Row）從 $k$ 位置（綠框）向右 $k$ 格（藍框）跟下方換（$k &#x3D; 1$），如圖 18：</p><p><img src="https://i.imgur.com/8kVKxGT.png" alt="圖 18、交換中間列區塊"></p><div class="note warning">            <p>注意計算綠框向右 $k$ 格時，綠框自己不算是 1 格。</p>          </div><p>上面矩陣的 $(n&#x2F;2) + \lfloor n&#x2F;4 \rfloor$ 處向右 $k - 1$ 格跟下方換，<br>這邊理解一下，雖然看起來很複雜，但 $n&#x2F;2$ 是子方陣的大小、$(n&#x2F;2)&#x2F;2$ 恰為子方陣大小的一半。<br>從綠框處（含）、往右 $0$ 格（藍框、因為是 $0$ 而無法顯示）如圖 19：</p><p><img src="https://i.imgur.com/yEXXqu3.png" alt="圖 19、交換右側直行區塊"></p><div class="note info">            <p>您可以在演示區使用 $10$ x $10$ 的魔方陣觀察這一步。</p>          </div><p>這樣最後得到的，如圖 20 就是完好的魔方陣了。</p><p><img src="https://i.imgur.com/V4dCf8W.png" alt="圖 20、$6$ x $6$ 魔方陣"></p><h2 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h2><p>知道了構造方式、接下來的只是土法煉鋼。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//生成 nxn 空間</span></span><br><span class="line"><span class="built_in">map</span>[n][n];</span><br><span class="line"></span><br><span class="line"><span class="comment">//奇數方陣大小</span></span><br><span class="line">odd_size = n/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//構造奇數方陣</span></span><br><span class="line">odd_magic = magic(odd_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//組合子方陣</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&amp;lt;odd_size; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&amp;lt;odd_size; y++)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="comment">//組合 A 子方陣</span></span><br><span class="line">        <span class="built_in">map</span>[x][y] = odd_magic[x][y];</span><br><span class="line">        <span class="comment">//組合 B 子方陣</span></span><br><span class="line">        <span class="built_in">map</span>[x+(n/<span class="number">2</span>)][y] = odd_magic[x][y] + <span class="number">2</span>*<span class="built_in">pow</span>(odd_size, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//組合 C 子方陣</span></span><br><span class="line">        <span class="built_in">map</span>[x][y+(n/<span class="number">2</span>)] = odd_magic[x][y] + <span class="number">3</span>*<span class="built_in">pow</span>(odd_size, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//組合 D 子方陣</span></span><br><span class="line">        <span class="built_in">map</span>[x+(n/<span class="number">2</span>)][y+(n/<span class="number">2</span>)] = odd_magic[x][y] + <span class="number">1</span>*<span class="built_in">pow</span>(odd_size, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//計算 k 值</span></span><br><span class="line">k = (n - <span class="number">2</span>)/<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交換左上角區塊</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&amp;lt;k; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&amp;lt;k; y++)</span><br><span class="line">        swap(<span class="built_in">map</span>[x][y], <span class="built_in">map</span>[x][y+odd_size]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交換左下角區塊</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&amp;lt;k; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&amp;lt;k; y++)</span><br><span class="line">        swap(<span class="built_in">map</span>[x][odd_size-y], <span class="built_in">map</span>[x][n-y]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交換中間區塊</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>; x&amp;lt;k; x++)</span><br><span class="line">    swap(<span class="built_in">map</span>[k+x][odd_size/<span class="number">2</span>], <span class="built_in">map</span>[k+x][n-(odd_size/<span class="number">2</span>)]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交換右邊的(k-1)區塊</span></span><br><span class="line">pos = oddsize + (odd_size/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=pos; x&amp;lt;pos+k<span class="number">-1</span>; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&amp;lt;odd_size; y++)</span><br><span class="line">        swap(<span class="built_in">map</span>[x][y], <span class="built_in">map</span>[x][y+odd_size]);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h2><iframe scrolling="no" width="100%" height="410px" src="https://jsfiddle.net/1samkxs3/embedded/result,js,html,css/dark" frameborder="0" loading="lazy" allowfullscreen></iframe>]]></content>
      
      
      <categories>
          
          <category> 資料結構與演算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
